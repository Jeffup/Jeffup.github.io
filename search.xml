<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>工具OllyDbg的使用</title>
    <url>/2019/11/10/%E5%B7%A5%E5%85%B7OllyDbg%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>汇编语言(入门学习)</title>
    <url>/2019/11/10/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80-%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<h4 id="简介：本篇旨在对汇编的基础知识进行汇总，汇总的都是要点（简明扼要），目前还在更新中。"><a href="#简介：本篇旨在对汇编的基础知识进行汇总，汇总的都是要点（简明扼要），目前还在更新中。" class="headerlink" title="简介：本篇旨在对汇编的基础知识进行汇总，汇总的都是要点（简明扼要），目前还在更新中。"></a>简介：本篇旨在对汇编的基础知识进行汇总，汇总的都是要点（简明扼要），目前还在更新中。</h4><a id="more"></a>
<h1 id="第一章-基础知识"><a href="#第一章-基础知识" class="headerlink" title="第一章 基础知识"></a>第一章 基础知识</h1><h2 id="1-1-存储单元"><a href="#1-1-存储单元" class="headerlink" title="1.1 存储单元"></a>1.1 存储单元</h2><p>一个存储单元存储的信息量以<strong>bit</strong>为单位（最小）。而转换关系中8 bit=1 bytes(B)。而一个字=两个字节<br>在微型计算机存储器的存储单元中，一个单元可以存<strong>1 B</strong>（即8个进制位）。而一个存储器有128个单元，则可以存储128 B。</p>
<h2 id="1-2-CPU对存储器的读写"><a href="#1-2-CPU对存储器的读写" class="headerlink" title="1.2 CPU对存储器的读写"></a>1.2 CPU对存储器的读写</h2><p>要读写，则应该与三类信息进行交互：</p>
<blockquote>
<ol>
<li>地址信息</li>
<li>控制信息</li>
<li>数据信息</li>
</ol>
</blockquote>
<p>而逻辑上又分为3类总线，分别传输信息：</p>
<blockquote>
<ol>
<li>地址总线（指出内存中的信息放在那里(自下而上读01)）</li>
<li>控制总线（若要传输的数据多于一次性传输的宽度，则分开来多传几次）</li>
<li>数据总线</li>
</ol>
</blockquote>
<h3 id="1-2-1-影响性能的因素："><a href="#1-2-1-影响性能的因素：" class="headerlink" title="1.2.1 影响性能的因素："></a>1.2.1 影响性能的因素：</h3><h4 id="宽度（线的条数）：它决定了部件的能力（速度，控制能力等）。8086为16条，8088为8条"><a href="#宽度（线的条数）：它决定了部件的能力（速度，控制能力等）。8086为16条，8088为8条" class="headerlink" title="宽度（线的条数）：它决定了部件的能力（速度，控制能力等）。8086为16条，8088为8条"></a>宽度（线的条数）：它决定了部件的能力（速度，控制能力等）。8086为16条，8088为8条</h4><blockquote>
<p>若CPU的寻址能力为8KB，则总线宽度：8*1024/1 = $2^13$ (注意单位是B,13则为总线宽度)</p>
</blockquote>
<h1 id="第二章-寄存器"><a href="#第二章-寄存器" class="headerlink" title="第二章 寄存器"></a>第二章 寄存器</h1><h2 id="2-1-通用寄存器"><a href="#2-1-通用寄存器" class="headerlink" title="2.1 通用寄存器"></a>2.1 通用寄存器</h2><p>有<strong>AX BX CX DX</strong>四种，它们分为高位和低位以兼容以前的程序，如（AX = AH(高) + AL(低)）<br><em>要注意的是：若只用AL进行运算，若超出其范围，超出的数据不会到AH当中！</em></p>
<h2 id="2-2-CPU给出物理地址的方法"><a href="#2-2-CPU给出物理地址的方法" class="headerlink" title="2.2 CPU给出物理地址的方法"></a>2.2 CPU给出物理地址的方法</h2><blockquote>
<p>段地址(<strong>SA</strong>)：只是为了内存的管理，并不是真分段。16位地址分段，一段64KB<br>偏移地址(<strong>EA</strong>)：16位地址最多64KB<br>公式：物理地址=段地址*16+偏移地址</p>
</blockquote>
<h2 id="2-3-段寄存器"><a href="#2-3-段寄存器" class="headerlink" title="2.3 段寄存器"></a>2.3 段寄存器</h2><p>有<strong>CS DS SS ES</strong>四种。CS常存储段地址。它们提供了一下功能：</p>
<ol>
<li>CS：CPU要<strong>执行指令</strong>的地址。相当于命令指针</li>
<li>DS：读取内存的地址（返回数据）。相当于数据指针</li>
<li>SS：存储内存中的栈的顶。相当于栈顶指针</li>
</ol>
<h3 id="2-3-1-CS和IP"><a href="#2-3-1-CS和IP" class="headerlink" title="2.3.1 CS和IP"></a>2.3.1 CS和IP</h3><p>IP是存储基于CS的偏移量。修改的流程：</p>
<blockquote>
<p>一般流程：读取指令 -&gt; 修改 IP+=<em>命令长度</em> -&gt; 执行指令(可能会涉及修改CS:IP) -&gt; 读取指令…<br><em>8086PC启动时在FFFF0H单元中读取指令执行</em></p>
</blockquote>
<h2 id="2-4-疑问"><a href="#2-4-疑问" class="headerlink" title="2.4 疑问"></a>2.4 疑问</h2><h3 id="1-为什么偏移地址只能在64Kb内？"><a href="#1-为什么偏移地址只能在64Kb内？" class="headerlink" title="1. 为什么偏移地址只能在64Kb内？"></a>1. 为什么偏移地址只能在64Kb内？</h3><p>一个16位的CPU，只能有1111 1111 1111 1111，代表了4个16进制数，所以能表示2**16 bit的数据，恰好，就是64Kb。</p>
<h3 id="2-暂留"><a href="#2-暂留" class="headerlink" title="2.暂留"></a>2.暂留</h3><h1 id="第三章-寄存器（内存访问）"><a href="#第三章-寄存器（内存访问）" class="headerlink" title="第三章 寄存器（内存访问）"></a>第三章 寄存器（内存访问）</h1><h2 id="3-1-内存中字的存储"><a href="#3-1-内存中字的存储" class="headerlink" title="3.1 内存中字的存储"></a>3.1 内存中字的存储</h2><blockquote>
<p>字单元的概念：即存放一个字型数据的内存单元，由<strong>两个地址连续</strong>的内存单元（一个8位）组成。高放高位，低放低位。</p>
</blockquote>
<p>这里解释一下： 若有单元[0]-&gt;2e，[1]-&gt;33，那么我们读[0]的字型数据为：332eH（高放高位）</p>
<h2 id="3-2-DS和-address"><a href="#3-2-DS和-address" class="headerlink" title="3.2 DS和[address]"></a>3.2 DS和[address]</h2><blockquote>
<p>“[…]”表示一个内存单元，表示在段地址下的偏移量。如10000H = 1000:0 = [0]</p>
</blockquote>
<ul>
<li><p>在masm汇编编辑器中，如果单纯写mov ax,[0]，那么他会把[0]当做0来解释，即指令变成：mov ax,0<br>而若用bx作为中转，那是可以的！如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mov bx,0</span><br><span class="line">mov ax,[bx]</span><br></pre></td></tr></table></figure>
<p>这个是可以把[bx]当成段地址，返回ds:bx下的数据的！<br>而如果偏要用[idata]的话，那么就必须加上<strong>ds:</strong>前缀，如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mov ax,ds:[0]</span><br></pre></td></tr></table></figure>
</li>
<li><p>而对于Debug编译器的话，ds是自动加上的，用</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mov ax,[0]</span><br></pre></td></tr></table></figure>
<p>即可，如果使用[]的话，而且他（段寄存器）是不能直接用mov命令改变的，必须通过其他的寄存器中转才能改变。</p>
</li>
</ul>
<h2 id="3-3-字的传送（mov指令）"><a href="#3-3-字的传送（mov指令）" class="headerlink" title="3.3 字的传送（mov指令）"></a>3.3 字的传送（mov指令）</h2><p>在传送字之后， DS和[address]也会跟着变，如1000:0，若传入一个fffeH，则address会从0-&gt;2，此时，[0]存有feH，[1]存有ffH,[2]为空。</p>
<h2 id="3-4-mov、add、sub指令"><a href="#3-4-mov、add、sub指令" class="headerlink" title="3.4 mov、add、sub指令"></a>3.4 mov、add、sub指令</h2><p>主要是说说置零问题，与机械码长度问题，稍微提一下，以后会细讲。<br>举例子：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sub bx, bx</span><br><span class="line">mov bx, 0</span><br></pre></td></tr></table></figure>
<p>两个都是可以将bx寄存器置零的指令，但是sub的机械码长度为2，而mov为3，用sub更好。<br>另外说说jmp指令，他是转移指令，具有一个操作对象的指令，而上面的具有两个。</p>
<h2 id="3-5-栈"><a href="#3-5-栈" class="headerlink" title="3.5 栈"></a>3.5 栈</h2><p>他是一个FILO结构（先入后出），而且是从大变小（地址）。</p>
<h3 id="3-5-1-push和pop"><a href="#3-5-1-push和pop" class="headerlink" title="3.5.1 push和pop"></a>3.5.1 push和pop</h3><blockquote>
<p>执行push ax命令，会把ax中的数据传入ss:sp指向的地址空间。此时<strong>sp-=2</strong><br>执行pop ax命令，会把ss:sp指向的地址空间中的数据传给ax。此时<strong>sp+=2</strong></p>
</blockquote>
<p>执行之后的指针变化：</p>
<ul>
<li>push先令sp-=2，然后将ax中的数据放进去。称为出栈。</li>
<li>pop是先取出数据放到ax中，再sp+=2。称为入栈。</li>
</ul>
<p><img src="/2019/11/10/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80-%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0/3.5.png" alt></p>
<h3 id="3-5-2-数据传输"><a href="#3-5-2-数据传输" class="headerlink" title="3.5.2 数据传输"></a>3.5.2 数据传输</h3><p>如8086cpu的入栈和出栈都是以<strong>字</strong>为单位进行的。</p>
<h3 id="3-5-3-栈指针"><a href="#3-5-3-栈指针" class="headerlink" title="3.5.3 栈指针"></a>3.5.3 栈指针</h3><p>上面已经用到了：段寄存器:寄存器存储(ss:sp)<br>sp是指偏移地址，ss:sp始终指向栈顶。</p>
<h2 id="3-6-栈顶越界问题"><a href="#3-6-栈顶越界问题" class="headerlink" title="3.6 栈顶越界问题"></a>3.6 栈顶越界问题</h2><p>栈溢出问题都是大问题，如果栈顶越界了，那么执行push和pop会受影响吗？当然不会！直接刚，写！写！写！出！出！出！管你呢。<br>所以就会有可能读了其他程序的数据，或者<strong>修改了（覆盖）</strong>其他程序的数据（直接崩溃的说）<br>执行情况（取自《汇编语言第二版》王爽著）<br><img src="/2019/11/10/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80-%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0/3.6.jpg" alt></p>
<h2 id="3-7-问题"><a href="#3-7-问题" class="headerlink" title="3.7 问题"></a>3.7 问题</h2><h3 id="1-程序与数据有区别吗？"><a href="#1-程序与数据有区别吗？" class="headerlink" title="1.程序与数据有区别吗？"></a>1.程序与数据有区别吗？</h3><p>可以说有，也可以说没有。由于指令都是0和1组成的，只是用不同功能的段地址读出来的不一样，如,CS和DS都指向10000H，那么，CS会将里头的数据转化为机械码，执行指令，而DS就直接读数据，作为单纯的数据使用。</p>
<h3 id="2-空栈如（10000H-1000FH）此时ss-1000H，那么sp是多少？"><a href="#2-空栈如（10000H-1000FH）此时ss-1000H，那么sp是多少？" class="headerlink" title="2.空栈如（10000H~1000FH）此时ss=1000H，那么sp是多少？"></a>2.空栈如（10000H~1000FH）此时ss=1000H，那么sp是多少？</h3><p>因为是自下而上（自大到小），所以sp=0010H。<br>换一种方式看，若存储了一个数据，则一个存到000EH，一个存到000FH，此时的栈指针在栈顶，当然指向000EH了，此时是已经让sp-=2了，那么回溯一下，不就有sp=0010H了。</p>
<ul>
<li>好了，问题来了，如果将（10000H~1FFFFH）作为空间呢？<br>答案：sp=0000H，因为，不能变成10000H(笑)</li>
</ul>
<h3 id="3-栈会溢出，那么，为什么不设置栈大小"><a href="#3-栈会溢出，那么，为什么不设置栈大小" class="headerlink" title="3.栈会溢出，那么，为什么不设置栈大小"></a>3.栈会溢出，那么，为什么不设置栈大小</h3><p>emmm，可惜8086cpu就是没有，所以变成自己注意。</p>
<h3 id="4-只有mov可以完成传输数据吗？"><a href="#4-只有mov可以完成传输数据吗？" class="headerlink" title="4.只有mov可以完成传输数据吗？"></a>4.只有mov可以完成传输数据吗？</h3><p>push也可以哦，只要把sp定位为ds:[address]那就好了哦。直接写进去。</p>
<h1 id="第四章-第一个程序"><a href="#第四章-第一个程序" class="headerlink" title="第四章 第一个程序"></a>第四章 第一个程序</h1><h2 id="4-1-一个源程序从写出到执行的过程"><a href="#4-1-一个源程序从写出到执行的过程" class="headerlink" title="4.1 一个源程序从写出到执行的过程"></a>4.1 一个源程序从写出到执行的过程</h2><p>执行过程包括：写程序-&gt;编译连接成可执行文件-&gt;执行。</p>
<blockquote>
<p>可执行文件文件中包括以下两部分：</p>
</blockquote>
<ol>
<li>程序和数据</li>
<li>相关的描述：程序多大，占用多少运行空间</li>
</ol>
<h2 id="4-2-源程序"><a href="#4-2-源程序" class="headerlink" title="4.2 源程序"></a>4.2 源程序</h2><h3 id="4-2-1-伪指令"><a href="#4-2-1-伪指令" class="headerlink" title="4.2.1 伪指令"></a>4.2.1 伪指令</h3><p>也就是只能被编译器识别的指令，如<strong>assume</strong>、<strong>segment</strong>、<strong>end</strong>等，<strong><em>这是没有机械码的</em></strong>。<br>一般的伪指令使用如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">assume cs:code  #声明（假设）cs:段名（标号）</span><br><span class="line">code segment	#段名 segment</span><br><span class="line">_指令_</span><br><span class="line">code ends		#对应segment，表示一个段结束</span><br><span class="line">end				#对应assume，表示程序结束</span><br></pre></td></tr></table></figure>

<h3 id="4-2-2-程序返回"><a href="#4-2-2-程序返回" class="headerlink" title="4.2.2 程序返回"></a>4.2.2 程序返回</h3><p>现在考虑，如何让上一个程序把CPU控制权交给写一个程序，这时候就要使用<strong>程序返回</strong><br>其代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mov ax, 4c00H</span><br><span class="line">int 21H</span><br></pre></td></tr></table></figure>
<h2 id="4-3-程序生成流程"><a href="#4-3-程序生成流程" class="headerlink" title="4.3 程序生成流程"></a>4.3 程序生成流程</h2><p><strong>编程 -&gt; <em>1.asm</em> -&gt; 编译 -&gt; <em>1.obj</em> -&gt; 连接 -&gt; <em>1.exe</em> -&gt; 加载 -&gt; <em>内存中的程序</em> -&gt; 运行</strong><br>注：加载就是将程序加载到内存，执行就是在内存中执行程序的指令</p>
<h2 id="4-4-怎么装载程序？"><a href="#4-4-怎么装载程序？" class="headerlink" title="4.4 怎么装载程序？"></a>4.4 怎么装载程序？</h2><p>操作系统是一个模块组成庞大的系统。任何通用的系统都要提供一个称为shell的程序，用户使用这个程序来操作计算机系统进行工作。</p>
<p>如DOS中有一个程序command.com，这个程序称为：命令解释器，也就是DOS中的SHELL<br>（其实跟我们的cmd.exe差不多）</p>
<p>先运行shell，然后在加载1.exe可执行程序的时候，cmd会自动把cpu的控制权交给1.exe，执行完成再返回cmd。</p>
<h2 id="4-4-展示EXE的加载过程"><a href="#4-4-展示EXE的加载过程" class="headerlink" title="4.4 展示EXE的加载过程"></a>4.4 展示EXE的加载过程</h2><p><img src="/2019/11/10/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80-%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0/4.4.png" alt></p>
<h1 id="第五章-BX-和loop指令"><a href="#第五章-BX-和loop指令" class="headerlink" title="第五章 [BX]和loop指令"></a>第五章 [BX]和loop指令</h1><h2 id="5-1-BX"><a href="#5-1-BX" class="headerlink" title="5.1 [BX]"></a>5.1 [BX]</h2><p>这个之前就讲过：其实就是把BX中的值作为ds的偏移地址EA，然后可以用这个来访问特定地址下的数据。<br>如ds:1000H，bx=0001H，那么[BX]就是指ds*16+bx下的值。</p>
<h2 id="5-2-loop"><a href="#5-2-loop" class="headerlink" title="5.2 loop"></a>5.2 loop</h2><p>直接上程序：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">assume cs:eloop</span><br><span class="line">eloop segment</span><br><span class="line">	mov ax,128</span><br><span class="line">	mov cx,36</span><br><span class="line">  s:add ax,ax</span><br><span class="line">	loop s</span><br><span class="line">eloop ends</span><br><span class="line">end</span><br></pre></td></tr></table></figure>
<p>解释：</p>
<ol>
<li>loop是按照cx当中的值进行对有标号的s下的命令进行循环的。当cx不等于0，则执行循环，这个程序实际上是实现128*36的程序。</li>
<li>s实际上是IP值，指向s标记的地址，所以loop s实际上是给IP赋值：IP=s，然后就可以通过cs:ip来执行指令了</li>
</ol>
<blockquote>
<p>注意：汇编程序中，数据不能以字母开头，所以要在前面加个0。比如：9138h可以写成9138h，而A000h就必须写成0A000h</p>
</blockquote>
<h2 id="5-3-loop和-bx-的联合运用"><a href="#5-3-loop和-bx-的联合运用" class="headerlink" title="5.3 loop和[bx]的联合运用"></a>5.3 loop和[bx]的联合运用</h2><p>例如来一个如同C++语言中的：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int dx = 0;</span><br><span class="line">int ds[12] = &#123;1, 2, ...&#125;;</span><br><span class="line">for(int i=0; i &lt; 12; i++)</span><br><span class="line">&#123;</span><br><span class="line">	dx += ds[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>那么汇编语言就有：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">assume cs:code</span><br><span class="line">code segment:</span><br><span class="line">	mov ax, 0ffffh	;因为ds寄存器不能直接赋值，所以用ax作为中间变量</span><br><span class="line">	mov ds,ax		</span><br><span class="line">	mov bx,0		;初始化ds:bx指向ffff:0</span><br><span class="line"></span><br><span class="line">	mov dx,0		;初始化**累加寄存器**dx，让值为0</span><br><span class="line"></span><br><span class="line">	mov cx,12		;初始化循环计数寄存器cx，令值为12，指循环12次</span><br><span class="line"></span><br><span class="line"> s: mov al,[bx]		;以下两步执行ax的赋值操作</span><br><span class="line">	mov ah,0		;</span><br><span class="line">	add dx,ax		;执行加法</span><br><span class="line">	inc bx			;ds:bx指向下一个单元，因为bx的值增加了1，相当于C++代码中的*i++*</span><br><span class="line">	loop s			;loop完成一次，则cx=cx-1，然后判断cx是否等于0，如果等于则退出循环</span><br><span class="line"></span><br><span class="line">	mov ax,4c00h</span><br><span class="line">	int 21h</span><br><span class="line"></span><br><span class="line">code ends</span><br><span class="line">end</span><br></pre></td></tr></table></figure>
<p>好了，现在来说说这段代码里面有什么需要注意的点：</p>
<ol>
<li>cx寄存器一般用作loop循环的判断条件，即<strong>循环的粗次数</strong>。</li>
<li>ax寄存器的初始化有两步，是，因为一个字符型数据是8位这样的话转化为16位就得让高8位的值赋为0。</li>
<li>dx寄存器是常用的累加寄存器。</li>
<li>inc指令是让后面的值加一的指令，相当于C++语言中的‘++’自增。</li>
<li>int指令：<blockquote>
<p>由int 指令引发的中断是一种重要的内中断。<br>格式： int n   //相当于引发一个n号中断的过程,最终功能和call指令相似，都是调用一段程序。</p>
<ul>
<li>取中断类型码n</li>
<li>标志寄存器入栈，并IF=0,TF=0      //TF=0使得避免中断程序执行过程中引发单步中断</li>
<li>CS,IP寄存器入栈</li>
<li>IP=(n*4) , CS=(n*4 + 2)<br><a href="https://blog.csdn.net/u010034085/article/details/97819727" target="_blank" rel="noopener">原文链接</a></li>
</ul>
</blockquote>
</li>
</ol>
<h2 id="5-4-段前缀与其使用"><a href="#5-4-段前缀与其使用" class="headerlink" title="5.4 段前缀与其使用"></a>5.4 段前缀与其使用</h2><blockquote>
<ul>
<li>能够显示地指令内存单元的段地址的，如：”ds:”、”cs:”、”ss:”、”es:”。这就是段前缀。</li>
<li>默认的[x]是指：(dx*16)+x，而如果要用其他的段寄存器，则需要加上它的段前缀。 </li>
</ul>
</blockquote>
<h1 id="第六章-包含多个段的程序"><a href="#第六章-包含多个段的程序" class="headerlink" title="第六章 包含多个段的程序"></a>第六章 包含多个段的程序</h1><blockquote>
<p>由于软件是由数据和程序组成的，数据当然也是程序里面必不可少的部分，所以会将代码分为多段进行，如数据段、代码段等。</p>
</blockquote>
<h2 id="6-1-在代码段中使用数据"><a href="#6-1-在代码段中使用数据" class="headerlink" title="6.1 在代码段中使用数据"></a>6.1 在代码段中使用数据</h2><blockquote>
<p><strong>汇编程序若没有特殊的说明（或者注明在哪里开始），则默认从头开始！</strong><br>所以，一旦你的程序头部有数据，则将会把头部的数据翻译为<strong>机器码</strong>执行。(冤)</p>
</blockquote>
<p>那么解决方式是：在开始执行代码的地方加上 <strong>start:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">assume cs:code</span><br><span class="line">code segment</span><br><span class="line">  dw 0123h,0456h,0789h ;这里是数据部分 dw意思是定义字符型数据</span><br><span class="line">  start: mov bx,0   ;注意，从这开始，标识为start!</span><br><span class="line">         mov ax,0</span><br><span class="line"></span><br><span class="line">         mov cx,8</span><br><span class="line">	  s: add ax,cs:[bx]	;用cs作为段地址，取数据！</span><br><span class="line">         add bx,2</span><br><span class="line">         loop s</span><br><span class="line">         </span><br><span class="line">         mov ax,4c00h</span><br><span class="line">         int 2h</span><br><span class="line">code ends</span><br><span class="line">end start   ;注意end后面要加上end开始的名称！</span><br></pre></td></tr></table></figure>

<h2 id="6-2-将数据、代码、栈放入不同的段"><a href="#6-2-将数据、代码、栈放入不同的段" class="headerlink" title="6.2 将数据、代码、栈放入不同的段"></a>6.2 将数据、代码、栈放入不同的段</h2><p>上面说了，代码从哪里开始就在哪里加上<strong>start</strong>，结束就用<strong>end start</strong>（其他标识也行）<br>好，记住，那是代码，别把接下来说的混淆了。</p>
<p>不同的段可以放不同的东西，例如数据，代码等等。<br>只要记住将段名end了再定义其他段。也只有定义了，才能使用这个段</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">assume cs:b,ds:a,ss:c</span><br><span class="line">a segment</span><br><span class="line">    dw 0123h, 0456h, 0789h, 0abch, 0de fh, Ofedh, 0cbah, 0987h</span><br><span class="line">a ends</span><br><span class="line"></span><br><span class="line">c segment</span><br><span class="line">    dw 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0</span><br><span class="line">c ends</span><br><span class="line"></span><br><span class="line">b segment</span><br><span class="line">d:  mov ax,c  ;使用段c中的数据</span><br><span class="line">    mov ss,ax</span><br><span class="line">    mov sp, 20h  ;希望用c段当作栈空间，设置ss:sp指向c:20</span><br><span class="line"></span><br><span class="line">    mov ax,a	;使用段a</span><br><span class="line">    mov ds,ax  ;希望用ds:bx访问a段中的数据，ds指向a段</span><br><span class="line">    mov bx,0  ;ds:bx指向a段中的第一一个单元</span><br><span class="line">    mov Cx,8</span><br><span class="line"></span><br><span class="line">s:  push [bx]</span><br><span class="line">    add bx,2</span><br><span class="line">    1oop s   ;以上将a段中的0~15单元中的8个字型数据依次入栈</span><br><span class="line"></span><br><span class="line">    mov bx,0</span><br><span class="line">    mov cx, B</span><br><span class="line">s0:	pop [bx]</span><br><span class="line">    add bx,2</span><br><span class="line">    1oop s0  ;以上依次出栈8个字型数据到a段的0~15单元中</span><br><span class="line"></span><br><span class="line">    mov ax, 4c00hint 21h</span><br><span class="line">b ends</span><br><span class="line"></span><br><span class="line">end d  ;d处是要执行的第一- 条指令，即程序的入口</span><br></pre></td></tr></table></figure>
<h1 id="第七章-更灵活的定位内存地址的方法"><a href="#第七章-更灵活的定位内存地址的方法" class="headerlink" title="第七章 更灵活的定位内存地址的方法"></a>第七章 更灵活的定位内存地址的方法</h1><p>之前的[0]和[bx]均可以起到定位的作用，现在有更灵活的定位方式：</p>
<h2 id="7-1-and和or指令"><a href="#7-1-and和or指令" class="headerlink" title="7.1 and和or指令"></a>7.1 and和or指令</h2><blockquote>
<p>and是有零变零，而or是有一变一<br>也可以想象成and是乘法，or是加法</p>
</blockquote>
<h2 id="7-2-以字符型给出数据"><a href="#7-2-以字符型给出数据" class="headerlink" title="7.2 以字符型给出数据"></a>7.2 以字符型给出数据</h2><p>凡是以’…’形式给出数据的，都被译为是字符型数据，这样，编译器会将里面的数据变成ASCII码值。具体实例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">db &apos;unIX&apos;</span><br><span class="line">mov al,&apos;a&apos;</span><br></pre></td></tr></table></figure>
<p>这里被译为</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">db 75H,6EH,49H,58H</span><br><span class="line">mov al,61H</span><br></pre></td></tr></table></figure>
<p>而大小写转换的方法有两种：</p>
<ol>
<li>基于比较的，在ASCII码中，大写字母+20H=小写字母</li>
<li>基于二进制数的，在ASCII表达字符时，若第五位为0，则为大写字母；若第五位为1则为小写字母（这里可以用or或者and来进行转换）</li>
</ol>
<h2 id="7-3-以-bx-idata-的方式寻址"><a href="#7-3-以-bx-idata-的方式寻址" class="headerlink" title="7.3 以[bx+idata]的方式寻址"></a>7.3 以[bx+idata]的方式寻址</h2><p>现在以例题进行解析，将第一组字符串变成大写，第二组变成小写</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">assume cs:codesg,ds:datasg</span><br><span class="line">datasg segment</span><br><span class="line">  db &apos;BaSiC&apos;</span><br><span class="line">  db &apos;MinIX&apos;</span><br><span class="line">datasg ends</span><br><span class="line">codesg segment</span><br><span class="line">start:			;代码段</span><br><span class="line">codesg ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure>
<ul>
<li>原来的思想：取[bx]中的字符，再对其进行and 11011111b操作，再放回去，然后将bx自增，再重新···，而变成小写就or 00100000b。（这里要执行两次循环啊，一个变大写，一个变小写）</li>
<li>然而我们可以使用以下思想，更加便捷，就是[bx+idata]：思想和前面的一样，但是，不用执行两次循环，只要一次就够了：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">  mov ax,datasg</span><br><span class="line">  mov ds, ax</span><br><span class="line">  mov bx,0</span><br><span class="line">  </span><br><span class="line">  mov cx,5</span><br><span class="line">s:mov al,[bx]      ;定位第一个字符串的第bx个字符</span><br><span class="line">  and al,11011111b ;执行完变大工作</span><br><span class="line">  mov [bx],al      ;放回去</span><br><span class="line">  mov al[5+bx]     ;定位第二个字符串的第bx个字符（因为一个字符串只有5个字符）</span><br><span class="line">  or al,00100000b  ;执行变小工作</span><br><span class="line">  mov [5+bx],al    ;放回去</span><br><span class="line">  inc bx           ;自增</span><br><span class="line">  loop s</span><br></pre></td></tr></table></figure>
这个其实，学过高级语言都知道这方法，只不过，没想到汇编也能做吧，汇编语言也不是那么死板的。</li>
</ul>
<h2 id="7-4-si与di寄存器和多重循环"><a href="#7-4-si与di寄存器和多重循环" class="headerlink" title="7.4 si与di寄存器和多重循环"></a>7.4 si与di寄存器和多重循环</h2><p>这个只要知道是16位寄存器，功能和bx差不多，可以用作[bx+si+idata]和[bx+di+idata]就可以了。其中，idata是常量，其他的为变量。这个结构可以执行二重循环，相当于处理二维数组。<br>需要注意的是二重循环的实现：</p>
<blockquote>
<ul>
<li>问题一：cx寄存器是用作循环的判定条件的，那么二重循环对于没有两个cx的我们来说，如何是好？<br>将之前的cx用其他寄存器保存起来啊！</li>
<li>问题二：二重循环可以那样做，那么多重循环呢！？你只有有限个寄存器。<br>利用内存空间！开辟一段dw 0，让后指向它，放进去就完事了。</li>
<li>问题三：那这个方法的前提是我得知道有多少个循环，很麻烦啊，换个简单的。</li>
<li><em>在需要暂存数据的时候我们都应该使用栈*</em></li>
<li><em>在需要暂存数据的时候我们都应该使用栈*</em></li>
<li><em>在需要暂存数据的时候我们都应该使用栈*</em><br>按顺序push，然后逆向按顺序pop</li>
</ul>
</blockquote>
<h1 id="第八章-数据处理的两个基本问题"><a href="#第八章-数据处理的两个基本问题" class="headerlink" title="第八章 数据处理的两个基本问题"></a>第八章 数据处理的两个基本问题</h1><p>这两个问题是：</p>
<ol>
<li><strong>处理的数据在什么地方</strong></li>
<li><strong>要处理的数据有多长</strong></li>
</ol>
<h2 id="8-1-bx、si、di和bp"><a href="#8-1-bx、si、di和bp" class="headerlink" title="8.1 bx、si、di和bp"></a>8.1 bx、si、di和bp</h2><p>这几个都用过，主要说说bp:这个只要在[…]里使用了它，没有段地址声明，那么默认是<strong>ss</strong></p>
<h2 id="8-2-机器指令处理的数据在什么地方"><a href="#8-2-机器指令处理的数据在什么地方" class="headerlink" title="8.2 机器指令处理的数据在什么地方"></a>8.2 机器指令处理的数据在什么地方</h2><p><strong>在指令执行前</strong>，所要处理的数据可以在三个地方：</p>
<ol>
<li>CPU内部</li>
<li>内存</li>
<li>端口<br>下面举例子：<br><img src="/2019/11/10/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80-%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0/8.1.png" alt><br>上图还表明了汇编语言中数据位置的表达</li>
<li>立即数（idata）：如上图的最后一个例子，是直接赋值的</li>
<li>寄存器：如上图的第二个例子，使用寄存器名。</li>
<li>段地址：如果是[bx]则默认段地址是ds，如果是[bp]则默认段地址为ss，当然可以显性给出。</li>
</ol>
<h2 id="8-3-指令处理的数据长度"><a href="#8-3-指令处理的数据长度" class="headerlink" title="8.3 指令处理的数据长度"></a>8.3 指令处理的数据长度</h2><p>这个得看具体例子。</p>
<ol>
<li>如果是ax,bx，那么这个就是字操作</li>
<li>如说是al,bl，那么就是字节操作</li>
<li>在没有寄存器名存在的情况下，用操作符X ptr指明内存单元的长度，X在汇编中可以为word或byte（且必须显式声明）。</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mov word ptr ds:[0],1	;字</span><br><span class="line">mov byte ptr ds:[0],1	;字节</span><br></pre></td></tr></table></figure>
<ol start="4">
<li>有些指令默认了访问的是字还是字节，如<strong>push</strong>默认进行<strong>字</strong>操作，而用[…]的是字单元操作(一个8位)。</li>
</ol>
<h2 id="8-4-div指令"><a href="#8-4-div指令" class="headerlink" title="8.4 div指令"></a>8.4 div指令</h2><p>div是除法指令，使用div做除法的时候应注意以下问题.</p>
<ol>
<li>除数:有8位和16位两种，在<strong>一个reg</strong>或<strong>内存单元</strong>中。</li>
<li>被除数:默认放在<strong>AX</strong>或<strong>DX和AX</strong>中<ol>
<li>如果除数为8位，<strong>被除数则为16位</strong>，<strong>默认在AX</strong>中存放；</li>
<li>如果除数为16位，<strong>被除数则为32位</strong>，在DX和AX中存放，<strong>DX存放高16位，AX存放低16位</strong>。</li>
</ol>
</li>
<li>结果:<ol>
<li>如果<strong>除数为8位</strong>，则AL存储除法操作的商，AH存储除法操作的余数:</li>
<li>如果<strong>除数为16位</strong>，则AX存储除法操作的商，DX存储除法操作的余数。</li>
</ol>
</li>
</ol>
<p>格式如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">div reg</span><br><span class="line">div 内存单元</span><br><span class="line">div byte ptr ds:[0]</span><br><span class="line">含义：(al)=(ax)/((ds)*16+0)的商</span><br><span class="line">	 (ah)=(ax)/((ds)*16+0)的余数</span><br></pre></td></tr></table></figure>
<h2 id="8-5-实例"><a href="#8-5-实例" class="headerlink" title="8.5 实例"></a>8.5 实例</h2><p>利用除法指令计算100001/100<br>分析：</p>
<ol>
<li>由于100001大于整数最大值（16位）65535，不能用ax寄存器存放，所以只能用dx和ax两个寄存器联合存放，共32位</li>
<li>而出书100小于255（8位），但是因为被除数是32位，所以除数应该用16位的来存放除数100<br>所以有程序：</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mov dx,1</span><br><span class="line">mov ax,86A1H	;(dx)*10000H+(ax)=100001   100001=186A1H</span><br><span class="line">mov bx,100</span><br><span class="line">div bx</span><br></pre></td></tr></table></figure>

<p>执行后，(ax)=03E8H(即10000)，(dx)=1(余数为1)。</p>
<h2 id="8-6-伪指令dd"><a href="#8-6-伪指令dd" class="headerlink" title="8.6 伪指令dd"></a>8.6 伪指令dd</h2><p>之前有学过用db和dw定义字节型数据和字型数据。dd是用来定义dword（double word，双字）型数据的。</p>
<ul>
<li>db 占1个字节</li>
<li>dw 占1个字（即两个字节）</li>
<li>db 占2个字（即四个字节）</li>
</ul>
<h2 id="8-7-dup"><a href="#8-7-dup" class="headerlink" title="8.7 dup"></a>8.7 dup</h2><p>dup是一个操作符，在汇编语言中与dw,db,dd一样，都是由编译器识别处理的符号，且与它们一同配合使用，用来进行数据重复。<br>如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">db 3 dup (0)</span><br><span class="line">定义了3个字节，它们的值都是0，相当于执行了 db 0,0,0。</span><br><span class="line"></span><br><span class="line">db 3 dup (1,2,3)</span><br><span class="line">定义了3\*3=9个字节，它们是0、1、2、0、1、2、0、1、2，相当于db 0,1,2,0,1,2,0,1,2。</span><br><span class="line">字符型也适用。</span><br><span class="line"></span><br><span class="line">总结：</span><br><span class="line">d？ 重复的次数 dup (重复的(字节/字/双字型)数据）</span><br></pre></td></tr></table></figure>

<h1 id="第九章-转移指令的原理"><a href="#第九章-转移指令的原理" class="headerlink" title="第九章 转移指令的原理"></a>第九章 转移指令的原理</h1><p><strong>可以修改IP 或同事修改CS和IP的指令统称为转移指令统称为转移指令</strong>。如jmp、jno等，即可以控制CPU指令内存中某处代码的指令。<br>具体分类有：</p>
<ol>
<li>无条件转移指令（jmp）</li>
<li>条件转移指令（jno）</li>
<li>循环指令（loop）</li>
<li>过程</li>
<li>中断</li>
</ol>
<p>还有其他的分类：</p>
<ol>
<li><p>只修改IP：段内转移（jmp ax）</p>
</li>
<li><p>同时修改CS和IP：段间转移（jmp 1000:0）</p>
</li>
<li><p>短转移</p>
</li>
<li><p>近转移</p>
</li>
</ol>
<h2 id="9-1-操作符offset"><a href="#9-1-操作符offset" class="headerlink" title="9.1 操作符offset"></a>9.1 操作符offset</h2><p>offset是编译器处理符号，功能：取得标号的额编译地址。<br>如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">start: mov ax, offset start	;相当于mov ax,0</span><br><span class="line">	s: mov ax, offset s		;相当于mov ax,3</span><br></pre></td></tr></table></figure>
<p>解析：第一条指令mov … 是三个字节，所以s段的offset为3</p>
<h2 id="9-2-jmp指令和依据译为进行转移的jmp指令"><a href="#9-2-jmp指令和依据译为进行转移的jmp指令" class="headerlink" title="9.2 jmp指令和依据译为进行转移的jmp指令"></a>9.2 jmp指令和依据译为进行转移的jmp指令</h2><h3 id="9-2-1-jmp-short-标号-转移到标号出执行指令"><a href="#9-2-1-jmp-short-标号-转移到标号出执行指令" class="headerlink" title="9.2.1 jmp short 标号(转移到标号出执行指令)"></a>9.2.1 jmp short 标号(转移到标号出执行指令)</h3><pre><code>1. short标号下，它属于段内短转移，对IP的修改范围为-128~127。</code></pre><h3 id="9-2-2-立即数在机器码中的表示"><a href="#9-2-2-立即数在机器码中的表示" class="headerlink" title="9.2.2 立即数在机器码中的表示"></a>9.2.2 立即数在机器码中的表示</h3><p>在一般的汇编指令当中，汇编指令的idata（立即数），不论他是表示一个数据还是内存单元的偏移地址，都会在相应的机器指令中出现，因为CPU执行的是机器指令，他必须处理这些数据或地址。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mov ax,0123h		B8 23 01</span><br><span class="line">mov ax,ds:[0123h]	A1 23 01</span><br><span class="line">push ds:[0123h]		FF 36 23 01</span><br></pre></td></tr></table></figure>
<h3 id="9-2-3-jmp转移的机制（是怎么实现转移的）"><a href="#9-2-3-jmp转移的机制（是怎么实现转移的）" class="headerlink" title="9.2.3 jmp转移的机制（是怎么实现转移的）"></a>9.2.3 jmp转移的机制（是怎么实现转移的）<span id="jmp"></span></h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">start:	mov ax,0</span><br><span class="line">		mov bx,0</span><br><span class="line">		jmp short s</span><br><span class="line">		add ax,1</span><br><span class="line">	s:	inc ax</span><br></pre></td></tr></table></figure>

<ol>
<li>首先我们应该知道，jmp指令是2个字节，如代码中的jmp机械码是：<strong>EB 03</strong> 。这样的机械码，<strong>没有包含s段的地址</strong>！所以将jmp指令写入内存之后，IP=IP+2=0008h。</li>
<li>但是，执行完jmp后，IP=000Bh。因为执行JMP，就是执行IP=IP+(EB之后的偏移量)=IP+3=000Bh。</li>
<li>所以<strong>jmp执行的是给IP加偏移地址！</strong>。</li>
</ol>
<p>所以 jmp short 标号 的功能为：<strong>(ip)=(ip)+8位位移</strong></p>
<h3 id="9-2-4-继续上面的，8位位移是怎么得出来的？"><a href="#9-2-4-继续上面的，8位位移是怎么得出来的？" class="headerlink" title="9.2.4 继续上面的，8位位移是怎么得出来的？"></a>9.2.4 继续上面的，8位位移是怎么得出来的？</h3><p><img src="/2019/11/10/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80-%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0/9.2.4.png" alt></p>
<ol>
<li><strong>8位位移</strong>=<strong>标号处的地址</strong> - jmp指令<strong>后的第一个字节的地址</strong>.</li>
<li><strong>short</strong>指明此处的位移为<strong>8位位移</strong>;</li>
<li>8位位移的范围为-128-127，<strong>用补码表示</strong></li>
<li>8位位移由编译程序在编译时算出。</li>
</ol>
<blockquote>
<p>还有一种和”jmp short标号”功能相近的指令格式:<br><strong>jmp near ptr标号</strong><br>它实现的是段内近转移。功能为:<strong>(IP)=(LP)+16位位移</strong>。<br>(1) 16位位移=标号处的地址 - jmp指令后的第一个字节的地址:<br>(2) <strong>near ptr</strong>指明此处的位移为<strong>16位位移</strong>，进行的是<strong>段内近转移</strong>:<br>(3) 16位位移的范围为一32768~32767，用<strong>补码表示</strong>:<br>(4) 16位位移由编译程序在编译时算出。</p>
</blockquote>
<h3 id="9-2-5-jmp-far-ptr-标号（段间转移-远转移）"><a href="#9-2-5-jmp-far-ptr-标号（段间转移-远转移）" class="headerlink" title="9.2.5 jmp far ptr 标号（段间转移/远转移）"></a>9.2.5 jmp far ptr 标号（段间转移/远转移）</h3><p>是不是所有的jmp机械码都没有段数据呢？当然不是！小标题就说到了：far ptr，这个指令用标号的段地址和偏移地址修改CS和IP<br>如：<br><img src="/2019/11/10/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80-%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0/9.2.5.png" alt><br>解释：“OB 01 BD 0B”是目的地之在指令中的存储顺序：<br>高地址：“BD 0B”是段地址 0BBDH ；<br>低地址：“0B 01”是偏移地址 010BH ；</p>
<h3 id="9-2-6-转移地址在寄存器的jmp指令-这就相当于总结了，上面废话有点多"><a href="#9-2-6-转移地址在寄存器的jmp指令-这就相当于总结了，上面废话有点多" class="headerlink" title="9.2.6 转移地址在寄存器的jmp指令(这就相当于总结了，上面废话有点多)"></a>9.2.6 转移地址在寄存器的jmp指令(这就相当于总结了，上面废话有点多)</h3><ul>
<li>若只是一个字，则只是偏移地址（直接EB ??完事）</li>
<li>若是两个字，那么一个是段，一个是偏移地址。</li>
</ul>
<h2 id="9-3-jcxz指令"><a href="#9-3-jcxz指令" class="headerlink" title="9.3 jcxz指令"></a>9.3 jcxz指令</h2><p>该指令为有条件转移指令，所有的有条件转移指令都是<strong>短指令</strong>，即上面9.2.6说的1个字，只有位移（偏移地址），对ip的修改范围是：-128~127.</p>
<blockquote>
<p>指令格式：jcxz 标号<br>如果(cx)=0，则转移到标号这</p>
</blockquote>
<h2 id="9-4-loop指令"><a href="#9-4-loop指令" class="headerlink" title="9.4 loop指令"></a>9.4 loop指令</h2><p>也是短转移指令，pass</p>
<h2 id="9-5-编译器对转移位移超界的检测"><a href="#9-5-编译器对转移位移超界的检测" class="headerlink" title="9.5 编译器对转移位移超界的检测"></a>9.5 编译器对转移位移超界的检测</h2><p>编译的时候就会出错！因为，这超界，编译器可识别不了。这不存在的玩意儿。</p>
<h1 id="第十章-CALL和RET指令"><a href="#第十章-CALL和RET指令" class="headerlink" title="第十章 CALL和RET指令"></a>第十章 CALL和RET指令</h1><h2 id="10-1-ret和retf"><a href="#10-1-ret和retf" class="headerlink" title="10.1 ret和retf"></a>10.1 ret和retf</h2><p>它们都是用栈中的指令，而ret是改变ip，而retf是改变cs:ip，实现远转移。<br>而正是因为它们是取栈中的指令，所以要和push 和pop结合起来，而ret或者retf执行完后，相当于执行了指令pop<br>如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mov ax stack	;在前面声明的stack数据段，共16B</span><br><span class="line">mov ss ax		;栈段地址</span><br><span class="line">mov sp 16		;将值（Base）设置为16，往上加。（栈的特性）</span><br><span class="line">push cx</span><br><span class="line">push ip</span><br><span class="line">retf</span><br></pre></td></tr></table></figure>
<p>这里就相当于执行了刚放进去的机器码。</p>
<h2 id="10-2-call指令"><a href="#10-2-call指令" class="headerlink" title="10.2 call指令"></a>10.2 call指令</h2><ul>
<li>将打那个钱的IP或CS:IP压入栈中</li>
<li>转移</li>
</ul>
<p>注意：call指令不能执行短转移，其实现方法与<a href="#jmp">jmp指令</a>相同</p>
<h3 id="10-2-1-依据位移进行转移的call指令"><a href="#10-2-1-依据位移进行转移的call指令" class="headerlink" title="10.2.1 依据位移进行转移的call指令"></a>10.2.1 依据位移进行转移的call指令</h3><blockquote>
<p>call 标号(将当期那的ip压入栈后，转到标号处执行指令)</p>
</blockquote>
<p>指令执行时会带有以下操作：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1. (sp)=(sp)-2	;压栈</span><br><span class="line"> ((ss)*16+(sp))=(IP)</span><br><span class="line">2. (IP)=(IP)+16位位移</span><br></pre></td></tr></table></figure>
<p>这个位移之前也说过了，不多讲。<br>看到上面的代码我们也能联想到jmp的执行了，相当于：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">push IP</span><br><span class="line">jmp near ptr 标号</span><br></pre></td></tr></table></figure>
<p>举个例子！</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">内存地址 机器码 汇编指令 </span><br><span class="line">1000:0 b8 00 00 mov ax,0 </span><br><span class="line">1000:3 e8 01 00 call s </span><br><span class="line">1000:6 40 		inc ax </span><br><span class="line">1000:7 58 		s:pop ax</span><br></pre></td></tr></table></figure>
<p>也许你会想到：我没有push哪来的pop!?</p>
<ol>
<li>在call之时已经有了push ip，此时的ip=提取call s之后指向下一个执行机器码（inc ax）的ip指针，也就是ip=6。</li>
<li>而当call转移到s，ip就变为call之后的ip。</li>
<li>此时再pop ax，也就是ax=6。</li>
<li>因为执行完s，没有<span id="ret"></span>回调指令pop ip。。。所以不会执行inc ax</li>
</ol>
<h3 id="10-2-2-转移地址在指令中的call指令"><a href="#10-2-2-转移地址在指令中的call指令" class="headerlink" title="10.2.2 转移地址在指令中的call指令"></a>10.2.2 转移地址在指令中的call指令</h3><p>这个也就是段间转移了，是相对于上头说的段内转移</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">call far ptr 标号</span><br></pre></td></tr></table></figure>
<p>此时会执行cs和ip双压栈</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1. (sp)=(sp)-2	;压栈</span><br><span class="line"> ((ss)*16+(sp))=(CS)</span><br><span class="line">(sp)=(sp)-2	;压栈</span><br><span class="line"> ((ss)*16+(sp))=(IP)</span><br><span class="line">2. (CS)=标号所在的段地址</span><br><span class="line">(IP)=标号在段中的偏移地址</span><br><span class="line"></span><br><span class="line">即：</span><br><span class="line">push CS</span><br><span class="line">push IP</span><br><span class="line">jmp far ptr 标号</span><br></pre></td></tr></table></figure>
<p>举个例子：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1000:0 b8 00 00 		mov ax,0</span><br><span class="line">1000:3 9a 09 00 00 10 	call far ptr s</span><br><span class="line">1000:8 40 				inc ax</span><br><span class="line">1000:9 58 			s:	pop ax</span><br><span class="line">						add ax,ax</span><br><span class="line">						pop bx</span><br><span class="line">						add ax,bx</span><br></pre></td></tr></table></figure>
<p>ax是多少呢？</p>
<ol>
<li>call指令执行之后，stack中有cs和ip两个数据，CS在底部,IP在顶部。所以第一次pop ax，ax=ip=8</li>
<li>执行add后ax=16即10H</li>
<li>再执行pop，bx=1000H</li>
<li>add指令执行后ax=ax+bx=1010H</li>
</ol>
<h3 id="10-2-3-转移指令在寄存器中的call指令"><a href="#10-2-3-转移指令在寄存器中的call指令" class="headerlink" title="10.2.3 转移指令在寄存器中的call指令"></a>10.2.3 转移指令在寄存器中的call指令</h3><pre><code>call 16位reg</code></pre><p>功能：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">push IP</span><br><span class="line">jmp 16位reg	;IP=(reg)</span><br></pre></td></tr></table></figure>
<p>这个跟10.2.1是不是很像？段内转移。例子：call ax（当ax=6,则转到cs:6处执行）</p>
<h3 id="10-2-4-转移指令在内存中的call指令"><a href="#10-2-4-转移指令在内存中的call指令" class="headerlink" title="10.2.4 转移指令在内存中的call指令"></a>10.2.4 转移指令在内存中的call指令</h3><pre><code>call word ptr 内存单元地址</code></pre><p>功能：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">push IP</span><br><span class="line">jmp word ptr 内存单元地址</span><br></pre></td></tr></table></figure>
<p>其实跟10.2.3没啥两样。</p>
<p>但是还有一种双字型：<br>    call dword ptr 内存单元地址<br>功能：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">push CS</span><br><span class="line">push IP</span><br><span class="line">jmp dword ptr 内存单元地址</span><br></pre></td></tr></table></figure>
<p>举个例子就明白了</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mov sp,10h</span><br><span class="line">mov ax,0123h</span><br><span class="line">mov ds:[0],ax</span><br><span class="line">mov word ptr ds:[2]，0</span><br><span class="line">call dword ptr ds:[0]</span><br></pre></td></tr></table></figure>
<p>执行后：(CS)=0, (IP)=0123H, (sp)=0CH.</p>
<h2 id="10-3-call与ret的配合使用（敲黑板！）"><a href="#10-3-call与ret的配合使用（敲黑板！）" class="headerlink" title="10.3 call与ret的配合使用（敲黑板！）"></a>10.3 call与ret的配合使用（敲黑板！）</h2><ul>
<li>call之时压ip到栈中!</li>
<li>call完之后，执行转移后的指令</li>
<li>通过ret取出栈中的地址，执行转移操作！即<strong><a href="#ret">回调</a></strong>作用！</li>
<li>回调完成就可以执行call之后的代码了！<br>分析例子：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">assume cs:code</span><br><span class="line">code segment</span><br><span class="line">  start: mov ax,1</span><br><span class="line">         mov cx,3</span><br><span class="line">         call s</span><br><span class="line">         mov bx,ax	;(b)=?</span><br><span class="line">         mov ax,4c00h</span><br><span class="line">         int 21h</span><br><span class="line">      s: add ax,ax</span><br><span class="line">         loop s</span><br><span class="line">         ret</span><br><span class="line">code ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure>
<blockquote>
<p> 我们来看一下CPU执行这个程序的主要过程。<br>  (1)CPU将call s指令的机器码读入，IP指向了call s后的指令mov bx,ax.然后CPU执行call s指令，将当前的IP值(指令mov bx,ax的偏移地址)压栈，并将IP的值改变为标号s处的偏移地址:<br>  (2) CPU从标号s处开始执行指令，loop循环完毕后，(ax)=8;<br>  (3) CPU将ret指令的机器码读入，IP指向了ret指令后的内存单元，然后CPU执行ret指令，从栈中弹出一个值(即call s先前压入的mov bx,ax指令的偏移地址)送入IP中。则CS:IP指向指令mov bx,ax;<br>  (4) CPU从mov bx,ax开始执行指令，直至完成。</p>
</blockquote>
</li>
</ul>
<h2 id="10-4-mul乘法指令"><a href="#10-4-mul乘法指令" class="headerlink" title="10.4 mul乘法指令"></a>10.4 mul乘法指令</h2><p>之前说了div除法指令，现在说乘法指令。</p>
<h3 id="10-4-1-乘法规则"><a href="#10-4-1-乘法规则" class="headerlink" title="10.4.1 乘法规则"></a>10.4.1 乘法规则</h3><p>这里跟div的除数和被除数不一样的是，乘法的两个数，要么都是8位要么都是16位！</p>
<ol>
<li>乘法的两个数</li>
</ol>
<ul>
<li>如果是8位，一个放在<strong>AL</strong>中，一个放在8位的reg或内存字节单元中。</li>
<li>如果是16位，一个放在<strong>AX</strong>中，一个放在16位的reg或内存字节单元中。</li>
</ul>
<ol start="2">
<li>乘法的结果</li>
</ol>
<ul>
<li>如果是8位乘法，结果放在<strong>AX</strong>中</li>
<li>如果是16位乘法，<strong>高位放DX</strong>，<strong>低位放AX</strong></li>
</ul>
<h3 id="10-4-2-指令格式："><a href="#10-4-2-指令格式：" class="headerlink" title="10.4.2 指令格式："></a>10.4.2 指令格式：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mul reg</span><br><span class="line">mul 内存单元</span><br></pre></td></tr></table></figure>
<p>格式说明：<br>因为有一个放在了al(以8位为例)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mov al 1</span><br><span class="line">mov byte ptr ds:[0] 2</span><br><span class="line">mul ds:[0]</span><br></pre></td></tr></table></figure>
<p>这个就是用2*1了~<br>结果是ax=2（当然，我赋值的是十进制嘛）</p>
<h3 id="10-4-3-用mul寻址"><a href="#10-4-3-用mul寻址" class="headerlink" title="10.4.3 用mul寻址"></a>10.4.3 用mul寻址</h3><ol>
<li>mul byte ptr ds:[0]<br>含义：ax=al<em>(ds</em>16+0)</li>
<li>mul word ptr [bx+si+8]<br>含义：dx=</li>
</ol>
<h2 id="10-5-模块化程序设计"><a href="#10-5-模块化程序设计" class="headerlink" title="10.5  模块化程序设计"></a>10.5  模块化程序设计</h2><h3 id="10-5-1-参数和结果的传递问题"><a href="#10-5-1-参数和结果的传递问题" class="headerlink" title="10.5.1 参数和结果的传递问题"></a>10.5.1 参数和结果的传递问题</h3><p>也就是说，传进来的参数是啥，返回值是个啥。</p>
<ol>
<li>传入的参数：<br>这个有很多，有用栈传递的，也有直接用内存单元或者寄存器。</li>
<li>返回值：<br>这个可以存在寄存器中返回跟传入参数的方法很像</li>
</ol>
<p>而模块化设计，其实就是相当于c语言中的函数，把一个段中的代码当做一个函数执行。</p>
<h3 id="10-5-2-寄存器冲突问题"><a href="#10-5-2-寄存器冲突问题" class="headerlink" title="10.5.2 寄存器冲突问题"></a>10.5.2 寄存器冲突问题</h3><p>冲突问题是什么呢？例如如果上面的模块使用的loop，即使用了寄存器cx，而call的模块也适用了loop，即也使用了cx，那么两者就将共用cx，肯定会出错！<br>解决办法有：</p>
<ol>
<li>让别的调用者调用其他寄存器（这个很难实现，你也不知道他会用到什么寄存器）</li>
<li>不要使用会冲突的寄存器（这个不可能实现，只是说说理想罢了）</li>
<li>用栈，压进去，保存，call完在出栈！（这个OK哦）</li>
</ol>
<h2 id="10-6-课后"><a href="#10-6-课后" class="headerlink" title="10.6 课后"></a>10.6 课后</h2><h3 id="下面的程序执行后，ax和bx中的数值为多少？"><a href="#下面的程序执行后，ax和bx中的数值为多少？" class="headerlink" title="下面的程序执行后，ax和bx中的数值为多少？"></a>下面的程序执行后，ax和bx中的数值为多少？</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">assume cs:codesg</span><br><span class="line">stack segment</span><br><span class="line">    dw 8 dup(0)</span><br><span class="line">stack ends</span><br><span class="line">codesg segment</span><br><span class="line">start:</span><br><span class="line">    mov ax,stack</span><br><span class="line">    mov ss,ax</span><br><span class="line">    mov sp,10h</span><br><span class="line">    mov word ptr ss:[0],offset s ;(ss:[0])=1ah</span><br><span class="line">    mov ss:[2],cs                ;(ss:[2])=cs</span><br><span class="line">    call dword ptr ss:[0]        ;cs入栈,ip=19h入栈,转到cs:1ah处执行指令</span><br><span class="line">                                 ;(ss:[4])=cs,(ss:[6])=ip</span><br><span class="line">    nop</span><br><span class="line">s:  mov ax,offset s              ;ax=1ah</span><br><span class="line">    sub ax,ss:[0ch]              ;ax=1ah-(ss:[0ch])=1ah-19h=1</span><br><span class="line">    mov bx,cs                    ;bx=cs＝0c5bh</span><br><span class="line">    sub bx,ss:[0eh]              ;bx=cs-cs=0</span><br><span class="line">    mov ax,4c00h</span><br><span class="line">    int 21h</span><br><span class="line">codesg ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure>
<h3 id="实验10-1-编写子程序-之-显示字符串"><a href="#实验10-1-编写子程序-之-显示字符串" class="headerlink" title="实验10-1 编写子程序 之 显示字符串"></a>实验10-1 编写子程序 之 显示字符串</h3><p>在这次实验中，我们将要编写3个子程序，通过它们来认识几个常见的问题和掌握解决这些问题的方法.同前面的所有实验一样，这个实验是必须独立完成的，在后面的课程中，将要用到这个实验中编写的3个子程序。</p>
<h4 id="显示字符串"><a href="#显示字符串" class="headerlink" title="显示字符串"></a>显示字符串</h4><h5 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h5><p>显示字符串是现实工作中经常要用到的功能，应该编写一个通用的子程序来实现这个功<br>能.我们应该提供灵活的调用接口，使调用者可以决定显示的位置(行、列)、内容和颜色。</p>
<h5 id="子程序描述"><a href="#子程序描述" class="headerlink" title="子程序描述"></a>子程序描述</h5><p>名称:show str<br>功能:在指定的位置，用指定的颜色，显示一个用0结束的字符串。<br>参数:(dh)=行号(取值范围。-24), (dl)=列号(取值范围0-79),<br>      (cl)=颜色，ds:si指向字符串的首地址<br>返回:无<br>应用举例:在屏幕的8行3列，用绿色显示data段中的字符串。</p>
<h4 id="提示"><a href="#提示" class="headerlink" title="提示"></a>提示</h4><ol>
<li>子程序的入口参数是屏幕上的行号和列号，注意在子程序内部要将它们转化为显存中的地址，首先要分析一下屏幕上的行列位置和显存地址的对应关系:</li>
<li>注意保存子程序中用到的相关寄存器:</li>
<li>这个子程序的内部处理和显存的结构密切相关.但是向外提供了与显存结构无关的接口。通过调用这个子程序，进行字符串的显示时可以不必了解显存的结构，为编程提供了方便。在实验中，注意体会这种设计思想。</li>
<li>其实这玩意，就是抢占了本来应该在屏幕中输出的系统信息。那么设置行列号的，就是占的信息的位置。<details>
<summary><mark><font color="darkred">点击查看参考代码</font></mark></summary>
<pre><code>  
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">assume cs:code,ds:data</span><br><span class="line"></span><br><span class="line">data segment</span><br><span class="line">	db &apos;Welcome to masm!&apos;,0</span><br><span class="line">data ends</span><br><span class="line"></span><br><span class="line">code segment</span><br><span class="line">start:	</span><br><span class="line">	mov dh,8	;行号</span><br><span class="line">	mov dl,3	;列号</span><br><span class="line">	mov cl,07h	;白色字	</span><br><span class="line">	mov ax,data</span><br><span class="line">	mov ds,ax</span><br><span class="line">	mov si,0	;循环加入字</span><br><span class="line">	call show_str</span><br><span class="line"></span><br><span class="line">	mov ax,4c00h</span><br><span class="line">	int 21h</span><br><span class="line">show_str:</span><br><span class="line">	push cx	;保存用到的寄存器</span><br><span class="line">	push si</span><br><span class="line">	push es</span><br><span class="line">	push di</span><br><span class="line">	push bx</span><br><span class="line"></span><br><span class="line">	mov ax,0b800h</span><br><span class="line">	mov es,ax</span><br><span class="line"></span><br><span class="line">	mov al,0a0h	;一行的总列数160字节</span><br><span class="line">	dec dh		;行号减1，因为是从0开始的</span><br><span class="line">	mul dh		;计算行开始偏移地址</span><br><span class="line">	mov bx,ax</span><br><span class="line"></span><br><span class="line">	mov al,2</span><br><span class="line">	mul dl		;计算列</span><br><span class="line">	sub ax,2	;列也是从0开始，而且一个字符占两个字节</span><br><span class="line">	add bx,ax	;求出开始位置	</span><br><span class="line">	</span><br><span class="line">	mov di,0</span><br><span class="line">	mov al,cl</span><br><span class="line">	mov ch,0	;高8位为0</span><br><span class="line">s:	</span><br><span class="line">	mov cl,ds:[si]	;判断是否到了字符结束</span><br><span class="line">	jcxz ok</span><br><span class="line">	mov es:[bx+di],cl</span><br><span class="line">	mov es:[bx+di+1],al</span><br><span class="line"></span><br><span class="line">	inc si</span><br><span class="line">	add di,2</span><br><span class="line">	jmp short s</span><br><span class="line">ok:</span><br><span class="line">	pop bx</span><br><span class="line">	pop di</span><br><span class="line">	pop es</span><br><span class="line">	pop si</span><br><span class="line">	pop cx</span><br><span class="line">	ret</span><br><span class="line"></span><br><span class="line">code ends</span><br><span class="line"></span><br><span class="line">end start</span><br></pre></td></tr></table></figure>
</code></pre>
</details>

</li>
</ol>
<h3 id="解决除法溢出问题"><a href="#解决除法溢出问题" class="headerlink" title="解决除法溢出问题"></a>解决除法溢出问题</h3><h4 id="问题："><a href="#问题：" class="headerlink" title="问题："></a>问题：</h4><p>其实就是如果商超过了应该存储商的寄存器的大小，应该怎么办。emmm可以用大一点的，用dword</p>
<h1 id="第十一章-标志寄存器"><a href="#第十一章-标志寄存器" class="headerlink" title="第十一章 标志寄存器"></a>第十一章 标志寄存器</h1><p>这是一种特殊的寄存器，一共16位：</p>
<ol>
<li>用来存储相关指令的执行结果</li>
<li>用来为CPU执行相关指令提供行为依据</li>
<li>用来控制CPU的相关工作方式<br>其分布如下：</li>
</ol>
<p>|15|14|13|12|11|10|9|8|7|6|5|4|3|2|1|0|<br>|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|<br>|*|*|*|*|OF|DF|IF|TF|SF|ZF|*|AF|*|PF|*|CF|<br>其中*表示都没用：1 3 5 12 13 14 15在8086CPU中都没有使用。<br>注意：对标志位有影响的指令有：add,sub,mul,div,inc,or,and等，而没有影响的有：mov,push,pop等，它们大多数为传送指令。</p>
<h2 id="11-1-标志表"><a href="#11-1-标志表" class="headerlink" title="11.1 标志表"></a>11.1 标志表</h2><table>
<thead>
<tr>
<th>名称</th>
<th>代号</th>
<th>作用</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>零标志</td>
<td>ZF</td>
<td>判断结果是否为零</td>
<td>若为0则ZF=1，否则ZF=0</td>
</tr>
<tr>
<td>奇偶标志</td>
<td>PF</td>
<td>判断结果中1的个数是奇是偶</td>
<td>若1的个数为奇数则PF=0，否则为1</td>
</tr>
<tr>
<td>符号标志</td>
<td>SF</td>
<td>判断结果是正是负</td>
<td>若为正数则SF=0，否则为1</td>
</tr>
<tr>
<td>进位标志位</td>
<td>CF</td>
<td>在进行<strong>无符号</strong>运算时记录是否有向最高位<strong>进位</strong>或者<strong>借位</strong></td>
<td>那是假想的最高位</td>
</tr>
<tr>
<td>溢出标志</td>
<td>OF</td>
<td>判断是否超过容器所能装的最大数</td>
<td>如al=98+99=197，197&gt;127溢出，实际结果：-59</td>
</tr>
<tr>
<td>方向标志</td>
<td>DF</td>
<td>控制每次操作后si、di的增减</td>
<td>df=0 每次si,di增加；df=1 每次si,di减少。经常用作字符串的传送</td>
</tr>
</tbody></table>
<h2 id="11-2-与标志有关的指令"><a href="#11-2-与标志有关的指令" class="headerlink" title="11.2 与标志有关的指令"></a>11.2 与标志有关的指令</h2><h3 id="11-2-1-与CF相关的：adc-sdd指令"><a href="#11-2-1-与CF相关的：adc-sdd指令" class="headerlink" title="11.2.1 与CF相关的：adc,sdd指令"></a>11.2.1 与CF相关的：adc,sdd指令</h3><ol>
<li>adc：带进位加法。如：adc al,8h == al+8h+CF </li>
<li>sdd：带借位减法。如：sdd al,8h == al-8h-CF</li>
</ol>
<h3 id="11-2-2-与CF和ZF有关的：cmp指令（比较指令）"><a href="#11-2-2-与CF和ZF有关的：cmp指令（比较指令）" class="headerlink" title="11.2.2 与CF和ZF有关的：cmp指令（比较指令）"></a>11.2.2 与CF和ZF有关的：cmp指令（比较指令）</h3><p>指令格式：cmp <em>s1</em>,<em>s2</em><br>举个例子：cmp ax,bx<br>比对结果如下：</p>
<p>|情况|结果分析|结果|<br>|-|-|-|-|<br>|<strong>(ax)=(bx)</strong>|则(ax)-(bx)=0|<strong>zf=1</strong>;|<br>|<strong>(ax)≠(bx)</strong>|则(ax)-(bx)≠0|<strong>zf=0</strong>;|<br>|<strong>(ax)&lt;(bx)</strong>|则(ax卜(bx)将产生借位|<strong>cf=1</strong>;|<br>|<strong>(ax)≥(bx)</strong>|则(ax)-(bx)不必借位|<strong>cf=0</strong>;|<br>|<strong>(ax)&gt;(bx)</strong>|则(ax)-(bx)既<em>不必借位<em>，</em>结果又不为0</em>|<strong>cf=0并且zf=0</strong>;|<br>|<strong>(ax)≤(bx)</strong>|则(ax)-(bx)既<em>可能借位<em>，</em>结果可能为0</em>|<strong>cf=1或zf=1</strong>.|</p>
<h3 id="11-2-3-与CMP有关的比较结果条件转移指令"><a href="#11-2-3-与CMP有关的比较结果条件转移指令" class="headerlink" title="11.2.3 与CMP有关的比较结果条件转移指令"></a>11.2.3 与CMP有关的比较结果条件转移指令</h3><table>
<thead>
<tr>
<th>指令</th>
<th>含义</th>
<th>简记</th>
<th>符号</th>
<th>监测的相关标志位</th>
</tr>
</thead>
<tbody><tr>
<td>je</td>
<td>等于则转移</td>
<td>equal</td>
<td>=</td>
<td>zf=1</td>
</tr>
<tr>
<td>jne</td>
<td>不等于则转移</td>
<td>not equal</td>
<td>≠</td>
<td>zf=0</td>
</tr>
<tr>
<td>jb</td>
<td>低于则转移</td>
<td>below</td>
<td>＜</td>
<td>cf=1</td>
</tr>
<tr>
<td>jnb</td>
<td>不低于则转移</td>
<td>not below</td>
<td>≥</td>
<td>cf=0</td>
</tr>
<tr>
<td>ja</td>
<td>高于则转移</td>
<td>above</td>
<td>＞</td>
<td>cf=0且zf=0</td>
</tr>
<tr>
<td>jna</td>
<td>不高于则转移</td>
<td>not above</td>
<td>≤</td>
<td>cf=1或zf=1</td>
</tr>
</tbody></table>
<p>注意，这个一般是与cmp配合使用，如同call和ret一样，但是没有说一定要配合使用。</p>
<h3 id="11-2-4-与DF有关指令"><a href="#11-2-4-与DF有关指令" class="headerlink" title="11.2.4 与DF有关指令"></a>11.2.4 与DF有关指令</h3><table>
<thead>
<tr>
<th>指令</th>
<th>功能</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td>movsb</td>
<td>mov es:[di],byte ptr ds:[si]</td>
<td>从ds中取字符放到es指定的位置中，单位为字节，会令<strong>di和si同时±1</strong></td>
</tr>
<tr>
<td>movsw</td>
<td>mov es:[di],word ptr ds:[si]</td>
<td>从ds中取字符放到es指定的位置中，单位为字，会令di<strong>和si同时±2</strong></td>
</tr>
<tr>
<td>cld</td>
<td>设置df=0，正向</td>
<td>令di，si向增方向</td>
</tr>
<tr>
<td>std</td>
<td>设置df=1，逆向</td>
<td>令di，si向减方向</td>
</tr>
<tr>
<td>rep</td>
<td>重复指令，根据CX当中的值，与LOOP相似</td>
<td>配合movsb使用</td>
</tr>
</tbody></table>
<p>例子：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">我们来看下面的两个程序。</span><br><span class="line">(1)编程，用串传送指令，将data段中的第一个字符串复制到它后面的空间中。</span><br><span class="line">data segment</span><br><span class="line">db &apos;Welcome to masm!.</span><br><span class="line">db 16 dup (0)</span><br><span class="line">data ends</span><br><span class="line">我们分析一下，使用串传送指令进行数据的传送，需要给它提供一些必要的信息</span><br><span class="line">它们是:</span><br><span class="line">1. 传送的原始位置:ds:si:</span><br><span class="line">2. 传送的目的位置:es:di;</span><br><span class="line">3. 传送的长度:CX;</span><br><span class="line">4. 传送的方向:df.</span><br><span class="line">在这个问题中，这些信息如下。</span><br><span class="line">1. 传送的原始位置:data:O;</span><br><span class="line">2. 传送的目的位置:data:0010;</span><br><span class="line">3. 传送的长度:16;</span><br><span class="line">4. 传送的方向:因为正向传送(每次串传送指令执行后，Si和di递增此较方便，所以设置df=o</span><br><span class="line">好了，明确了这些信息之后，我们来编写程序:</span><br><span class="line">mov ax,data</span><br><span class="line">mov ds,ax</span><br><span class="line">mov si,0	;ds:si指向data: 0</span><br><span class="line">mov es,ax</span><br><span class="line">mov di,16	;es.di于行向data:0010</span><br><span class="line">mov cx,16	;(cx)-16, rep循环1‘次</span><br><span class="line">cld			;设置df=0，正向传送</span><br><span class="line">rep movsb</span><br></pre></td></tr></table></figure>

<h2 id="11-3-标志位有关的问题"><a href="#11-3-标志位有关的问题" class="headerlink" title="11.3 标志位有关的问题"></a>11.3 标志位有关的问题</h2><h3 id="11-3-1-单纯就符号标志位就可以判断结果的正负吗？（即判断相减的两个数的大小）"><a href="#11-3-1-单纯就符号标志位就可以判断结果的正负吗？（即判断相减的两个数的大小）" class="headerlink" title="11.3.1 单纯就符号标志位就可以判断结果的正负吗？（即判断相减的两个数的大小）"></a>11.3.1 单纯就符号标志位就可以判断结果的正负吗？（即判断相减的两个数的大小）</h3><p>当然不是！</p>
<blockquote>
<p>当1-2=-1&lt;0，则SF为1，表示负数，则前一个数比后一个数大<br>当34-(-96)=82H时，82H是-126的补码，所以SF=1，但是前一个数比后一个数大？当然不。</p>
</blockquote>
<p>为什么呢？<strong>因为发生了溢出</strong>。</p>
<ul>
<li>也就是说，保存结果的寄存器不足以表示那么大的数。</li>
<li>而34-(-96)=130明显超过127（假设保存结果的是ah）。 </li>
<li>那么结果就会表示为-126<em>（130-127=3，-128+3-1=-126）</em></li>
<li>而此时，SF=1，同时，<strong>OF=1</strong>。</li>
<li>所以<strong>要看结果的正负，要结合SF和OF的值</strong>.</li>
</ul>
<p>总结：</p>
<table>
<thead>
<tr>
<th>标志</th>
<th>结果</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>SF=1,OF=0</td>
<td>负</td>
<td>略</td>
</tr>
<tr>
<td>SF=1,OF=1</td>
<td>正</td>
<td>因为溢出导致实际结果为负，那么逻辑上必定为正</td>
</tr>
<tr>
<td>SF=0,OF=1</td>
<td>负</td>
<td>因为溢出导致实际结果为正，那么逻辑上必定为负</td>
</tr>
<tr>
<td>SF=0,OF=0</td>
<td>正</td>
<td>略</td>
</tr>
</tbody></table>
<h2 id="11-4-pushf和popf"><a href="#11-4-pushf和popf" class="headerlink" title="11.4 pushf和popf"></a>11.4 pushf和popf</h2><p>因为标志寄存器共16位，所以pushf就直接将16位当做寄存器放入栈中，popf是出栈。<br>注意，它们不需要加对象参数，入栈和出栈的对象都是标志寄存器！</p>
]]></content>
      <categories>
        <category>理论</category>
        <category>代码编程</category>
      </categories>
      <tags>
        <tag>汇编</tag>
        <tag>二进制</tag>
      </tags>
  </entry>
  <entry>
    <title>网络流量分析（nogotofail））</title>
    <url>/2019/11/10/%E7%BD%91%E7%BB%9C%E6%B5%81%E9%87%8F%E5%88%86%E6%9E%90-nogotofail/</url>
    <content><![CDATA[<h4 id="应用范围"><a href="#应用范围" class="headerlink" title="应用范围"></a>应用范围</h4><p>它包括对常见的SSL证书验证问题(HTTPS和TLS/SSL)的测试<br>库bug、SSL和STARTTLS剥离问题、明文问题等等。</p>
<a id="more"></a>

<h1 id="应用到的库："><a href="#应用到的库：" class="headerlink" title="应用到的库："></a>应用到的库：</h1><h2 id="psutil模块"><a href="#psutil模块" class="headerlink" title="psutil模块"></a>psutil模块</h2><p>psutil是一个<a href="http://pythonhosted.org/psutil/" target="_blank" rel="noopener">跨平台库</a>能够轻松实现获取系统运行的进程和系统利用率（包括CPU、内存、磁盘、网络等）信息。它主要用来做系统监控，性能分析，进程管理。它实现了同等命令行工具提供的功能，如ps、top、lsof、netstat、ifconfig、who、df、kill、free、nice、ionice、iostat、iotop、uptime、pidof、tty、taskset、pmap等。目前支持32位和64位的Linux、Windows、OS X、FreeBSD和Sun Solaris等操作系统.</p>
<h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><figure class="highlight plain"><figcaption><span>install psutil```</span></figcaption><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">### 基本使用</span><br><span class="line">#### 获取CPU时间</span><br></pre></td></tr></table></figure>
<blockquote>
<blockquote>
<blockquote>
<p>psutil.cpu_times()<br>scputimes(user=650613.02, nice=22.14, system=154916.5, idle=16702285.26, iowait=68894.55, irq=3.38, softirq=7075.65, steal=0.0, guest=0.0)</p>
</blockquote>
</blockquote>
</blockquote>
<p>```</p>
<blockquote>
<ol>
<li>psutil.process_iter()<br>遍历所有进程</li>
<li>psutil.version_info[] </li>
<li>psutil.net_connections<br>寻找连接(用户)的个数，在<a href="https://baike.baidu.com/item/mavericks/4902413?fr=aladdin" target="_blank" rel="noopener">OSX</a>中需要root权限</li>
<li>psutil.NoSuchProcess, psutil.AccessDenied</li>
</ol>
</blockquote>
<p><a href="https://www.cnblogs.com/saneri/p/7528283.html" target="_blank" rel="noopener">参考文章</a></p>
<p><a href="https://www.cnblogs.com/lfs2640666960/p/9330735.html" target="_blank" rel="noopener">https://www.cnblogs.com/lfs2640666960/p/9330735.html</a> 介绍的不错</p>
<ol start="5">
<li>bash: 未预期的符号 `newline’ 附近有语法错误:将&lt;&gt;换成’’</li>
</ol>
<h1 id="关于elk"><a href="#关于elk" class="headerlink" title="关于elk"></a>关于elk</h1><ol>
<li>安装<br>yum install -y elasticsearch<br>安装在/usr/share/elasticsearch当中，启动在bin当中的elasticsearch。用./Bin…来启动</li>
</ol>
<ul>
<li>测试运行：curl ‘<a href="http://localhost:9200/?pretty&#39;" target="_blank" rel="noopener">http://localhost:9200/?pretty&#39;</a></li>
<li>会得到<img src="/2019/11/10/%E7%BD%91%E7%BB%9C%E6%B5%81%E9%87%8F%E5%88%86%E6%9E%90-nogotofail/elasticsuccess.jpg" alt></li>
<li>Elasticsearch 的实例。 而一个 集群 是一组拥有相同 cluster.name 的节点， 他们能一起工作并共享数据，还提供容错与可伸缩性。(当然，一个单独的节点也可以组成一个集群) 你可以在 elasticsearch.yml 配置文件中 修改 cluster.name ，该文件会在节点启动时加载 (译者注：这个重启服务后才会生效)。 </li>
<li>而elasticsearch中的.yml在/etc/elasticsearch当中</li>
<li>设置：logstash，netflow，配置</li>
<li>可以用端口9200，web客户端，甚至curl进行交互<br>  curl -X<VERB> ‘<PROTOCOL>://<HOST>:<PORT>/<PATH>?<QUERY_STRING>‘ -d ‘<BODY>‘   <a href="https://www.elastic.co/guide/cn/elasticsearch/guide/current/_talking_to_elasticsearch.html" target="_blank" rel="noopener">使用参考</a></BODY></QUERY_STRING></PATH></PORT></HOST></PROTOCOL></VERB></li>
<li></li>
<li>会遇到问题：Exception in thread “main” org.elasticsearch.bootstrap.BootstrapException: java.nio.file.NoSuchFileException: /usr/share/elasticsearch/config<br>Likely root cause: java.nio.file.NoSuchFileException: /usr/share/elasticsearch/config …<br><a href="https://www.cnblogs.com/yswenli/p/6397351.html" target="_blank" rel="noopener">解决方法</a><br>其实就是： cp -r /etc/elasticsearch /usr/share/elasticsearch/config<br>➜  ~ groupadd elsearch<br>➜  ~ useradd elsearch -g elsearch -p elsearch<br>➜  ~ cd /usr/share<br>➜   chown -R elsearch:elsearch elasticsearch<br>➜  su elsearch<br>这是因为elasticsearch需要读写配置文件，我们需要给予config文件夹权限，上面新建了elsearch用户，elsearch用户不具备读写权限，因此还是会报错，解决方法是切换到管理员账户，赋予权限即可：<br>sudo -i<br>chmod -R 775 config<br><a href="https://www.linuxidc.com/Linux/2018-11/155518.htm" target="_blank" rel="noopener">这篇讲的很全</a></li>
</ul>
<p>安装sense<br>其实这个是Kibana的一个应用<br>安装：yum install -y kibana<br>测试运行也是一样的路径<br>    <a href="http://localhost:5601/app/sense" target="_blank" rel="noopener">http://localhost:5601/app/sense</a><br>这个是emmm，测试？</p>
<p>关于javaAPI交互<br>节点客户端（Node client）<br>    节点客户端作为一个非数据节点加入到本地集群中。换句话说，它本身不保存任何数据，但是它知道数据在集群中的哪个节点中，并且可以把请求转发到正确的节点。<br>传输客户端（Transport client）<br>    轻量级的传输客户端可以将请求发送到远程集群。它本身不加入集群，但是它可以将请求转发到集群中的一个节点上。<br>两个 Java 客户端都是通过 9300 端口并使用 Elasticsearch 的原生 传输 协议和集群交互。集群中的节点通过端口 9300 彼此通信。如果这个端口没有打开，节点将无法形成一个集群。</p>
<h2 id="安装elasticsearch-head遇到的问题"><a href="#安装elasticsearch-head遇到的问题" class="headerlink" title="安装elasticsearch-head遇到的问题"></a>安装elasticsearch-head遇到的问题</h2><ol>
<li>warning: notsup SKIPPING OPTIONAL DEPENDENCY: Unsupported platform for <a href="mailto:fsevents@1.2.4" target="_blank" rel="noopener">fsevents@1.2.4</a>: wanted {“os”<br>这个证明已经安装成功了<br><img src="/2019/11/10/%E7%BD%91%E7%BB%9C%E6%B5%81%E9%87%8F%E5%88%86%E6%9E%90-nogotofail/nmp2.png" alt></li>
<li>npm WARN <a href="mailto:elasticsearch-head@0.0.0" target="_blank" rel="noopener">elasticsearch-head@0.0.0</a> license should be a valid SPDX license expression<br>这个说你的license不对口，得去找找spdx licence是个啥玩意：<br>既然知道spdx是个啥，就不难解决问题了；让我打开正确的姿势：打开elasticsearch-head目录下的package.json文件，找到license位置，修改为上面这个网站上存在Identifier，就可以了。如图所示，把原来的Apache内容修改为Apache-2.0。具体修改后的内容参考官网上的Identifier数值（防止后续更新，授之于渔了）。<br><img src="/2019/11/10/%E7%BD%91%E7%BB%9C%E6%B5%81%E9%87%8F%E5%88%86%E6%9E%90-nogotofail/npm.png" alt></li>
<li>成功！<br><img src="/2019/11/10/%E7%BD%91%E7%BB%9C%E6%B5%81%E9%87%8F%E5%88%86%E6%9E%90-nogotofail/headok.jpg" alt></li>
<li>妈的，又不成功：This account is currently not available（用户当前不可用）<br>安装完elasticsearch之后系统会自动创建一个elasticsearch用户，在启动elasticsearch的时候需要切换该用户启动，但是在我切换到elasticsearch用户的时候显示This account is currently not available。</li>
</ol>
<p>查资料发现是因为该用户的shell不可用，查看/etc/passwd文件发现此用户的shell是/sbin/nologin需修改成/bin/bash</p>
<ol start="5">
<li>elasticsearch-head中cluster health: not connected<br>修改elasticsearch安装目录中 config/elasticsearch.yml<br>http.cors.enabled: true<br>http.cors.allow-origin: “*”<br>修改elasticsearch-head下Gruntfile.js<br>connect: {<br>server: {<br>options: {<br>hostname: ‘0.0.0.0’,<br>port: 9100,<br>base: ‘.’,<br>keepalive: true<br>}<br>}<br>}<br><a href="https://blog.csdn.net/qq_30505673/article/details/85051785" target="_blank" rel="noopener">原文链接</a></li>
</ol>
]]></content>
      <categories>
        <category>理论</category>
      </categories>
      <tags>
        <tag>网络流量</tag>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>算法实验</title>
    <url>/2019/11/10/%E7%AE%97%E6%B3%95%E5%AE%9E%E9%AA%8C/</url>
    <content><![CDATA[<h4 id="简介：包括线性时间算法，最长递增子序列，以斐波那契堆实现迪杰斯特拉算法"><a href="#简介：包括线性时间算法，最长递增子序列，以斐波那契堆实现迪杰斯特拉算法" class="headerlink" title="简介：包括线性时间算法，最长递增子序列，以斐波那契堆实现迪杰斯特拉算法"></a>简介：包括线性时间算法，最长递增子序列，以斐波那契堆实现迪杰斯特拉算法</h4><a id="more"></a>
<h2 id="1-线性时间选择（序数问题）"><a href="#1-线性时间选择（序数问题）" class="headerlink" title="1. 线性时间选择（序数问题）"></a>1. 线性时间选择（序数问题）</h2><ul>
<li>问题描述：已知n个数，找出排序后第k小的数。要求平均时间复杂度为O(n)。</li>
<li>解决思路：使用快速排序的思想解决查找问题，用随机数（舍伍德算法）解决基准问题，用分治策略搭建整体的算法结构。</li>
<li>步骤分析：<br>(1)    使用舍伍德算法选择基准r（第r个数）<br>(2)    用快速排序算法进行下面的操作：将大于基准的数值放于基准后，将小于基准的数值放于基准前，刷新数组的排序。<br>(3)    若想要查找的第k个数值的k比基准r大，则取数组的右边再重复进行以上操作，若小于，则选择左边的，若等于，则输出。</li>
<li>示例：<br><img src="/2019/11/10/%E7%AE%97%E6%B3%95%E5%AE%9E%E9%AA%8C/example1.png" alt><blockquote>
<p>示例分析：输入10个数，分别为5 2 7 8 9 0 1 3 4 6，第5小的元素为4，验证成功。</p>
</blockquote>
</li>
</ul>
<h2 id="2-最长递增子序列问题"><a href="#2-最长递增子序列问题" class="headerlink" title="2. 最长递增子序列问题"></a>2. 最长递增子序列问题</h2><ul>
<li>问题描述：寻找最长递增的序列。</li>
<li>解决思路：利用矩阵记录之前的结果，用动态规划法完成寻找</li>
<li>算法步骤：<br>(1)    设置变量有：存储当前最长序列的值的数组tempmax，存储最长序列长度maxlen存储最长序列的最大值下标maxindex<br>(2)    从下标为1的值开始遍历<br>(3)    若i下标下的值比前一个值大，则更新tempmax[i]=tempmax[i-1]+1，即增加长度1，若此时的tempmaxp[i]比maxlen大，则更新maxlen，且更新maxindex=1</li>
<li>示例：<br><img src="/2019/11/10/%E7%AE%97%E6%B3%95%E5%AE%9E%E9%AA%8C/example2.png" alt><br>示例分析：<blockquote>
<p>输入10个数分别为1 3 2 4 5 3 7 8 9 6，其最长递增子序列为3 7 8 9，长度为4，验证成功。</p>
</blockquote>
</li>
</ul>
<h2 id="3-斐波那契堆实现最短路径算法（迪杰斯特拉）"><a href="#3-斐波那契堆实现最短路径算法（迪杰斯特拉）" class="headerlink" title="3. 斐波那契堆实现最短路径算法（迪杰斯特拉）"></a>3. 斐波那契堆实现最短路径算法（迪杰斯特拉）</h2><ul>
<li>问题描述：用斐波那契堆取最小路径辅助迪杰斯特拉算法实现最小路径算法</li>
<li>解决思路：1. 使用贪心算法实现迪杰斯特拉最短路径算法，使用斐波那契堆建立最小堆，方便取最小‘结点’以完成接下来的操作</li>
<li>算法思想：</li>
</ul>
<ol>
<li><p>迪杰斯特拉伪代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">DIJKSTRA(G, w, s)</span><br><span class="line">INITIALIZE - SINGLE - SOURCE(G, s)</span><br><span class="line">S ← Ø</span><br><span class="line">Q ← V[G]   //第3行，INSERT操作，O（1）构造堆</span><br><span class="line">while Q ≠ Ø</span><br><span class="line">	do u ← EXTRACT - MIN(Q)   //第5行，从堆中取出最小点</span><br><span class="line">      S ← S ∪&#123; u &#125;</span><br><span class="line">      for each vertex v ∈ Adj[u]</span><br><span class="line">          do RELAX(u, v, w)  //第8行，RELAX操作，对堆进行降级工作</span><br></pre></td></tr></table></figure></li>
<li><p>其中在第5行的EXTRACT-MIN操作用斐波那契堆实现，斐波那契堆结构如下:</p>
<blockquote>
<ul>
<li>斐波那契堆是由一组最小堆有序树构成的。每个节点的度数为其子节点的数目。树的度数为其根节点的度数。</li>
<li>斐波那契堆中的树都是有根的但是无序。每个节点x包含指向父节点的指针p[x]和指向任意一个子结点的child[x]。x的所有子节点都用双向循环链表链接起来，叫做x的子链表。子链表中的每一个节点y都有指向它的左兄弟的left[y]和右兄弟的right[y]。如果节点y是x仅有的子节点，则left[y]=right[y]=y。</li>
<li>斐波那契堆中所有树的根节点也用一个双向循环链表链接起来。使用一个指针指向斐波那契堆中最小元素。</li>
</ul>
</blockquote>
</li>
<li><p>用稀疏矩阵表示图，定义为weight</p>
</li>
<li><p>具体实现示例分析：<br><img src="/2019/11/10/%E7%AE%97%E6%B3%95%E5%AE%9E%E9%AA%8C/example3-1.png" alt></p>
<blockquote>
<p>其矩阵如：<br> {0,4,NoEdge,2,NoEdge},<br> {4,0,4,1,NoEdge},<br> {NoEdge,4,0,1,3},<br> {2,1,1,0,7},<br>{NoEdge,NoEdge,3,7,0}<br>最终应该得到结果：<br>a-&gt;a=0<br>a-&gt;d-&gt;b=3<br>a-&gt;d-&gt;c=3<br>a-&gt;d=2<br>a-&gt;d-&gt;c-&gt;e=6</p>
</blockquote>
<p> <img src="/2019/11/10/%E7%AE%97%E6%B3%95%E5%AE%9E%E9%AA%8C/example3-2.png" alt="a"><br>测试成功！</p>
</li>
</ol>
]]></content>
      <categories>
        <category>代码编程</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2019/11/10/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p>
<a id="more"></a>

<h2 id="HEXO常用："><a href="#HEXO常用：" class="headerlink" title="HEXO常用："></a>HEXO常用：</h2><h3 id="新建文章"><a href="#新建文章" class="headerlink" title="新建文章"></a>新建文章</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p>
<h3 id="启动本地镜像服务"><a href="#启动本地镜像服务" class="headerlink" title="启动本地镜像服务"></a>启动本地镜像服务</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p>
<h3 id="生成静态文件"><a href="#生成静态文件" class="headerlink" title="生成静态文件"></a>生成静态文件</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p>
<h3 id="上传文件（同步）"><a href="#上传文件（同步）" class="headerlink" title="上传文件（同步）"></a>上传文件（同步）</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br><span class="line">$ hexo d 也可</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p>
<h2 id="常要注意的玩意："><a href="#常要注意的玩意：" class="headerlink" title="常要注意的玩意："></a>常要注意的玩意：</h2><h3 id="hexo图片问题"><a href="#hexo图片问题" class="headerlink" title="hexo图片问题"></a><a href="https://www.jianshu.com/p/3db6a61d3782" target="_blank" rel="noopener">hexo图片问题</a></h3><h3 id="hexo阅读更多"><a href="#hexo阅读更多" class="headerlink" title="hexo阅读更多"></a>hexo阅读更多</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install hexo-generator-index2 --save</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># index2 generator是否包含官方的hexo-generator-index，默认true（包含）</span><br><span class="line">index2_include_index: true</span><br><span class="line">index2_generator:</span><br><span class="line">    per_page: 8</span><br><span class="line">    order_by: -date # 按发布时间排序</span><br><span class="line">    exclude:</span><br><span class="line">        - tag hide # 不包含标签为hide的文章</span><br><span class="line">        - category hide # 不包含分类为hide的文章</span><br></pre></td></tr></table></figure>
<p>然后</p>
<h2 id="博客设置问题："><a href="#博客设置问题：" class="headerlink" title="博客设置问题："></a>博客设置问题：</h2><h3 id="头像-amp-图标："><a href="#头像-amp-图标：" class="headerlink" title="头像&amp;图标："></a>头像&amp;图标：</h3><p>在主题目录下配置文件中.<br>头像：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">author:</span><br><span class="line">  name: DuK</span><br><span class="line">  work: Study,0-1</span><br><span class="line">  location: China</span><br><span class="line">  avatar_url: /images/avatar.png</span><br></pre></td></tr></table></figure>
<p>而其图标：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">favicon: /images/favicon.ico</span><br></pre></td></tr></table></figure>
<p>网站：<a href="http://www.faviconico.org/" target="_blank" rel="noopener">图标制作</a></p>
<h3 id="侧边栏目（标签，归档）"><a href="#侧边栏目（标签，归档）" class="headerlink" title="侧边栏目（标签，归档）"></a>侧边栏目（标签，归档）</h3><p>得先进行</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo new page tags</span><br></pre></td></tr></table></figure>
<p>然后才会有，这里tags还要加上：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: tags</span><br><span class="line">date: 2019-11-10 11:36:27</span><br><span class="line">layout: tags</span><br><span class="line">---</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>配置</tag>
        <tag>博客</tag>
        <tag>指令</tag>
      </tags>
  </entry>
</search>
