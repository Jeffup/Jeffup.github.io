<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>入侵检测实验</title>
    <url>/2020/05/26/%E5%85%A5%E4%BE%B5%E6%A3%80%E6%B5%8B%E5%AE%9E%E9%AA%8C/</url>
    <content><![CDATA[<p>本文章介绍入侵检测技术以及各种工具的使用。</p>
<a id="more"></a>
<h1 id="第一章-入侵检测"><a href="#第一章-入侵检测" class="headerlink" title="第一章 入侵检测"></a>第一章 入侵检测</h1><h2 id="一、原理"><a href="#一、原理" class="headerlink" title="一、原理"></a>一、原理</h2><p>入侵检测系统，<strong>简称IDC，是一种基于硬件的防火墙</strong>，通过建控以知系统漏洞，黑客入侵手法并记录下来，通过分析数据包，安全的就通过。危险的就拦截，通过日志记录可轻松追查到入侵者的IP，用于取证。</p>
<p><strong>入侵检测技术（IDS）可以被定义为对计算机和网络资源的恶意使用行为进行识别和相应处理的系统</strong>。包括系统外部的入侵和内部用户的非授权行为,是为保证计算机系统的安全而设计与配置的一种能够及时发现并报告系统中未授权或异常现象的技术，是一种用于检测计算机网络中违反安全策略行为的技术。</p>
<h3 id="1-1-什么是入侵"><a href="#1-1-什么是入侵" class="headerlink" title="1.1 什么是入侵"></a>1.1 什么是入侵</h3><p>入侵，就是恶意攻击者（俗称黑客），不经授权的控制、使用我方资源（读写文件、执行命令、控制网络资源等） </p>
<h3 id="1-2-入侵和内鬼"><a href="#1-2-入侵和内鬼" class="headerlink" title="1.2 入侵和内鬼"></a>1.2 入侵和内鬼</h3><p>入侵本身是手段，GetShell只是开始，目的是为了之后对资源的控制和数据的窃取。而内鬼本身拥有合法的权限，可以合法接触敏感资产，但是基于工作以外的目的对这些资源进行非法处置，包括拷贝副本、转移外泄、篡改数据牟利等</p>
<h2 id="二、入侵的本质"><a href="#二、入侵的本质" class="headerlink" title="二、入侵的本质"></a>二、入侵的本质</h2><h3 id="2-1-入侵检测的本质"><a href="#2-1-入侵检测的本质" class="headerlink" title="2.1 入侵检测的本质"></a>2.1 入侵检测的本质</h3><p>根据特征进行模式匹配；（黑特征法，例如WebShell关键字匹配）</p>
<p>根据业务历史行为（生成基线模型），对入侵行为做异常对比；（非白既黑），如果业务的历史行为不够收敛，就用加固的手段对其进行收敛，再挑出不合规的小众异常行为。</p>
<h3 id="2-2-入侵检测与攻击向量"><a href="#2-2-入侵检测与攻击向量" class="headerlink" title="2.2 入侵检测与攻击向量"></a>2.2 入侵检测与攻击向量</h3><p>针对一个明确的“目标”，它被访问的渠道可能是有限集，被攻击的必经路径也有限。一个可以成功入侵的 <strong>攻击方法 + 目标</strong> 合并起来，就称为一个“攻击向量”</p>
<p>因此，谈入侵检测模型效果时，需要先明确攻击向量，针对不同的攻击路径，采集对应的数据，才可能做对应的检测模型。比如，基于SSH登录后的SHELL命令采集，是不会让你发现Webshell的攻击的。而基于网络流量的采集数据，也不会让你获悉黑客是否在SSH后的SHELL环境里执行了什么文件切割打包的动作。</p>
<h3 id="2-3-常见的入侵手法"><a href="#2-3-常见的入侵手法" class="headerlink" title="2.3 常见的入侵手法"></a>2.3 常见的入侵手法</h3><ol>
<li>高危服务入侵：所有的公共服务都叫做高危端口</li>
<li>Web入侵：基于PHP、JAVA、ASP/<a href="http://ASP.NET、NODE、C写的cgi等等动态的Web服务本身的漏洞" target="_blank" rel="noopener">http://ASP.NET、NODE、C写的cgi等等动态的Web服务本身的漏洞</a></li>
<li>0day入侵 ：通过NSA泄漏的工具包　</li>
<li>通过办公网入侵 ：绝大多数APT报告里，黑客是先对人下手，比如发个邮件，哄骗你打开后，控制了你的PC，再进行长期的观察/翻阅，拿到你的合法凭据后，再到内网漫游</li>
</ol>
<h3 id="2-4-常见入侵的应对方法"><a href="#2-4-常见入侵的应对方法" class="headerlink" title="2.4 常见入侵的应对方法"></a>2.4 常见入侵的应对方法</h3><ol>
<li>高危服务入侵：在这里做入侵检测的必要性不高，因为高危服务的具体所指非常的多，不一定存在通用的特征，所以，通过加固方式，收敛攻击入口才是更有效的策略。禁止所有高危端口对互联网开放即可</li>
<li>Web入侵：找到黑客GetShell和正常业务行为的一些区别</li>
<li>0day入侵：入侵检测模型可以通用</li>
</ol>
<h2 id="三、-发现APT"><a href="#三、-发现APT" class="headerlink" title="三、 发现APT"></a>三、 发现APT</h2><p>所谓APT，就是<strong>高级的持续威胁</strong>。既然是高级的，按照一般的描述，他们的木马是免杀的（不能假定我们可以发现这个木马）、他们的漏洞不公开的（不能假定我们可以加固抵抗）、他们的手法是高级的（不能假定这个手法在已知的范畴里）。</p>
<p>所以，实际上<strong>APT的意思就几乎等同于我们不能发现的入侵事件</strong>了。</p>
<p>但是，业界总还有APT检测产品、解决方案的厂商在混饭吃，他们是怎么做的呢？</p>
<blockquote>
<ul>
<li>说木马免杀的，他们用沙箱+人工分析，哪怕效率低一些，还是试图做出定性，并快速的把IOC（威胁情报）同步给其它客户，发现1例，全网都去排查。</li>
<li>说流量变形对抗的，他们用异常检测的模型，把一些不认识的可疑的IP关系、payload给识别出来——当然，识别出来之后，也要运营人员跟进得仔细才能定性。</li>
<li>说攻击手法高级的，他们还是会假定黑客就用鱼叉、水坑之类的已知手法去执行，然后在邮箱附件、PC终端等环节采集日志，对用户行为进行分析，UEBA试图寻找出用户异于平常的动作。</li>
</ul>
</blockquote>
<h1 id="第二章-蜜罐（部署实验）"><a href="#第二章-蜜罐（部署实验）" class="headerlink" title="第二章 蜜罐（部署实验）"></a>第二章 蜜罐（部署实验）</h1><h2 id="一、蜜罐原理"><a href="#一、蜜罐原理" class="headerlink" title="一、蜜罐原理"></a>一、蜜罐原理</h2><h3 id="1-1-什么是蜜罐"><a href="#1-1-什么是蜜罐" class="headerlink" title="1.1 什么是蜜罐"></a>1.1 什么是蜜罐</h3><p><strong>蜜罐其实就是一个“陷阱”程序</strong>，这个陷阱是指对人侵者而特意设计出来的-些伪造的系统漏洞。这些伪造的系统漏洞，在引诱入侵者扫描或攻击时，就会激活能够触发报警事件的软件。这样一来，网管就可以立即知晓有入侵者侵入了。</p>
<p>也就是说通过设置蜜罐程序，一旦操作系统中出现入侵事件，那么系统就可以很快发出报警。在许多大的网络中。一般都设计有专门的蜜罐程序。蜜罐程序一般分为两种：一种是只发现人侵者而不对其采取报复行动，另一种是同时采取报复行动。</p>
<p>0K，在进行了初步的了解后，请读者先来牢记两个英文的含义：</p>
<blockquote>
<p><strong>Honeypot</strong>：是一种故意存在着缺陷的虛拟系统，用来对黑客进行欺骗。<br><strong>Honeynet</strong>：是一个很有学习价値的工具，它能使我们了解黑客人侵的攻击方式。</p>
</blockquote>
<p>作为一个包含漏洞的系统，它可以帮助有特殊要求的网络模拟出一个或多个易受攻的主机，给xp系统下载黑客提供易受攻击的口标，让黑客误认为入侵成功，可以为所欲为了。使用蜜罐，主要是为了能够套住黑客，以便网络保安系统和人员能够将之“锁定”。</p>
<h3 id="1-2-蜜罐分类"><a href="#1-2-蜜罐分类" class="headerlink" title="1.2 蜜罐分类"></a>1.2 蜜罐分类</h3><ol>
<li>低交互：模拟服务和漏洞以便收集信息和恶意软件，但是攻击者无法和该系统进行交互；</li>
<li>中等交互：在一个特有的控制环境中模拟一个生产服务，允许攻击者的部分交互；</li>
<li>高交互：攻击者可以几乎自由的访问系统资源直至系统重新清除恢复。</li>
</ol>
<h3 id="1-3-什么是pentbox"><a href="#1-3-什么是pentbox" class="headerlink" title="1.3 什么是pentbox"></a>1.3 什么是pentbox</h3><p>基于Ruby开发，面向GNU/Linux系统,且兼容Windows、MacOS、Android等系统。</p>
<p>主要用于帮助安全人员对网络、系统的安全性和稳定性进行测试。但它常被用作黑客工具套件,尤其是它提供的NetDoSTest(网络压力测试)。 </p>
<h2 id="二、安装和使用Pentbox"><a href="#二、安装和使用Pentbox" class="headerlink" title="二、安装和使用Pentbox"></a>二、安装和使用Pentbox</h2><h3 id="2-1-解压"><a href="#2-1-解压" class="headerlink" title="2.1 解压"></a>2.1 解压</h3><p><img src="/2020/05/26/%E5%85%A5%E4%BE%B5%E6%A3%80%E6%B5%8B%E5%AE%9E%E9%AA%8C/2.1.jpg" alt></p>
<h3 id="2-2-修改pentbox-rb，注释生成日志文件"><a href="#2-2-修改pentbox-rb，注释生成日志文件" class="headerlink" title="2.2 修改pentbox.rb，注释生成日志文件"></a>2.2 修改pentbox.rb，注释生成日志文件</h3><p>查看文件夹：<br><img src="/2020/05/26/%E5%85%A5%E4%BE%B5%E6%A3%80%E6%B5%8B%E5%AE%9E%E9%AA%8C/2.2.jpg" alt><br>修改<code>pentbox.rb</code><br><img src="/2020/05/26/%E5%85%A5%E4%BE%B5%E6%A3%80%E6%B5%8B%E5%AE%9E%E9%AA%8C/2.3.jpg" alt></p>
<h3 id="2-3-penbox界面"><a href="#2-3-penbox界面" class="headerlink" title="2.3 penbox界面"></a>2.3 penbox界面</h3><p><img src="/2020/05/26/%E5%85%A5%E4%BE%B5%E6%A3%80%E6%B5%8B%E5%AE%9E%E9%AA%8C/2.4.jpg" alt><br>根据上面选项，选择Network Tool。然后进行以下选择：<br><img src="/2020/05/26/%E5%85%A5%E4%BE%B5%E6%A3%80%E6%B5%8B%E5%AE%9E%E9%AA%8C/2.5.jpg" alt><br>80端口已经打开，若有人连接则会显示</p>
<h3 id="2-4-目标机尝试连接已安装Pentbox的机子（ip：10-5-10-42）"><a href="#2-4-目标机尝试连接已安装Pentbox的机子（ip：10-5-10-42）" class="headerlink" title="2.4 目标机尝试连接已安装Pentbox的机子（ip：10.5.10.42）"></a>2.4 目标机尝试连接已安装Pentbox的机子（ip：10.5.10.42）</h3><p>目标机用浏览器连接机子后，机子展示界面：<br><img src="/2020/05/26/%E5%85%A5%E4%BE%B5%E6%A3%80%E6%B5%8B%E5%AE%9E%E9%AA%8C/2.6.jpg" alt></p>
<blockquote>
<p><strong>HONEYPOT ACTIVATED ON PORT 80</strong>其中<strong>80</strong>为<strong>域名</strong></p>
</blockquote>
<h1 id="第三章-后门检测工具"><a href="#第三章-后门检测工具" class="headerlink" title="第三章 后门检测工具"></a>第三章 后门检测工具</h1><h2 id="一、实验原理"><a href="#一、实验原理" class="headerlink" title="一、实验原理"></a>一、实验原理</h2><h3 id="1-1-rootkit简介"><a href="#1-1-rootkit简介" class="headerlink" title="1.1 rootkit简介"></a>1.1 rootkit简介</h3><p><strong>rootkit是Linux平台下最常见的一种木马后门工具</strong>，它主要通过替<strong>换系统文件</strong>来达到入侵和和隐蔽的目的，这种木马比普通木马后门更加危险和隐蔽，普通的检测工具和检查手段很难发现这种木马。rootkit攻击能力极强，对系统的危害很大，它通过一套工具来建立后门和隐藏行迹，从而让攻击者保住权限，<strong>以使它在任何时候都可以使用root权限登录到系统</strong>。</p>
<p>rootkit主要有两种类型：<strong>文件级别</strong>和<strong>内核级别</strong>，下面分别进行简单介绍。</p>
<ol>
<li><p><strong>文件级别rootkit</strong><br>文件级别的rootkit一般是通过程序漏洞或者系统漏洞进入系统后，通过修改系统的重要文件来达到隐藏自己的目的。<strong>在系统遭受rootkit攻击后，合法的文件被木马程序替代，变成了外壳程序，而其内部是隐藏着的后门程序。</strong>通常容易被rootkit替换的系统程序有<strong>login、ls、ps、ifconfig、du、find、netstat</strong>等，<strong>其中login程序是最经常被替换的</strong>，因为当访问Linux时，无论是通过本地登录还是远程登录，<code>/bin/login</code>程序都会运行，系统将通过<code>/bin/login</code>来收集并核对用户的账号和密码，而rootkit就是利用这个程序的特点，<strong>使用一个带有根权限后门密码的/bin/login来替换系统的/bin/login</strong>，这样攻击者通过输入设定好的密码就能轻松进入系统。此时，即使系统管理员修改root密码或者清除root密码，攻击者还是一样能通过root用户登录系统。攻击者通常在进入Linux系统后，会进行一系列的攻击动作，最常见的是安装嗅探器收集本机或者网络中其他服务器的重要数据。在默认情况下，Linux中也有一些系统文件会监控这些工具动作，例如ifconfig命令，所以，攻击者为了避免被发现，会想方设法替换其他系统文件，常见的就是ls、ps、ifconfig、du、find、netstat等。如果这些文件都被替换，那么在系统层面就很难发现rootkit已经在系统中运行了。</p>
<p>这就是文件级别的rootkit，对系统维护很大，<strong>目前最有效的防御方法是定期对系统重要文件的完整性进行检查</strong>，如果发现文件被修改或者被替换，那么很可能系统已经遭受了rootkit入侵。<strong>检查件完整性的工具</strong>很多，常见的有<strong>Tripwire、 aide</strong>等，可以通过这些工具定期检查文件系统的完整性，以检测系统是否被rootkit入侵。</p>
</li>
<li><p><strong>内核级别的rootkit</strong><br>内核级rootkit是<strong>比文件级rootkit更高级的一种入侵方式</strong>，它可以使攻击者获得对系统底层的完全控制权，<strong>此时攻击者可以修改系统内核，进而截获运行程序向内核提交的命令，并将其重定向到入侵者所选择的程序并运行此程序</strong>，也就是说，当用户要运行程序A时，被入侵者修改过的内核会假装执行A程序，而实际上却执行了程序B。</p>
<p>内核级rootkit主要依附在内核上，<strong>它并不对系统文件做任何修改</strong>，因此一般的检测工具很难检测到它的存在，这样一旦系统内核被植入rootkit，攻击者就可以对系统为所欲为而不被发现。目前对于内核级的rootkit<strong>还没有很好的防御工具</strong>，因此，做好系统安全防范就非常重要，将系统维持在最小权限内工作，只要攻击者不能获取root权限，就无法在内核中植入rootkit。</p>
</li>
</ol>
<h3 id="1-2-chkrootkit的缺点"><a href="#1-2-chkrootkit的缺点" class="headerlink" title="1.2 chkrootkit的缺点"></a>1.2 chkrootkit的缺点</h3><p><strong>chkrootkit在检查rootkit的过程中使用了部分系统命令</strong>，因此，如果服务器被黑客入侵，<strong>那么依赖的系统命令可能也已经被入侵者替换</strong>，此时chkrootkit的检测结果将变得完全不可信。为了避免chkrootkit的这个问题，<strong>可以在服务器对外开放前，事先将chkrootkit使用的系统命令进行备份</strong>。</p>
<h3 id="1-3-rootkit后门检测工具RKHunter"><a href="#1-3-rootkit后门检测工具RKHunter" class="headerlink" title="1.3 rootkit后门检测工具RKHunter"></a>1.3 rootkit后门检测工具RKHunter</h3><p>RKHunter是一款专业的检测系统是否感染rootkit的工具，它通过执行一系列的脚本来确认服务器是否已经感染rootkit。在官方的资料中，RKHunter可以作的事情有：</p>
<blockquote>
<p>MD5校验测试，检测文件是否有改动<br>检测rootkit使用的二进制和系统工具文件<br>检测特洛伊木马程序的特征码<br>检测常用程序的文件属性是否异常<br>检测系统相关的测试<br>检测隐藏文件<br>检测可疑的核心模块LKM<br>检测系统已启动的监听端口</p>
</blockquote>
<h2 id="二、软件chkrootkit"><a href="#二、软件chkrootkit" class="headerlink" title="二、软件chkrootkit"></a>二、软件chkrootkit</h2><h3 id="2-1-安装chkrootkit"><a href="#2-1-安装chkrootkit" class="headerlink" title="2.1 安装chkrootkit"></a>2.1 安装chkrootkit</h3><p>从官网上下载安装，安装完成：<br><img src="/2020/05/26/%E5%85%A5%E4%BE%B5%E6%A3%80%E6%B5%8B%E5%AE%9E%E9%AA%8C/3.1.jpg" alt><br><em>注：上图中的错误并不影响下面的操作</em></p>
<h3 id="2-2-复制一份文件到-usr-local-chkrootkit路径下，将原有带版本号的删除"><a href="#2-2-复制一份文件到-usr-local-chkrootkit路径下，将原有带版本号的删除" class="headerlink" title="2.2  复制一份文件到 /usr/local/chkrootkit路径下，将原有带版本号的删除"></a>2.2  复制一份文件到 /usr/local/chkrootkit路径下，将原有带版本号的删除</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd ..</span><br><span class="line">cp -r chkrootkit-* /usr/local/chkrootkit</span><br><span class="line">　　拷贝一份文件</span><br><span class="line">rm -rf chkrootkit-*</span><br></pre></td></tr></table></figure>

<h3 id="2-3-使用chkrootkit"><a href="#2-3-使用chkrootkit" class="headerlink" title="2.3 使用chkrootkit"></a>2.3 使用chkrootkit</h3><p>安装完的chkrootkit程序位于/usr/local/chkrootkit目录下，执行如下命令即可显示chkrootkit的详细用法,如图下所示：<br><code>/usr/local/chkrootkit/chkrootkit -h</code><br><img src="/2020/05/26/%E5%85%A5%E4%BE%B5%E6%A3%80%E6%B5%8B%E5%AE%9E%E9%AA%8C/3.2.jpg" alt><br>下面是为上图的各参数进行解释，含义如图下所示：</p>
<blockquote>
<p>-h 显示帮助信息<br>-v 显示版本信息<br>-l 显示测试内容<br>-d debug模式，显示检测过程的相关指令程序<br>-q 安静模式，只显示有问题的内容<br>-x 高级模式，显示所有检测结果<br>-r dir设置指定的目录为根目录<br>-p dir1：dir2：dirN指定chkrootkit检测时使用系统命令的目录</p>
</blockquote>
<p> chkrootkit的使用比较简单，直接执行chkrootkit -x进入高级模式，显示所有检测结果，检测结果如图下所示：<br><code>/usr/local/chkrootkit/chkrootkit -x</code><br><img src="/2020/05/26/%E5%85%A5%E4%BE%B5%E6%A3%80%E6%B5%8B%E5%AE%9E%E9%AA%8C/3.3.jpg" alt></p>
<h2 id="三、软件RKHunter"><a href="#三、软件RKHunter" class="headerlink" title="三、软件RKHunter"></a>三、软件RKHunter</h2><h3 id="3-1-安装RKHunter"><a href="#3-1-安装RKHunter" class="headerlink" title="3.1 安装RKHunter"></a>3.1 安装RKHunter</h3><p>官网：<code>http://www.rootkit.nl/projects/rootkit_hunter.html</code><br>解压之后进入目录，对文件进行编译，结果如图下所示：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd rkhunter-1.4.6</span><br><span class="line">./installer.sh --layout default --install</span><br></pre></td></tr></table></figure>
<p>安装成功：<br><img src="/2020/05/26/%E5%85%A5%E4%BE%B5%E6%A3%80%E6%B5%8B%E5%AE%9E%E9%AA%8C/3.4.jpg" alt><br>下图是对常用参数以及含义的解释：</p>
<blockquote>
<p>-c, –check必选参数，表示检测当前系统<br>–configfile 使用特定的配置文件<br>–cronjob作为cron任务定期运行<br>–sk, –skip-keypress自动完成所有检测，跳过键盘输入<br>–summary显示检测结果的统计信息<br>–update检测更新内容<br>-V, –version显示版本信息<br>–versioncheck检测最新版本</p>
</blockquote>
<h3 id="3-2-使用RKHunter"><a href="#3-2-使用RKHunter" class="headerlink" title="3.2 使用RKHunter"></a>3.2 使用RKHunter</h3><p>下面是通过rkhunter对某个系统的检测，结果如图下所示：<br>执行：<code>/usr/local/bin/rkhunter -c</code></p>
<ol>
<li>下面是第一部分，先进行系统命令的检查，主要是检测系统的二进制文件，因为这些文件最容易被rootkit攻击。显示OK字样表示正常，<strong>显示Warning表示有异常</strong>，需要引起注意，而显示“Not found”字样，一般无需理会。<br><img src="/2020/05/26/%E5%85%A5%E4%BE%B5%E6%A3%80%E6%B5%8B%E5%AE%9E%E9%AA%8C/3.5.jpg" alt></li>
<li>下面是第二部分，主要检测常见的rootkit程序，显示“Not found”表示系统未感染此rootkit，结果如图所示：<br><img src="/2020/05/26/%E5%85%A5%E4%BE%B5%E6%A3%80%E6%B5%8B%E5%AE%9E%E9%AA%8C/3.6.jpg" alt></li>
<li>下面是第三部分，主要是一些特殊或附加的检测，例如对rootkit文件或目录检测、对恶意软件检测以及对指定的内核模块检测,结果如图下所示：<br><img src="/2020/05/26/%E5%85%A5%E4%BE%B5%E6%A3%80%E6%B5%8B%E5%AE%9E%E9%AA%8C/3.7.jpg" alt></li>
<li>下面是第四部分，主要对网络、系统端口、系统启动文件、系统用户和组配置、SSH配置、文件系统等进行检测，结果如图所示：<br><img src="/2020/05/26/%E5%85%A5%E4%BE%B5%E6%A3%80%E6%B5%8B%E5%AE%9E%E9%AA%8C/3.8.jpg" alt></li>
<li>下面是最后一部分，这个部分其实是上面输出的一个总结，通过这个总结，可以大概了解服务器目录的安全状态，结果如图所示：<br><img src="/2020/05/26/%E5%85%A5%E4%BE%B5%E6%A3%80%E6%B5%8B%E5%AE%9E%E9%AA%8C/3.9.jpg" alt></li>
</ol>
<h1 id="第四章-Surikata入侵检测系统"><a href="#第四章-Surikata入侵检测系统" class="headerlink" title="第四章 Surikata入侵检测系统"></a>第四章 Surikata入侵检测系统</h1><h2 id="一、简介"><a href="#一、简介" class="headerlink" title="一、简介"></a>一、简介</h2><h3 id="1-1-Suricata简介"><a href="#1-1-Suricata简介" class="headerlink" title="1.1 Suricata简介"></a>1.1 Suricata简介</h3><p>Suricata是一个高性能的<strong>网络IDS，IPS和网络安全监控引擎</strong>。</p>
<p><strong>IPS：入侵预防系统</strong>(IPS: Intrusion Prevention System)是电脑网络安全设施，是对<strong>防病毒软件（Antivirus Programs）和防火墙(Packet Filter, Application Gateway)的补充</strong>。 入侵预防系统(Intrusion-prevention system)是一部能够监视网络或网络设备的网络资料传输行为的计算机网络安全设备，能够即时的中断、调整或隔离一些不正常或是具有伤害性的网络资料传输行为。是新一代的侵入检测系统（IDS）。</p>
<p><strong>Suricata是一个网络入侵检测和防护引擎</strong>，由开放信息安全基金会及其支持的厂商开发。该引擎是多线程的，内置支持IPV6。可加载现有的Snort规则和签名，支持Barnyard 和 Barnyard2 工具.</p>
<p>IDS：英文“Intrusion Detection Systems”的缩写，中文意思是“入侵检测系统”。依照一定的安全策略，通过软、硬件，对网络、系统的运行状况进行监视，尽可能发现各种攻击企图、攻击行为或者攻击结果，以保证网络系统资源的机密性、完整性和可用性。</p>
<p>Barnyard：知名的开源IDS的日志工具，具有快速的响应速度，优异的数据库写入功能，是做自定义的入侵检测系统不可缺少的插件。</p>
<h3 id="1-2-Suricata-入侵检测系统"><a href="#1-2-Suricata-入侵检测系统" class="headerlink" title="1.2 Suricata 入侵检测系统"></a>1.2 Suricata 入侵检测系统</h3><p>随着安全威胁的不断发生，入侵检测系统（IDS）在如今的数据中心环境中显得尤为必要。然而，随着越来越多的服务器将他们的网卡升级到10GB/40GB以太网，对如此线路上的硬件进行计算密集型的入侵检测越来越困难。其中一种提升入侵检测系统性能的途径是多线程入侵检测系统，它将 CPU 密集型的深度包检测工作并行的分配给多个并发任务来完成。这样的并行检测可以充分利用多核硬件的优势来轻松提升入侵检测系统的吞吐量。在这方面有两个知名的开源项目，分别是 Suricata 和 Bro.</p>
<h2 id="二、安装"><a href="#二、安装" class="headerlink" title="二、安装"></a>二、安装</h2><h3 id="2-1-安装命令"><a href="#2-1-安装命令" class="headerlink" title="2.1 安装命令"></a>2.1 安装命令</h3><ol>
<li>需要安装依赖包：<br><code>apt-get -y install libpcre3 libpcre3-dbg libpcre3-dev build-essential autoconf automake libtool libpcap-dev libnet1-dev libyaml-0-2 libyaml-dev zlib1g zlib1g-dev libmagic-dev libcap-ng-dev libjansson-dev pkg-config</code></li>
<li>下载安装包<br><code>wget http://www.openinfosecfoundation.org/download/suricata-2.0.8.tar.gz</code></li>
<li>进入目录后，编译相应模块（对suricata模块进行编译），然后编译安装<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd suricata-2.0.8</span><br><span class="line">./configure --sysconfdir=/etc --localstatedir=/var</span><br><span class="line">make &amp;&amp; make install</span><br></pre></td></tr></table></figure></li>
<li>make install-rules安装IDS规则集，由于下载所读过慢，所以直接查看下载完的规则集：<code>ls /root/apps/rules</code><br><img src="/2020/05/26/%E5%85%A5%E4%BE%B5%E6%A3%80%E6%B5%8B%E5%AE%9E%E9%AA%8C/4.1.jpg" alt></li>
<li>Suricata源代码随带默认的配置文件，不妨安装这些默认的配置文件，结果如图下所示：<br><img src="/2020/05/26/%E5%85%A5%E4%BE%B5%E6%A3%80%E6%B5%8B%E5%AE%9E%E9%AA%8C/4.2.jpg" alt></li>
<li>让系统共享动态链接库<code>ldconfig</code></li>
</ol>
<h3 id="2-2-配置-Suricata-IDS"><a href="#2-2-配置-Suricata-IDS" class="headerlink" title="2.2 配置 Suricata IDS"></a>2.2 配置 Suricata IDS</h3><ol>
<li>打开配置文件查看基本配置信息，结果如图下所示：<br>指令：<code>vi /etc/suricata/suricata.yaml</code><br><img src="/2020/05/26/%E5%85%A5%E4%BE%B5%E6%A3%80%E6%B5%8B%E5%AE%9E%E9%AA%8C/4.3.jpg" alt></li>
<li>为default-log-dir关键字指定 Suricata 日志文件所在的位置，结果如图所示：<br><img src="/2020/05/26/%E5%85%A5%E4%BE%B5%E6%A3%80%E6%B5%8B%E5%AE%9E%E9%AA%8C/4.4.jpg" alt></li>
<li>找到vars部分，配置对Suricata来说重要的变量，结果如图所示：<br><img src="/2020/05/26/%E5%85%A5%E4%BE%B5%E6%A3%80%E6%B5%8B%E5%AE%9E%E9%AA%8C/4.5.jpg" alt></li>
<li>找到threading 部分，你可以为不同的 Suricata 线程指定 CPU 关联，结果如图下所示：<br><img src="/2020/05/26/%E5%85%A5%E4%BE%B5%E6%A3%80%E6%B5%8B%E5%AE%9E%E9%AA%8C/4.6.jpg" alt></li>
</ol>
<h2 id="三、使用"><a href="#三、使用" class="headerlink" title="三、使用"></a>三、使用</h2><ol>
<li>多种模式<br>Suricata 支持许多运行模式。运行模式决定着 IDC 会使用何种线程。以下命令可以查看所有可用的运行模式，结果如图所示：<br>指令：<code>/usr/local/bin/suricata --list-runmodes</code><br><img src="/2020/05/26/%E5%85%A5%E4%BE%B5%E6%A3%80%E6%B5%8B%E5%AE%9E%E9%AA%8C/4.7.jpg" alt></li>
</ol>
<p>2.将主目录suricata-2.0.8/rlues下的tls-events.rules，复制到/etc/suricata/rules下<br>指令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd suricata-2.0.8/rules/</span><br><span class="line">cp tls-events.rules /etc/suricata/rules</span><br></pre></td></tr></table></figure>

<ol start="3">
<li><p>删除rules文件，防止重名，创建目录rules，将下载的规则集也复制到/etc/suricata/rules下。<br>指令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">rm /etc/suricata/rules</span><br><span class="line">mkdir /etc/suricata/rules</span><br><span class="line">cp /root/apps/rules/* /etc/suricata/rules</span><br></pre></td></tr></table></figure></li>
<li><p>再将本身自带的规则也添加到/etc/suricata/rules目录。<br>指令：<code>cp /root/suricata-2.0.8/rules/* /etc/suricata/rules/</code></p>
</li>
<li><p>将 Suricata 运行起来，结果如图所示：<br>指令：<code>/usr/local/bin/suricata -c /etc/suricata/suricata.yaml -i eth0 --init-errors-fatal</code><br><img src="/2020/05/26/%E5%85%A5%E4%BE%B5%E6%A3%80%E6%B5%8B%E5%AE%9E%E9%AA%8C/4.8.jpg" alt></p>
</li>
</ol>
<p><em>注：图中的警告可以忽略，它只是意味着你的网卡不支持LRO。</em></p>
<ol start="6">
<li><p>查看ip地址并创建hongya用户和密码。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ifconfig</span><br><span class="line">useradd hongya</span><br><span class="line">passwd hongya</span><br></pre></td></tr></table></figure>
</li>
<li><p>登录目标机，进行ssh连接操作机。<br>指令：<code>ssh hongya@172.17.0.11</code><br><img src="/2020/05/26/%E5%85%A5%E4%BE%B5%E6%A3%80%E6%B5%8B%E5%AE%9E%E9%AA%8C/4.9.jpg" alt></p>
</li>
<li><p>执行完 按ctrl+c结束 然后vi查看<code>/var/log/suricata/fast.log</code>日志文件，因为suricata检测日志存储在<code>/var/log/suricata</code>目录下，结果如图下所示：<br>指令：<code>vi /var/log/suricata/fast.log</code><br><img src="/2020/05/26/%E5%85%A5%E4%BE%B5%E6%A3%80%E6%B5%8B%E5%AE%9E%E9%AA%8C/4.10.jpg" alt></p>
</li>
</ol>
<h1 id="第五章-安装高级入侵检测环境到centos"><a href="#第五章-安装高级入侵检测环境到centos" class="headerlink" title="第五章 安装高级入侵检测环境到centos"></a>第五章 安装高级入侵检测环境到centos</h1><h2 id="一、简介-1"><a href="#一、简介-1" class="headerlink" title="一、简介"></a>一、简介</h2><p>AIDE的基本功能</p>
<p>对CentOS来说，最流行的入侵检测系统之一就是AIDE。这种系统可以创建数据库，用来核实你机器上文件的完整性。AIDE的主要功能如下：</p>
<blockquote>
<p>支持md5、sha1、rmd160、tiger、crc32、sha256和sha512摘要算法<br>支持这些文件类型：权限、Inode、UID、GID、链接名称、大小、块数量、链接数量、mtime、ctime和atime等文件属性<br>支持这些文件系统属性：Posix ACL、SELinux、XAttrs和Extended<br>支持正则表达式，可以选择性地添加或排除文件/目录<br>支持GZIP数据库压缩</p>
</blockquote>
<h2 id="二、安装-1"><a href="#二、安装-1" class="headerlink" title="二、安装"></a>二、安装</h2><ol>
<li>安装指令：<code>yum install aide</code></li>
<li>初始化：<code>aide --init</code></li>
<li>运行检查，初始化数据库后，它会创建/var/lib/aide/aide.bb.new.gz，执行命令<code>aide --check</code>进行检查，结果如图所示：<br><img src="/2020/05/26/%E5%85%A5%E4%BE%B5%E6%A3%80%E6%B5%8B%E5%AE%9E%E9%AA%8C/5.1.jpg" alt><br>从上图中我们可以看出命令失败了，那是因为，要想使用AIDE来运行检查，数据库必须位于/var/lib/aide/aide.db.gz.。为了解决这个问题，你得使用这个命令更名刚创建的数据库，然后在运行检查结果如图下所示：<br>执行命令：<code>mv /var/lib/aide/aide.db.new.gz /var/lib/aide/aide.db.gz</code><br>再执行：<code>aide --check</code><br><img src="/2020/05/26/%E5%85%A5%E4%BE%B5%E6%A3%80%E6%B5%8B%E5%AE%9E%E9%AA%8C/5.2.jpg" alt></li>
</ol>
<p><em>注：我们这里面的数据库没有修改东西，所以全部文件都匹配，否则会生成一份报告</em></p>
<ol start="4">
<li>不妨测试一下AIDE的准确性。创建假文件/usr/bin/aidetest，结果如图所示：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">touch /usr/bin/aidetest</span><br><span class="line">cd /usr/bin</span><br></pre></td></tr></table></figure>

</li>
</ol>
<p>我们再次运行aide –check进行检查，结果如图下所示：<br><img src="/2020/05/26/%E5%85%A5%E4%BE%B5%E6%A3%80%E6%B5%8B%E5%AE%9E%E9%AA%8C/5.3.jpg" alt></p>
]]></content>
      <tags>
        <tag>攻防</tag>
        <tag>实验</tag>
      </tags>
  </entry>
  <entry>
    <title>linux云计算</title>
    <url>/2020/02/08/linux%E4%BA%91%E8%AE%A1%E7%AE%97/</url>
    <content><![CDATA[<h2 id="一-grep的使用"><a href="#一-grep的使用" class="headerlink" title="一 grep的使用"></a>一 grep的使用</h2><h3 id="1-颜色："><a href="#1-颜色：" class="headerlink" title="1. 颜色："></a>1. 颜色：</h3><figure class="highlight plain"><figcaption><span>--color```会直接高亮，默认不高亮</span></figcaption><table><tr><td class="code"><pre><span class="line">### 2. 普通的正则搜索：</span><br><span class="line">例子：从文件`/etc/passwd`中搜出`root`，并且高亮。</span><br></pre></td></tr></table></figure>
<p>root@debian:~# grep –color ‘root’ /etc/passwd<br>root:x:0:0:root:/root:/bin/bash</p>
<pre><code>其他选项：

|命令|备注|
|-|-|
|-i|忽略大小写|
|-v|搜索不包含该字符串的内容|
|-n|显示符合匹配的行号|
|-o|只显示搜索出来的字符串本身|
|-q|不显示内容，但有返回值：`$?`，若含有，则`$?`为false：1|
|-A -B|A为after，B为before，搜索范围为后几行或者前几行如-A3，前三行|
|-C|又有前又有后|
|-e|或者包括，例如`grep -e &apos;root&apos; -e &apos;bash&apos; /etc/passwd`
|-w|单词，左右为数字或者_下划线，不作为单词|
|-f|搜索-f指令文件中的文件中的字符串|

*注：-q选项可以用这个命令代替：`grep &apos;root&apos; /etc/passwd &amp;&gt; /dev/null`效果一样的。*

### 3. 匹配的其他形式：
* 搜索文件：`ls *ks*` 搜索包含ks正则的文件名
* 搜索内容：`cat -n file.txt |grep ks` 搜索包含ks字符串的内容，并显示行号。
* 配合使用`cut`：cut -d &quot;  &quot; -f5以空格为分隔，选取第五列

### 4. 正则匹配
|符号|备注|
|-|-|</code></pre>]]></content>
  </entry>
  <entry>
    <title>实现python爬虫的简单细节分析</title>
    <url>/2019/12/23/%E5%AE%9E%E7%8E%B0python%E7%88%AC%E8%99%AB%E7%9A%84%E7%AE%80%E5%8D%95%E7%BB%86%E8%8A%82%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<p>实现python爬虫的简单细节分析</p>
<a id="more"></a>
<h2 id="爬虫部分"><a href="#爬虫部分" class="headerlink" title="爬虫部分"></a>爬虫部分</h2><h3 id="1-这肯定得加个User-Agent，不然连不上"><a href="#1-这肯定得加个User-Agent，不然连不上" class="headerlink" title="1. 这肯定得加个User-Agent，不然连不上"></a>1. 这肯定得加个User-Agent，不然连不上</h3><p>这里面可能还要加上cookie，这个有点诡异。你说，有一个值等于 0, 60 ，怎么办？把它变成[]，还是””？？？</p>
<h3 id="2-常规路数，使用bs4"><a href="#2-常规路数，使用bs4" class="headerlink" title="2. 常规路数，使用bs4"></a>2. 常规路数，使用bs4</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">def getHtml(url):</span><br><span class="line">    try:</span><br><span class="line">        r = requests.get(url, headers=&#123;&apos;User-Agent&apos;: &apos;Mozilla/5.0&apos;&#125;)</span><br><span class="line">        r.raise_for_status()</span><br><span class="line">        r.encoding = &quot;utf-8&quot;</span><br><span class="line">        return r.text</span><br><span class="line">    except:</span><br><span class="line">        print(&quot;Failed!!!&quot;)</span><br><span class="line"></span><br><span class="line">url = BASE_URL + str(year) + &apos;.html&apos;</span><br><span class="line">html = getHtml(url)</span><br><span class="line">soup = BeautifulSoup(html, &quot;html.parser&quot;)</span><br></pre></td></tr></table></figure>
<p>然后用find和find_all找到所有相关标签，当然可以指定class=？？？</p>
<h3 id="3-爬取表格"><a href="#3-爬取表格" class="headerlink" title="3. 爬取表格"></a>3. 爬取表格</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">comment_list = soup.find(&apos;table&apos;, attrs=&#123;&apos;class&apos;: &apos;table&apos;&#125;).find_all(&apos;tr&apos;)</span><br><span class="line"></span><br><span class="line">for j in comment_list[1:]:  # tr2[1:]遍历第1列到最后一列，表头为第0列</span><br><span class="line">    td = j.find_all(&apos;td&apos;)  # td表格</span><br><span class="line">    Rate = td[0].get_text().strip()  # 遍历排名</span><br><span class="line">    Country = td[1].get_text().strip()  # 遍历国家</span><br><span class="line">    Area = td[2].get_text().strip()  # 遍历洲</span><br><span class="line">    Num = td[3].get_text().strip()  # 遍历人数</span><br></pre></td></tr></table></figure>
<p>自己看，因为有的会带有列名，注意。</p>
<h3 id="4-正则表达"><a href="#4-正则表达" class="headerlink" title="4. 正则表达"></a>4. 正则表达</h3><p>提取括号内的内容：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">re.findall(r&quot;.*\((.*)\)&quot;, Num)</span><br></pre></td></tr></table></figure>
<p>由于提取之后会变成123,123这样的玩意，所以，将其replace替换</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">tNum = &quot;&quot;.join(re.findall(r&quot;.*\((.*)\)&quot;, Num)).replace(&apos;,&apos;, &apos;&apos;)</span><br></pre></td></tr></table></figure>
<p>好了，这里又将遇到问题：因为有的数据因数字较小，所以不会有()，那么re.findall之后的内容就只有<strong>None</strong>，如果再进行float，将会报错：ValueError。这时我们可以运用异常处理来解决：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">try:</span><br><span class="line">    fNum = float(tNum)</span><br><span class="line">except ValueError:</span><br><span class="line">    fNum = float(Num)</span><br></pre></td></tr></table></figure>

<h3 id="5-字典与列表的基本应用"><a href="#5-字典与列表的基本应用" class="headerlink" title="5. 字典与列表的基本应用"></a>5. 字典与列表的基本应用</h3><p>这里我只用了很少，不管了，先写下来：</p>
<ol>
<li>添加字典：直接dict[yourkey]=？？就可以</li>
<li>添加列表数据：listData.append(youwant)</li>
<li>删除字典：dict.pop(key)</li>
</ol>
<h2 id="数据读写部分"><a href="#数据读写部分" class="headerlink" title="数据读写部分"></a>数据读写部分</h2><p>这里都是对excel表格的操作。</p>
<h3 id="1-读excel"><a href="#1-读excel" class="headerlink" title="1. 读excel"></a>1. 读excel</h3><h4 id="打开文件并且选择相应的sheet"><a href="#打开文件并且选择相应的sheet" class="headerlink" title="打开文件并且选择相应的sheet"></a>打开文件并且选择相应的sheet</h4><p>注意，因为我存的是xls，所以不能用openxls来进行读，而应该用xlrd</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">workbook= xlrd.open_workbook(filepath)</span><br><span class="line">worksheet=workbook.sheet_by_name(&apos;ALLdata&apos;)</span><br></pre></td></tr></table></figure>
<h4 id="获取最大行列数"><a href="#获取最大行列数" class="headerlink" title="获取最大行列数"></a>获取最大行列数</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mrow=worksheet.nrows</span><br><span class="line">mcol=worksheet.ncols</span><br></pre></td></tr></table></figure>

<h4 id="读单元格"><a href="#读单元格" class="headerlink" title="读单元格"></a>读单元格</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">worksheet.cell(row, colum).value</span><br></pre></td></tr></table></figure>

<h3 id="2-写excel"><a href="#2-写excel" class="headerlink" title="2. 写excel"></a>2. 写excel</h3><h4 id="新建"><a href="#新建" class="headerlink" title="新建"></a>新建</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">workbook = xlwt.Workbook()</span><br><span class="line">#添加sheet表</span><br><span class="line">sheet = workbook.add_sheet(&apos;ALLdata&apos;, cell_overwrite_ok=True)</span><br></pre></td></tr></table></figure>
<h4 id="写入"><a href="#写入" class="headerlink" title="写入"></a>写入</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sheet.write(row, col, str(value))</span><br></pre></td></tr></table></figure>
<p>这里value必须是str类型，不然会报错！</p>
<h4 id="保存"><a href="#保存" class="headerlink" title="保存"></a>保存</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">workbook.save(filename)</span><br></pre></td></tr></table></figure>

<h2 id="数据分析部分"><a href="#数据分析部分" class="headerlink" title="数据分析部分"></a>数据分析部分</h2><h3 id="1-数据拟合及预测"><a href="#1-数据拟合及预测" class="headerlink" title="1. 数据拟合及预测"></a>1. 数据拟合及预测</h3><h4 id="拟合函数生成"><a href="#拟合函数生成" class="headerlink" title="拟合函数生成"></a>拟合函数生成</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">f1= np.polyfit(xdata, ydata, 3)</span><br><span class="line">p1 = np.poly1d(f1)</span><br><span class="line">yvals1 = p1(xdata)</span><br></pre></td></tr></table></figure>
<p>注：xdata，ydata是x，y坐标点的系列值，3是曲线拟合次数，此时p1即3次多项式。先把xdata代入p1多项式中，将会生成yvals1相应的值，这个可以作为预测值。</p>
<h4 id="2-图像生成"><a href="#2-图像生成" class="headerlink" title="2. 图像生成"></a>2. 图像生成</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ln1 = plt.plot(xdata, ydata, color=&apos;red&apos;, label=&apos;original values&apos;)</span><br><span class="line">pln1 = plt.plot(xdata, yvals1, color=&apos;blue&apos;, linewidth=2.0, linestyle=&apos;-.&apos;, label=&apos;polyfit  values&apos;)</span><br><span class="line"># yvals1 = p1(xdata)  # 拟合y值</span><br><span class="line">plt.xlabel(&apos;year&apos;)</span><br><span class="line">plt.ylabel(&apos;population&apos;)</span><br><span class="line">plt.legend(loc=4)</span><br><span class="line"># plt.show()</span><br><span class="line">plt.savefig(country+&quot;.png&quot;)</span><br><span class="line">plt.close()</span><br></pre></td></tr></table></figure>
<p>注：</p>
<ol>
<li>ln1是原来的图，那个label是标签（指定这个曲线是啥玩意）</li>
<li>pln1是拟合之后的值，使用拟合之后的yvals1。</li>
<li>linestyle=’-.’是线的类型，有– -. - 空等等</li>
<li>而plt.xlabel是指定x轴是啥</li>
<li>plt.show()展示图像</li>
<li>plt.savefig(filename)保存图像为filename</li>
<li>如果不关闭，那么这些xlabel和ylabel会混杂在一起，所以必须使用plt.close()</li>
</ol>
]]></content>
      <tags>
        <tag>python</tag>
        <tag>爬虫</tag>
        <tag>数据读写</tag>
      </tags>
  </entry>
  <entry>
    <title>UltraEdit的使用及文件类型判定</title>
    <url>/2019/12/02/UltraEdit%E7%9A%84%E4%BD%BF%E7%94%A8%E5%8F%8A%E6%96%87%E4%BB%B6%E7%B1%BB%E5%9E%8B%E5%88%A4%E5%AE%9A/</url>
    <content><![CDATA[<h2 id="实验原理"><a href="#实验原理" class="headerlink" title="实验原理"></a>实验原理</h2><h3 id="1-文件格式定义"><a href="#1-文件格式定义" class="headerlink" title="1. 文件格式定义"></a>1. 文件格式定义</h3><p>　　文件格式（或文件类型）是指电脑为了存储信息而使用的对信息的特殊编码方式，是用于识别内部储存的资料。比如有的储存图片，有的储存程序，有的储存文字信息。<a id="more"></a>每一类信息，都可以一种或多种文件格式保存在电脑存储中。每一种文件格式通常会有一种或多种扩展名可以用来识别，但也可能没有扩展名。扩展名可以帮助应用程序识别的文件格式。对于硬盘机或任何电脑存储来说，有效的信息只有0和1两种。所以电脑必须设计有相应的方式进行信息-位元的转换。对于不同的信息有不同的存储格式。</p>
<h3 id="2-文件格式概述"><a href="#2-文件格式概述" class="headerlink" title="2.文件格式概述"></a>2.文件格式概述</h3><p>　　有些文件格式被设计用于存储特殊的数据，例如：图像文件中的JPEG文件格式仅用于存储静态的图像，而GIF既可以存储静态图像，也可以存储简单动画；Quicktime 格式则可以存储多种不同的媒体类型。文本类的文件有：text文件一般仅存储简单没有格式的ASCII或Unicode的文本；HTML文件则可以存储带有格式的文本；PDF格式则可以存储内容丰富的，图文并茂的文本。<br>　　同一个文件格式，用不同的程序处理可能产生截然不同的结果。例如Word 文件，用Microsoft Word观看的时候，可以看到文本的内容，而以无格式方式在音乐播放软件中播放，产生的则是噪声。一种文件格式对某些软件会产生有意义的结果，对另一些软件来看，就像是毫无用途的数字垃圾。</p>
<h3 id="3-文件格式的规范"><a href="#3-文件格式的规范" class="headerlink" title="3. 文件格式的规范"></a>3. 文件格式的规范</h3><p>　　许多文件格式都有公开的、不同程度规范或者建议的格式。这些规范或者建议描述了数据如何编码，如何排列。有时也规定了是否需要特定的电脑程序读取或处理。有两种情况下，文件格式没有公开。第一种情况是：开发者将文件格式视作商业秘密不愿公开；第二种情况是：开发者不愿或花去很少的时间用于规范文档。<br>　　需要注意的是，使用不公开的文件格式可能会带来额外的成本。要了解这类文件格式或者需要通过对获得的文件进行逆向工程，或者通过向开发者付费来获得文件的格式。第二种方式中往往还需要与开发者签订不扩散协议。不论怎样两种方式都是费时，费钱的。</p>
<h3 id="4-识别文件的类型"><a href="#4-识别文件的类型" class="headerlink" title="4. 识别文件的类型"></a>4. 识别文件的类型</h3><p>　　从程序的角度来看，文件是数据流，文件系统为每一种文件格式规定了访问的方法。例如：元数据。不同的操作系统都习惯性的采用各自的方式解决这个问题，每种方式都有各自的优缺点。<br>    当然，现代的操作系统和应用程序，一般都需要这里所讲述的方法处理不同的文件。</p>
<h3 id="5-扩展名"><a href="#5-扩展名" class="headerlink" title="5. 扩展名"></a>5. 扩展名</h3><p>　　用扩展名识别文件格式的方式最先在数字设备公司的CP/M操作系统被采用。而后又被DOS和Windows操作系统采用。扩展名是指文件名中，最后一个点（.）号后的字母序列。例如，HTML文件通过.htm或.html扩展名识别；GIF图形文件用.gif扩展名识别。在早期的FAT文件系统中，扩展名限制只能是三个字符，因此尽管现在绝大多数的操作系统已不再有此限制，许多文件格式至今仍然采用三个字符作扩展名。因为没有一个正式的扩展名命名标准，所以，有些文件格式可能会采用相同的扩展名，出现这样的情况就会使操作系统错误地识别文件格式，同时也给用户造成困惑。<br>　　扩展名方式的一个特点是，更改文件扩展名会导致系统误判文件格式。例如，将filename.html 简单改名为filename.txt会使系统误将HTML文件识别为纯文本格式。尽管一些熟练的用户可以利用这个特点，但普通用户很容易在改名时发生错误，而使得文件变得无法使用。因此，现代的有些操作系统管理程序，例如Windows Explorer加入了限制向用户显示文件扩展名的功能。</p>
<h3 id="6-特征签名"><a href="#6-特征签名" class="headerlink" title="6. 特征签名"></a>6. 特征签名</h3><p>　　一种广泛应用在UNIX及其派生的操作系统上的方法是将一个特殊的数字存放在文件的特定位置里。最初这个数字一般是文件开始处的2个字节。现在一般是将任何可以独一无二字符序列都可以作为特征签名。例如GIF图形文件是将文件开始处的六个字节作为特征签名的，它可以是GIF87a或者GIF89a。但也有些文件很难通过这种方式识别，比如HTML文件。<br>　　采用这种方式可以更好的防止对文件格式发生误判，并且特征签名可以给出关于文件格式的更详细的信息。这种方式的缺点是效率较低。特别是显示大量的文件时，由于每种特征签名具有不同的识别方式，将消耗系统大量的资源对文件格式进行判断。扩展名和后面将提到的元数据方式由于采用固定格式数据，可进行快速匹配。应用程序往往利用特征签名来判断文件是否完整和有效。</p>
<h2 id="实践操作"><a href="#实践操作" class="headerlink" title="实践操作"></a>实践操作</h2><h3 id="1-操作系统"><a href="#1-操作系统" class="headerlink" title="1.操作系统"></a>1.操作系统</h3><p>　　操作机：Windows_7</p>
<h3 id="2-实验工具"><a href="#2-实验工具" class="headerlink" title="2.实验工具"></a>2.实验工具</h3><p>　　UltraEdit<img src="/2019/12/02/UltraEdit%E7%9A%84%E4%BD%BF%E7%94%A8%E5%8F%8A%E6%96%87%E4%BB%B6%E7%B1%BB%E5%9E%8B%E5%88%A4%E5%AE%9A/1.png" alt><br>　　UltraEdit 是一套功能强大的文本编辑器，可以编辑文本、十六进制、ASCII 码，完全可以取代记事本（如果电脑配置足够强大），内建英文单字检查、C++ 及 VB 指令突显，可同时编辑多个文件，而且即使开启很大的文件速度也不会慢。</p>
<h3 id="步骤1：用UltraEdit工具查看doc和gif文件类型"><a href="#步骤1：用UltraEdit工具查看doc和gif文件类型" class="headerlink" title="步骤1：用UltraEdit工具查看doc和gif文件类型"></a>步骤1：用UltraEdit工具查看doc和gif文件类型</h3><p>1.1 打开目录”D:\1、信息安全\3、信息系统安全\17软件安全课程\1.实验工具（一）文件格式猜测实验”，此文件夹下包含几种不同的文件格式。如图所示:<br><img src="/2019/12/02/UltraEdit%E7%9A%84%E4%BD%BF%E7%94%A8%E5%8F%8A%E6%96%87%E4%BB%B6%E7%B1%BB%E5%9E%8B%E5%88%A4%E5%AE%9A/2.png" alt></p>
<p>1.2 从桌面打开程序UltraEdit,如图所示：<br><img src="/2019/12/02/UltraEdit%E7%9A%84%E4%BD%BF%E7%94%A8%E5%8F%8A%E6%96%87%E4%BB%B6%E7%B1%BB%E5%9E%8B%E5%88%A4%E5%AE%9A/3.png" alt></p>
<p>1.3 点击“文件”-“打开”，打开目录D:\1、信息安全\3、信息系统安全\17软件安全课程\1.实验工具（一）文件格式猜测实验文件夹下的1-1.doc文件。<br><img src="/2019/12/02/UltraEdit%E7%9A%84%E4%BD%BF%E7%94%A8%E5%8F%8A%E6%96%87%E4%BB%B6%E7%B1%BB%E5%9E%8B%E5%88%A4%E5%AE%9A/4.png" alt><br><img src="/2019/12/02/UltraEdit%E7%9A%84%E4%BD%BF%E7%94%A8%E5%8F%8A%E6%96%87%E4%BB%B6%E7%B1%BB%E5%9E%8B%E5%88%A4%E5%AE%9A/5.png" alt></p>
<p>1.4 查看打开的1-1.doc文件,并在“00002730h”行查询此文件的格式标识。如图所示：<br><img src="/2019/12/02/UltraEdit%E7%9A%84%E4%BD%BF%E7%94%A8%E5%8F%8A%E6%96%87%E4%BB%B6%E7%B1%BB%E5%9E%8B%E5%88%A4%E5%AE%9A/6.png" alt><br>在文件中部出现Microsoft Office Word文档说明此文件格式为word文档。</p>
<p>1.5 再次使用UltraEdit软件打开1-2-2.gif文件。如图所示：<br><img src="/2019/12/02/UltraEdit%E7%9A%84%E4%BD%BF%E7%94%A8%E5%8F%8A%E6%96%87%E4%BB%B6%E7%B1%BB%E5%9E%8B%E5%88%A4%E5%AE%9A/7.png" alt></p>
<p>1.6 查看1-2-2.gif的文件格式为GIF。如图所示：<br><img src="/2019/12/02/UltraEdit%E7%9A%84%E4%BD%BF%E7%94%A8%E5%8F%8A%E6%96%87%E4%BB%B6%E7%B1%BB%E5%9E%8B%E5%88%A4%E5%AE%9A/8.png" alt></p>
<p>1.7 继续查看1-2.gif的文件格式，你会发现与1-2-2.gif的文件格式一样。如图：<br><img src="/2019/12/02/UltraEdit%E7%9A%84%E4%BD%BF%E7%94%A8%E5%8F%8A%E6%96%87%E4%BB%B6%E7%B1%BB%E5%9E%8B%E5%88%A4%E5%AE%9A/9.png" alt></p>
<h3 id="步骤2：用UltraEdit工具查看rar和zip压缩包及其包含文件的文件类型"><a href="#步骤2：用UltraEdit工具查看rar和zip压缩包及其包含文件的文件类型" class="headerlink" title="步骤2：用UltraEdit工具查看rar和zip压缩包及其包含文件的文件类型"></a>步骤2：用UltraEdit工具查看rar和zip压缩包及其包含文件的文件类型</h3><p>2.1 回到工具目录D:\1、信息安全\3、信息系统安全\17软件安全课程\1.实验工具（一）文件格式猜测实验文件夹。双击左键打开1-3.rar解压包，可以看到1-1.doc，1-2-2.gif，1-2.gif。如图所示：<br><img src="/2019/12/02/UltraEdit%E7%9A%84%E4%BD%BF%E7%94%A8%E5%8F%8A%E6%96%87%E4%BB%B6%E7%B1%BB%E5%9E%8B%E5%88%A4%E5%AE%9A/10.png" alt></p>
<p>2.2 关闭1-3.rar解压包，使用Uedit32软件打开1-3.rar，可以看到文件格式为Rar，如图所示：<br><img src="/2019/12/02/UltraEdit%E7%9A%84%E4%BD%BF%E7%94%A8%E5%8F%8A%E6%96%87%E4%BB%B6%E7%B1%BB%E5%9E%8B%E5%88%A4%E5%AE%9A/11.png" alt></p>
<p>2.3 我们可以再UltraEdit软件中查找到1-3.rar中包含的格式以及1-3.rar里的文件格式。如图所示：<br><img src="/2019/12/02/UltraEdit%E7%9A%84%E4%BD%BF%E7%94%A8%E5%8F%8A%E6%96%87%E4%BB%B6%E7%B1%BB%E5%9E%8B%E5%88%A4%E5%AE%9A/12.png" alt><br>　<br>2.4 使用UltraEdit打开1-3.zip文件，操作如1-3.rar一样的步骤。<br><img src="/2019/12/02/UltraEdit%E7%9A%84%E4%BD%BF%E7%94%A8%E5%8F%8A%E6%96%87%E4%BB%B6%E7%B1%BB%E5%9E%8B%E5%88%A4%E5%AE%9A/13.png" alt></p>
]]></content>
      <tags>
        <tag>课程</tag>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title>系统常用命令</title>
    <url>/2019/12/01/%E7%B3%BB%E7%BB%9F%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<h2 id="window"><a href="#window" class="headerlink" title="window"></a>window</h2><p>AT 计划在计算机上运行的命令和程序。<br>ATTRIB 显示或更改文件属性。</p>
<a id="more"></a>
<p>BREAK 设置或清除扩展式 CTRL+C 检查。<br>CACLS 显示或修改文件的访问控制列表(ACLs)。<br>CALL 从另一个批处理程序调用这一个。<br>CD 显示当前目录的名称或将其更改。</p>
<p>CHCP 显示或设置活动代码页数。<br>CHDIR 显示当前目录的名称或将其更改。<br>CHKDSK 检查磁盘并显示状态报告。<br>CHKNTFS 显示或修改启动时间磁盘检查。<br>CLS 清除屏幕。<br>CMD 打开另一个 Windows 命令解释程序窗口。<br>COLOR 设置默认控制台前景和背景颜色。<br>COMP 比较两个或两套文件的内容。<br>COMPACT 显示或更改 NTFS 分区上文件的压缩。<br>CONVERT 将 FAT 卷转换成 NTFS。您不能转换当前驱动器。<br>COPY 将至少一个文件复制到另一个位置。<br>DATE 显示或设置日期。</p>
<p>DEL 删除至少一个文件。<br>DIR 显示一个目录中的文件和子目录。<br>DISKCOMP 比较两个软盘的内容。<br>DISKCOPY 将一个软盘的内容复制到另一个软盘。<br>DOSKEY 编辑命令行、调用 Windows 命令并创建宏。<br>ECHO 显示消息，或将命令回显打开或关上。<br>ENDLOCAL 结束批文件中环境更改的本地化。<br>ERASE 删除至少一个文件。<br>EXIT 退出 CMD.EXE 程序(命令解释程序)。<br>FC 比较两个或两套文件，并显示不同处。<br>FIND 在文件中搜索文字字符串。<br>FINDSTR 在文件中搜索字符串。<br>FOR 为一套文件中的每个文件运行一个指定的命令。<br>FORMAT 格式化磁盘，以便跟 Windows 使用。<br>FTYPE 显示或修改用于文件扩展名关联的文件类型。<br>GOTO 将 Windows 命令解释程序指向批处理程序中某个标明的行。<br>GRAFTABL 启用 Windows 来以图像模式显示扩展字符集。<br>HELP 提供 Windows 命令的帮助信息。<br>IF 执行批处理程序中的条件性处理。<br>LABEL 创建、更改或删除磁盘的卷标。<br>MD 创建目录。<br>MKDIR 创建目录。<br>MODE 配置系统设备。<br>MORE 一次显示一个结果屏幕。<br>MOVE 将文件从一个目录移到另一个目录。<br>PATH 显示或设置可执行文件的搜索路径。<br>PAUSE 暂停批文件的处理并显示消息。<br>POPD 还原 PUSHD 保存的当前目录的上一个值。<br>PRINT 打印文本文件。<br>PROMPT 更改 Windows 命令提示符。<br>PUSHD 保存当前目录，然后对其进行更改。<br>RD 删除目录。<br>RECOVER 从有问题的磁盘恢复可读信息。<br>REM 记录批文件或 CONFIG.SYS 中的注释。<br>REN 重命名文件。<br>RENAME 重命名文件。<br>REPLACE 替换文件。<br>RMDIR 删除目录。<br>SET 显示、设置或删除 Windows 环境变量。<br>SETLOCAL 开始批文件中环境更改的本地化。<br>SHIFT 更换批文件中可替换参数的位置。<br>SORT 对输入进行分类。<br>START 启动另一个窗口来运行指定的程序或命令。<br>SUBST 将路径跟一个驱动器号关联。<br>TIME 显示或设置系统时间。<br>TITLE 设置 CMD.EXE 会话的窗口标题。<br>TREE 以图形模式显示驱动器或路径的目录结构。<br>TYPE 显示文本文件的内容。<br>VER 显示 Windows 版本。<br>VERIFY 告诉 Windows 是否验证文件是否已正确写入磁盘。<br>VOL 显示磁盘卷标和序列号。<br>XCOPY 复制文件和目录树。<br>appwiz.cpl————添加删除程序<br>control userpasswords2——–用户帐户设置<br>cleanmgr——-垃圾整理<br>CMD————–命令提示符可以当作是 Windows 的一个附件，Ping，Convert 这些不能在图形环境下 使用的功能要借助它来完成。<br>cmd——jview察看Java虚拟机版本。<br>command.com——调用的则是系统内置的 NTVDM，一个 DOS虚拟机。它完全是一个类似 Virtual PC 的 虚拟环境，和系统本身联系不大。<br>    当我们在命令提示符下运行 DOS 程序时，实际上也 是自动转移到 NTVDM虚拟机下，和 CMD 本身没什么关系。<br>calc———–启动计算器<br>chkdsk.exe—–Chkdsk磁盘检查<br>compmgmt.msc—计算机管理<br>conf———–启动 netmeeting<br>control userpasswords2—–User Account 权限设置<br>devmgmt.msc— 设备管理器<br>diskmgmt.msc—磁盘管理实用程序<br>dfrg.msc——-磁盘碎片整理程序<br>drwtsn32—— 系统医生<br>dvdplay——–启动Media Player<br>dxdiag———–DirectX Diagnostic Tool<br>gpedit.msc——-组策略编辑器<br>gpupdate /target:computer /force 强制刷新组策略<br>eventvwr.exe—–事件查看器<br>explorer——-打开资源管理器<br>logoff———注销命令<br>lusrmgr.msc—-本机用户和组<br>msinfo32———系统信息<br>msconfig———系统配置实用程序<br>net start (servicename)—-启动该服务<br>net stop (servicename)—–停止该服务<br>notepad——–打开记事本<br>nusrmgr.cpl——-同control userpasswords，打开用户帐户控制面板<br>Nslookup——-IP地址侦测器<br>oobe/msoobe /a—-检查XP是否激活<br>perfmon.msc—-计算机性能监测程序<br>progman——–程序管理器<br>regedit———-注册表编辑器<br>regedt32——-注册表编辑器<br>regsvr32 /u *.dll—-停止dll文件运行<br>route print——查看路由表<br>rononce -p —-15秒关机<br>rsop.msc——-组策略结果集<br>rundll32.exe rundll32.exe %Systemroot%System32shimgvw.dll,ImageView_Fullscreen—-启动一个空白的Windows 图片和传真查看器<br>secpol.msc——–本地安全策略<br>services.msc—本地服务设置<br>sfc /scannow—–启动系统文件检查器<br>sndrec32——-录音机<br>taskmgr—–任务管理器（适用于2000／xp／2003）<br>tsshutdn——-60秒倒计时关机命令<br>winchat——–XP自带局域网聊天<br>winmsd———系统信息<br>winver—–显示About Windows 窗口<br>wupdmgr———–Windows Update</p>
<p>‘;update dv_user set usergroupid=1 where username=’san’–</p>
]]></content>
      <tags>
        <tag>汇总</tag>
      </tags>
  </entry>
  <entry>
    <title>渗透相关资料汇总</title>
    <url>/2019/12/01/%E6%B8%97%E9%80%8F%E7%9B%B8%E5%85%B3%E8%B5%84%E6%96%99%E6%B1%87%E6%80%BB/</url>
    <content><![CDATA[<h1 id="渗透相关资料汇总"><a href="#渗透相关资料汇总" class="headerlink" title="渗透相关资料汇总"></a>渗透相关资料汇总</h1><a id="more"></a>
<h2 id="漏洞及渗透练习平台"><a href="#漏洞及渗透练习平台" class="headerlink" title="漏洞及渗透练习平台"></a>漏洞及渗透练习平台</h2><h3 id="WebGoat漏洞练习环境"><a href="#WebGoat漏洞练习环境" class="headerlink" title="WebGoat漏洞练习环境"></a>WebGoat漏洞练习环境</h3><p><a href="https://github.com/WebGoat/WebGoat" target="_blank" rel="noopener">https://github.com/WebGoat/WebGoat</a><br><a href="https://github.com/WebGoat/WebGoat-Legacy" target="_blank" rel="noopener">https://github.com/WebGoat/WebGoat-Legacy</a><br>Damn Vulnerable Web Application(漏洞练习平台)<br><a href="https://github.com/RandomStorm/DVWA" target="_blank" rel="noopener">https://github.com/RandomStorm/DVWA</a></p>
<h3 id="数据库注入练习平台"><a href="#数据库注入练习平台" class="headerlink" title="数据库注入练习平台"></a>数据库注入练习平台</h3><p><a href="https://github.com/Audi-1/sqli-labs" target="_blank" rel="noopener">https://github.com/Audi-1/sqli-labs</a><br>用node编写的漏洞练习平台，like OWASP Node Goat<br><a href="https://github.com/cr0hn/vulnerable-node" target="_blank" rel="noopener">https://github.com/cr0hn/vulnerable-node</a></p>
<h2 id="花式扫描器"><a href="#花式扫描器" class="headerlink" title="花式扫描器"></a>花式扫描器</h2><ol>
<li>端口扫描器Nmap<br><a href="https://github.com/nmap/nmap" target="_blank" rel="noopener">https://github.com/nmap/nmap</a></li>
<li>本地网络扫描器<br><a href="https://github.com/SkyLined/LocalNetworkScanner" target="_blank" rel="noopener">https://github.com/SkyLined/LocalNetworkScanner</a></li>
<li>子域名扫描器<br><a href="https://github.com/lijiejie/subDomainsBrute" target="_blank" rel="noopener">https://github.com/lijiejie/subDomainsBrute</a></li>
<li>漏洞路由扫描器<br><a href="https://github.com/jh00nbr/Routerhunter-2.0" target="_blank" rel="noopener">https://github.com/jh00nbr/Routerhunter-2.0</a></li>
<li>迷你批量信息泄漏扫描脚本<br><a href="https://github.com/lijiejie/BBScan" target="_blank" rel="noopener">https://github.com/lijiejie/BBScan</a></li>
<li>Waf类型检测工具<br><a href="https://github.com/EnableSecurity/wafw00f" target="_blank" rel="noopener">https://github.com/EnableSecurity/wafw00f</a></li>
</ol>
<h2 id="信息搜集工具"><a href="#信息搜集工具" class="headerlink" title="信息搜集工具"></a>信息搜集工具</h2><p>社工插件，可查找以email、phone、username的注册的所有网站账号信息<br><a href="https://github.com/n0tr00t/Sreg" target="_blank" rel="noopener">https://github.com/n0tr00t/Sreg</a><br>Github信息搜集，可实时扫描查询git最新上传有关邮箱账号密码信息<br><a href="https://github.com/sea-god/gitscan" target="_blank" rel="noopener">https://github.com/sea-god/gitscan</a><br>github Repo信息搜集工具<br><a href="https://github.com/metac0rtex/GitHarvester" target="_blank" rel="noopener">https://github.com/metac0rtex/GitHarvester</a></p>
<h2 id="WEB工具"><a href="#WEB工具" class="headerlink" title="WEB工具"></a>WEB工具</h2><ol>
<li>webshell大合集<br><a href="https://github.com/tennc/webshell" target="_blank" rel="noopener">https://github.com/tennc/webshell</a></li>
<li>渗透以及web攻击脚本<br><a href="https://github.com/brianwrf/hackUtils" target="_blank" rel="noopener">https://github.com/brianwrf/hackUtils</a></li>
<li>web渗透小工具大合集<br><a href="https://github.com/rootphantomer/hacktoolsfor_me" target="_blank" rel="noopener">https://github.com/rootphantomer/hacktoolsfor_me</a></li>
<li>XSS数据接收平台<br><a href="https://github.com/firesunCN/BlueLotus_XSSReceiver" target="_blank" rel="noopener">https://github.com/firesunCN/BlueLotus_XSSReceiver</a></li>
<li>XSS与CSRF工具<br><a href="https://github.com/evilcos/xssor" target="_blank" rel="noopener">https://github.com/evilcos/xssor</a></li>
<li>Short for command injection exploiter，web向命令注入检测工具<br><a href="https://github.com/stasinopoulos/commix" target="_blank" rel="noopener">https://github.com/stasinopoulos/commix</a></li>
<li>数据库注入工具<br><a href="https://github.com/sqlmapproject/sqlmap" target="_blank" rel="noopener">https://github.com/sqlmapproject/sqlmap</a></li>
<li>Web代理，通过加载sqlmap api进行sqli实时检测<br><a href="https://github.com/zt2/sqli-hunter" target="_blank" rel="noopener">https://github.com/zt2/sqli-hunter</a></li>
<li>新版中国菜刀<br><a href="https://github.com/Chora10/Cknife" target="_blank" rel="noopener">https://github.com/Chora10/Cknife</a></li>
<li>.git泄露利用EXP<br><a href="https://github.com/lijiejie/GitHack" target="_blank" rel="noopener">https://github.com/lijiejie/GitHack</a></li>
<li>浏览器攻击框架<br><a href="https://github.com/beefproject/beef" target="_blank" rel="noopener">https://github.com/beefproject/beef</a></li>
<li>自动化绕过WAF脚本<br><a href="https://github.com/khalilbijjou/WAFNinja" target="_blank" rel="noopener">https://github.com/khalilbijjou/WAFNinja</a></li>
<li>http命令行客户端，可以从命令行构造发送各种http请求（类似于Curl）<br><a href="https://github.com/jkbrzt/httpie" target="_blank" rel="noopener">https://github.com/jkbrzt/httpie</a></li>
<li>浏览器调试利器<br><a href="https://github.com/firebug/firebug" target="_blank" rel="noopener">https://github.com/firebug/firebug</a></li>
<li>一款开源WAF<br><a href="https://github.com/SpiderLabs/ModSecurity" target="_blank" rel="noopener">https://github.com/SpiderLabs/ModSecurity</a></li>
</ol>
<h2 id="windows域渗透工具"><a href="#windows域渗透工具" class="headerlink" title="windows域渗透工具"></a>windows域渗透工具</h2><ol>
<li>windows渗透神器<br><a href="https://github.com/gentilkiwi/mimikatz" target="_blank" rel="noopener">https://github.com/gentilkiwi/mimikatz</a></li>
<li>Powershell渗透库合集<br><a href="https://github.com/PowerShellMafia/PowerSploit" target="_blank" rel="noopener">https://github.com/PowerShellMafia/PowerSploit</a></li>
<li>Powershell tools合集<br><a href="https://github.com/clymb3r/PowerShell" target="_blank" rel="noopener">https://github.com/clymb3r/PowerShell</a></li>
</ol>
<h2 id="Fuzz"><a href="#Fuzz" class="headerlink" title="Fuzz"></a>Fuzz</h2><ol>
<li>Web向Fuzz工具<br><a href="https://github.com/xmendez/wfuzz" target="_blank" rel="noopener">https://github.com/xmendez/wfuzz</a></li>
<li>HTTP暴力破解，撞库攻击脚本<br><a href="https://github.com/lijiejie/htpwdScan" target="_blank" rel="noopener">https://github.com/lijiejie/htpwdScan</a></li>
</ol>
<h2 id="漏洞利用及攻击框架"><a href="#漏洞利用及攻击框架" class="headerlink" title="漏洞利用及攻击框架"></a>漏洞利用及攻击框架</h2><ol>
<li>msf<br><a href="https://github.com/rapid7/metasploit-framework" target="_blank" rel="noopener">https://github.com/rapid7/metasploit-framework</a></li>
<li>Poc调用框架，可加载Pocsuite,Tangscan，Beebeeto等<br><a href="https://github.com/erevus-cn/pocscan" target="_blank" rel="noopener">https://github.com/erevus-cn/pocscan</a></li>
<li>Pocsuite<br><a href="https://github.com/knownsec/Pocsuite" target="_blank" rel="noopener">https://github.com/knownsec/Pocsuite</a></li>
<li>Beebeeto<br><a href="https://github.com/n0tr00t/Beebeeto-framework" target="_blank" rel="noopener">https://github.com/n0tr00t/Beebeeto-framework</a></li>
</ol>
<h2 id="漏洞POC-amp-EXP"><a href="#漏洞POC-amp-EXP" class="headerlink" title="漏洞POC&amp;EXP"></a>漏洞POC&amp;EXP</h2><ol>
<li>ExploitDB官方git版本<br><a href="https://github.com/offensive-security/exploit-database" target="_blank" rel="noopener">https://github.com/offensive-security/exploit-database</a></li>
<li>php漏洞代码分析<br><a href="https://github.com/80vul/phpcodz" target="_blank" rel="noopener">https://github.com/80vul/phpcodz</a></li>
<li>Simple test for CVE-2016-2107<br><a href="https://github.com/FiloSottile/CVE-2016-2107" target="_blank" rel="noopener">https://github.com/FiloSottile/CVE-2016-2107</a></li>
<li>CVE-2015-7547 POC<br><a href="https://github.com/fjserna/CVE-2015-7547" target="_blank" rel="noopener">https://github.com/fjserna/CVE-2015-7547</a></li>
<li>JAVA反序列化POC生成工具<br><a href="https://github.com/frohoff/ysoserial" target="_blank" rel="noopener">https://github.com/frohoff/ysoserial</a></li>
<li>JAVA反序列化EXP<br><a href="https://github.com/foxglovesec/JavaUnserializeExploits" target="_blank" rel="noopener">https://github.com/foxglovesec/JavaUnserializeExploits</a></li>
<li>Jenkins CommonCollections EXP<br><a href="https://github.com/CaledoniaProject/jenkins-cli-exploit" target="_blank" rel="noopener">https://github.com/CaledoniaProject/jenkins-cli-exploit</a></li>
<li>CVE-2015-2426 EXP (windows内核提权)<br><a href="https://github.com/vlad902/hacking-team-windows-kernel-lpe" target="_blank" rel="noopener">https://github.com/vlad902/hacking-team-windows-kernel-lpe</a></li>
<li>use docker to show web attack(php本地文件包含结合phpinfo getshell 以及ssrf结合curl的利用演示)<br><a href="https://github.com/hxer/vulnapp" target="_blank" rel="noopener">https://github.com/hxer/vulnapp</a></li>
<li>php7缓存覆写漏洞Demo及相关工具<br><a href="https://github.com/GoSecure/php7-opcache-override" target="_blank" rel="noopener">https://github.com/GoSecure/php7-opcache-override</a></li>
<li>XcodeGhost木马样本<br><a href="https://github.com/XcodeGhostSource/XcodeGhost" target="_blank" rel="noopener">https://github.com/XcodeGhostSource/XcodeGhost</a></li>
</ol>
<h2 id="中间人攻击及钓鱼"><a href="#中间人攻击及钓鱼" class="headerlink" title="中间人攻击及钓鱼"></a>中间人攻击及钓鱼</h2><p>中间人攻击框架<br><a href="https://github.com/secretsquirrel/the-backdoor-factory" target="_blank" rel="noopener">https://github.com/secretsquirrel/the-backdoor-factory</a><br><a href="https://github.com/secretsquirrel/BDFProxy" target="_blank" rel="noopener">https://github.com/secretsquirrel/BDFProxy</a><br><a href="https://github.com/byt3bl33d3r/MITMf" target="_blank" rel="noopener">https://github.com/byt3bl33d3r/MITMf</a><br>Inject code, jam wifi, and spy on wifi users<br><a href="https://github.com/DanMcInerney/LANs.py" target="_blank" rel="noopener">https://github.com/DanMcInerney/LANs.py</a><br>可扩展的中间人代理工具<br><a href="https://github.com/intrepidusgroup/mallory" target="_blank" rel="noopener">https://github.com/intrepidusgroup/mallory</a><br>wifi钓鱼<br><a href="https://github.com/sophron/wifiphisher" target="_blank" rel="noopener">https://github.com/sophron/wifiphisher</a></p>
<h2 id="密码破解"><a href="#密码破解" class="headerlink" title="密码破解"></a>密码破解</h2><p>密码破解工具<br><a href="https://github.com/shinnok/johnny" target="_blank" rel="noopener">https://github.com/shinnok/johnny</a><br>本地存储的各类密码提取利器<br><a href="https://github.com/AlessandroZ/LaZagne" target="_blank" rel="noopener">https://github.com/AlessandroZ/LaZagne</a></p>
<h2 id="二进制及代码分析工具"><a href="#二进制及代码分析工具" class="headerlink" title="二进制及代码分析工具"></a>二进制及代码分析工具</h2><p>二进制分析工具<br><a href="https://github.com/devttys0/binwalk" target="_blank" rel="noopener">https://github.com/devttys0/binwalk</a><br>系统扫描器，用于寻找程序和库然后收集他们的依赖关系，链接等信息<br><a href="https://github.com/quarkslab/binmap" target="_blank" rel="noopener">https://github.com/quarkslab/binmap</a><br>rp++ is a full-cpp written tool that aims to find ROP sequences in PE/Elf/Mach-O (doesn’t support the FAT binaries) x86/x64 binaries.<br><a href="https://github.com/0vercl0k/rp" target="_blank" rel="noopener">https://github.com/0vercl0k/rp</a><br>Windows Exploit Development工具<br><a href="https://github.com/lillypad/badger" target="_blank" rel="noopener">https://github.com/lillypad/badger</a><br>二进制静态分析工具（python）<br><a href="https://github.com/bdcht/amoco" target="_blank" rel="noopener">https://github.com/bdcht/amoco</a><br>Python Exploit Development Assistance for GDB<br><a href="https://github.com/longld/peda" target="_blank" rel="noopener">https://github.com/longld/peda</a><br>对BillGates Linux Botnet系木马活动的监控工具<br><a href="https://github.com/ValdikSS/billgates-botnet-tracker" target="_blank" rel="noopener">https://github.com/ValdikSS/billgates-botnet-tracker</a><br>木马配置参数提取工具<br><a href="https://github.com/kevthehermit/RATDecoders" target="_blank" rel="noopener">https://github.com/kevthehermit/RATDecoders</a><br>Shellphish编写的二进制分析工具（CTF向）<br><a href="https://github.com/angr/angr" target="_blank" rel="noopener">https://github.com/angr/angr</a><br>针对python的静态代码分析工具<br><a href="https://github.com/yinwang0/pysonar2" target="_blank" rel="noopener">https://github.com/yinwang0/pysonar2</a><br>一个自动化的脚本（shell）分析工具，用来给出警告和建议<br><a href="https://github.com/koalaman/shellcheck" target="_blank" rel="noopener">https://github.com/koalaman/shellcheck</a><br>基于AST变换的简易Javascript反混淆辅助工具<br><a href="https://github.com/ChiChou/etacsufbo" target="_blank" rel="noopener">https://github.com/ChiChou/etacsufbo</a></p>
<h2 id="EXP编写框架及工具"><a href="#EXP编写框架及工具" class="headerlink" title="EXP编写框架及工具"></a>EXP编写框架及工具</h2><p>二进制EXP编写工具<br><a href="https://github.com/t00sh/rop-tool" target="_blank" rel="noopener">https://github.com/t00sh/rop-tool</a><br>CTF Pwn 类题目脚本编写框架<br><a href="https://github.com/Gallopsled/pwntools" target="_blank" rel="noopener">https://github.com/Gallopsled/pwntools</a><br>an easy-to-use io library for pwning development<br><a href="https://github.com/zTrix/zio" target="_blank" rel="noopener">https://github.com/zTrix/zio</a><br>跨平台注入工具（ Inject JavaScript to explore native apps on Windows, Mac, Linux, iOS and Android.）<br><a href="https://github.com/frida/frida" target="_blank" rel="noopener">https://github.com/frida/frida</a></p>
<h2 id="隐写相关工具"><a href="#隐写相关工具" class="headerlink" title="隐写相关工具"></a>隐写相关工具</h2><p>隐写检测工具<br><a href="https://github.com/abeluck/stegdetect" target="_blank" rel="noopener">https://github.com/abeluck/stegdetect</a></p>
<h2 id="各类安全资料"><a href="#各类安全资料" class="headerlink" title="各类安全资料"></a>各类安全资料</h2><p>域渗透教程<br><a href="https://github.com/l3m0n/pentest_study" target="_blank" rel="noopener">https://github.com/l3m0n/pentest_study</a><br>python security教程（原文链接<a href="http://www.primalsecurity.net/tutorials/python-tutorials/）" target="_blank" rel="noopener">http://www.primalsecurity.net/tutorials/python-tutorials/）</a><br><a href="https://github.com/smartFlash/pySecurity" target="_blank" rel="noopener">https://github.com/smartFlash/pySecurity</a><br>data_hacking合集<br><a href="https://github.com/ClickSecurity/data_hacking" target="_blank" rel="noopener">https://github.com/ClickSecurity/data_hacking</a><br>mobile-security-wiki<br><a href="https://github.com/exploitprotocol/mobile-security-wiki" target="_blank" rel="noopener">https://github.com/exploitprotocol/mobile-security-wiki</a><br>书籍《reverse-engineering-for-beginners》<br><a href="https://github.com/veficos/reverse-engineering-for-beginners" target="_blank" rel="noopener">https://github.com/veficos/reverse-engineering-for-beginners</a><br>一些信息安全标准及设备配置<br><a href="https://github.com/luyg24/IT_security" target="_blank" rel="noopener">https://github.com/luyg24/IT_security</a><br>APT相关笔记<br><a href="https://github.com/kbandla/APTnotes" target="_blank" rel="noopener">https://github.com/kbandla/APTnotes</a><br>Kcon资料<br><a href="https://github.com/knownsec/KCon" target="_blank" rel="noopener">https://github.com/knownsec/KCon</a><br>ctf及黑客资源合集<br><a href="https://github.com/bt3gl/My-Gray-Hacker-Resources" target="_blank" rel="noopener">https://github.com/bt3gl/My-Gray-Hacker-Resources</a><br>ctf和安全工具大合集<br><a href="https://github.com/zardus/ctf-tools" target="_blank" rel="noopener">https://github.com/zardus/ctf-tools</a><br>《DO NOT FUCK WITH A HACKER》<br><a href="https://github.com/citypw/DNFWAH" target="_blank" rel="noopener">https://github.com/citypw/DNFWAH</a></p>
<h2 id="各类CTF资源"><a href="#各类CTF资源" class="headerlink" title="各类CTF资源"></a>各类CTF资源</h2><p>近年ctf writeup大全<br><a href="https://github.com/ctfs/write-ups-2016" target="_blank" rel="noopener">https://github.com/ctfs/write-ups-2016</a><br><a href="https://github.com/ctfs/write-ups-2015" target="_blank" rel="noopener">https://github.com/ctfs/write-ups-2015</a><br><a href="https://github.com/ctfs/write-ups-2014" target="_blank" rel="noopener">https://github.com/ctfs/write-ups-2014</a><br>fbctf竞赛平台Demo<br><a href="https://github.com/facebook/fbctf" target="_blank" rel="noopener">https://github.com/facebook/fbctf</a><br>ctf Resources<br><a href="https://github.com/ctfs/resources" target="_blank" rel="noopener">https://github.com/ctfs/resources</a></p>
<h2 id="各类编程资源"><a href="#各类编程资源" class="headerlink" title="各类编程资源"></a>各类编程资源</h2><p>大礼包（什么都有）<br><a href="https://github.com/bayandin/awesome-awesomeness" target="_blank" rel="noopener">https://github.com/bayandin/awesome-awesomeness</a><br>bash-handbook<br><a href="https://github.com/denysdovhan/bash-handbook" target="_blank" rel="noopener">https://github.com/denysdovhan/bash-handbook</a></p>
<h2 id="python资源大全"><a href="#python资源大全" class="headerlink" title="python资源大全"></a>python资源大全</h2><p><a href="https://github.com/jobbole/awesome-python-cn" target="_blank" rel="noopener">https://github.com/jobbole/awesome-python-cn</a><br>git学习资料<br><a href="https://github.com/xirong/my-git" target="_blank" rel="noopener">https://github.com/xirong/my-git</a><br>安卓开源代码解析<br><a href="https://github.com/android-cn/android-open-project-analysis" target="_blank" rel="noopener">https://github.com/android-cn/android-open-project-analysis</a><br>python框架，库，资源大合集<br><a href="https://github.com/vinta/awesome-python" target="_blank" rel="noopener">https://github.com/vinta/awesome-python</a><br>JS 正则表达式库（用于简化构造复杂的JS正则表达式）<br><a href="https://github.com/VerbalExpressions/JSVerbalExpressions" target="_blank" rel="noopener">https://github.com/VerbalExpressions/JSVerbalExpressions</a><br>Python<br>python 正则表达式库（用于简化构造复杂的python正则表达式）<br><a href="https://github.com/VerbalExpressions/PythonVerbalExpressions" target="_blank" rel="noopener">https://github.com/VerbalExpressions/PythonVerbalExpressions</a><br>python任务管理以及命令执行库<br><a href="https://github.com/pyinvoke/invoke" target="_blank" rel="noopener">https://github.com/pyinvoke/invoke</a><br>python exe打包库<br><a href="https://github.com/pyinstaller/pyinstaller" target="_blank" rel="noopener">https://github.com/pyinstaller/pyinstaller</a><br>py3 爬虫框架<br><a href="https://github.com/orf/cyborg" target="_blank" rel="noopener">https://github.com/orf/cyborg</a><br>一个提供底层接口数据包编程和网络协议支持的python库<br><a href="https://github.com/CoreSecurity/impacket" target="_blank" rel="noopener">https://github.com/CoreSecurity/impacket</a><br>python requests 库<br><a href="https://github.com/kennethreitz/requests" target="_blank" rel="noopener">https://github.com/kennethreitz/requests</a><br>python 实用工具合集<br><a href="https://github.com/mahmoud/boltons" target="_blank" rel="noopener">https://github.com/mahmoud/boltons</a><br>python爬虫系统<br><a href="https://github.com/binux/pyspider" target="_blank" rel="noopener">https://github.com/binux/pyspider</a><br>ctf向 python工具包<br><a href="https://github.com/P1kachu/v0lt" target="_blank" rel="noopener">https://github.com/P1kachu/v0lt</a></p>
<h2 id="科学上网"><a href="#科学上网" class="headerlink" title="科学上网"></a>科学上网</h2><p>科学上网工具<br><a href="https://github.com/XX-net/XX-Net" target="_blank" rel="noopener">https://github.com/XX-net/XX-Net</a><br>老司机福利<br>微信自动抢红包动态库<br><a href="https://github.com/east520/AutoGetRedEnv" target="_blank" rel="noopener">https://github.com/east520/AutoGetRedEnv</a><br>微信抢红包插件（安卓版）<br><a href="https://github.com/geeeeeeeeek/WeChatLuckyMoney" target="_blank" rel="noopener">https://github.com/geeeeeeeeek/WeChatLuckyMoney</a><br>神器<br><a href="https://github.com/yangyangwithgnu/hardseed" target="_blank" rel="noopener">https://github.com/yangyangwithgnu/hardseed</a></p>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>以下内容来自：<a href="https://github.com/We5ter/Scanners-Box/blob/master/README_CN.md" target="_blank" rel="noopener">https://github.com/We5ter/Scanners-Box/blob/master/README_CN.md</a> 子域名枚举类<br><a href="https://github.com/lijiejie/subDomainsBrute" target="_blank" rel="noopener">https://github.com/lijiejie/subDomainsBrute</a> (经典的子域名爆破枚举脚本)<br><a href="https://github.com/ring04h/wydomain" target="_blank" rel="noopener">https://github.com/ring04h/wydomain</a> (子域名字典穷举)<br><a href="https://github.com/le4f/dnsmaper" target="_blank" rel="noopener">https://github.com/le4f/dnsmaper</a> (子域名枚举与地图标记)<br><a href="https://github.com/0xbug/orangescan" target="_blank" rel="noopener">https://github.com/0xbug/orangescan</a> (在线子域名信息收集工具)<br><a href="https://github.com/TheRook/subbrute" target="_blank" rel="noopener">https://github.com/TheRook/subbrute</a> （根据DNS记录查询子域名)<br><a href="https://github.com/We5ter/GoogleSSLdomainFinder" target="_blank" rel="noopener">https://github.com/We5ter/GoogleSSLdomainFinder</a> (基于谷歌SSL透明证书的子域名查询脚本)<br><a href="https://github.com/mandatoryprogrammer/cloudflare_enum" target="_blank" rel="noopener">https://github.com/mandatoryprogrammer/cloudflare_enum</a> （使用CloudFlare进行子域名枚举的脚本）<br><a href="https://github.com/18F/domain-scan" target="_blank" rel="noopener">https://github.com/18F/domain-scan</a> (A domain scanner）<br><a href="https://github.com/Evi1CLAY/Cool" target="_blank" rel="noopener">https://github.com/Evi1CLAY/Cool</a> … Python/DomainSeeker（多方式收集目标子域名信息）<br>数据库漏洞扫描类<br><a href="https://github.com/0xbug/SQLiScanner" target="_blank" rel="noopener">https://github.com/0xbug/SQLiScanner</a> (一款基于SQLMAP和Charles的被动SQL注入漏洞扫描工具)<br><a href="https://github.com/stamparm/DSSS" target="_blank" rel="noopener">https://github.com/stamparm/DSSS</a> (99行代码实现的sql注入漏洞扫描器)<br><a href="https://github.com/LoRexxar/Feigong（针对各种情况自由变化的MySQL注入脚本）" target="_blank" rel="noopener">https://github.com/LoRexxar/Feigong（针对各种情况自由变化的MySQL注入脚本）</a><br><a href="https://github.com/youngyangyang04/NoSQLAttack" target="_blank" rel="noopener">https://github.com/youngyangyang04/NoSQLAttack</a> (一款针对mongoDB的攻击工具)<br><a href="https://github.com/Neohapsis/bbqsql（SQL盲注利用框架）" target="_blank" rel="noopener">https://github.com/Neohapsis/bbqsql（SQL盲注利用框架）</a><br><a href="https://github.com/NetSPI/PowerUpSQL（攻击SQLSERVER的Powershell脚本框架）" target="_blank" rel="noopener">https://github.com/NetSPI/PowerUpSQL（攻击SQLSERVER的Powershell脚本框架）</a><br>弱口令或信息泄漏扫描类<br><a href="https://github.com/lijiejie/htpwdScan" target="_blank" rel="noopener">https://github.com/lijiejie/htpwdScan</a> (一个简单的HTTP暴力破解、撞库攻击脚本)<br><a href="https://github.com/lijiejie/BBScan" target="_blank" rel="noopener">https://github.com/lijiejie/BBScan</a> (一个迷你的信息泄漏批量扫描脚本)<br><a href="https://github.com/lijiejie/GitHack" target="_blank" rel="noopener">https://github.com/lijiejie/GitHack</a> (.git文件夹泄漏利用工具)<br><a href="https://github.com/wilson9x1/fenghuangscanner_v3" target="_blank" rel="noopener">https://github.com/wilson9x1/fenghuangscanner_v3</a> (端口及弱口令检测)<br><a href="https://github.com/ysrc/F-Scrack" target="_blank" rel="noopener">https://github.com/ysrc/F-Scrack</a> (对各类服务进行弱口令检测的脚本)<br><a href="https://github.com/Mebus/cupp" target="_blank" rel="noopener">https://github.com/Mebus/cupp</a> （根据用户习惯生成弱口令探测字典脚本）<br><a href="https://github.com/RicterZ/genpAss" target="_blank" rel="noopener">https://github.com/RicterZ/genpAss</a> （中国特色的弱口令生成器）<br><a href="https://github.com/netxfly/crack_ssh" target="_blank" rel="noopener">https://github.com/netxfly/crack_ssh</a> （go写的协程版的ssh\redis\mongodb弱口令破解工具）<br>物联网设备扫描<br><a href="https://github.com/rapid7/IoTSeeker" target="_blank" rel="noopener">https://github.com/rapid7/IoTSeeker</a> （物联网设备默认密码扫描检测工具)<br><a href="https://github.com/shodan-labs/iotdb" target="_blank" rel="noopener">https://github.com/shodan-labs/iotdb</a> (使用nmap扫描IoT设备)<br>xss扫描器<br><a href="https://github.com/shawarkhanethicalhacker/BruteXSS" target="_blank" rel="noopener">https://github.com/shawarkhanethicalhacker/BruteXSS</a> （Cross-Site Scripting Bruteforcer）<br><a href="https://github.com/1N3/XSSTracer" target="_blank" rel="noopener">https://github.com/1N3/XSSTracer</a> (A small python script to check for Cross-Site Tracing)<br><a href="https://github.com/0x584A/fuzzXssPHP" target="_blank" rel="noopener">https://github.com/0x584A/fuzzXssPHP</a> (PHP版本的反射型xss扫描)<br><a href="https://github.com/chuhades/xss_scan" target="_blank" rel="noopener">https://github.com/chuhades/xss_scan</a> (批量扫描xss的python脚本）<br>企业网络自检<br><a href="https://github.com/sowish/LNScan" target="_blank" rel="noopener">https://github.com/sowish/LNScan</a> （详细的内部网络信息扫描器）<br><a href="https://github.com/ysrc/xunfeng" target="_blank" rel="noopener">https://github.com/ysrc/xunfeng</a> (网络资产识别引擎，漏洞检测引擎）<br><a href="https://github.com/SkyLined/LocalNetworkScanner" target="_blank" rel="noopener">https://github.com/SkyLined/LocalNetworkScanner</a> (javascript实现的本地网络扫描器)<br><a href="https://github.com/laramies/theHarvester" target="_blank" rel="noopener">https://github.com/laramies/theHarvester</a> （企业被搜索引擎收录敏感资产信息监控脚本：员工邮箱、子域名、Hosts）<br><a href="https://github.com/x0day/Multisearch-v2" target="_blank" rel="noopener">https://github.com/x0day/Multisearch-v2</a> (bing、google、360、zoomeye等搜索引擎聚合搜索，可用于发现企业被搜索引擎收录的敏感资产信息）<br>webshell检测<br><a href="https://github.com/We5ter/Scanners-Box/tree/master/Find_webshell/" target="_blank" rel="noopener">https://github.com/We5ter/Scanners-Box/tree/master/Find_webshell/</a> （php后门检测，脚本较简单，因此存在误报高和效率低下的问题）<br><a href="https://github.com/yassineaddi/BackdoorMan" target="_blank" rel="noopener">https://github.com/yassineaddi/BackdoorMan</a> （A toolkit find malicious, hidden and suspicious PHP scripts and shells in a chosen destination）<br>内网渗透<br><a href="https://github.com/0xwindows/VulScritp" target="_blank" rel="noopener">https://github.com/0xwindows/VulScritp</a> （企业内网渗透脚本，包括banner扫描、端口扫描；phpmyadmin、jenkins等通用漏洞利用等）<br><a href="https://github.com/lcatro/networkbackdoorscanner（基于网络流量的内网探测框架）" target="_blank" rel="noopener">https://github.com/lcatro/networkbackdoorscanner（基于网络流量的内网探测框架）</a><br><a href="https://github.com/fdiskyou/hunter（调用" target="_blank" rel="noopener">https://github.com/fdiskyou/hunter（调用</a> Windows API 枚举用户登录信息）<br>中间件扫描、指纹识别类<br><a href="https://github.com/ring04h/wyportmap" target="_blank" rel="noopener">https://github.com/ring04h/wyportmap</a> (目标端口扫描+系统服务指纹识别)<br><a href="https://github.com/ring04h/weakfilescan" target="_blank" rel="noopener">https://github.com/ring04h/weakfilescan</a> (动态多线程敏感信息泄露检测工具)<br><a href="https://github.com/EnableSecurity/wafw00f" target="_blank" rel="noopener">https://github.com/EnableSecurity/wafw00f</a> (WAF产品指纹识别)<br><a href="https://github.com/rbsec/sslscan" target="_blank" rel="noopener">https://github.com/rbsec/sslscan</a> （ssl类型识别)<br><a href="https://github.com/urbanadventurer/whatweb" target="_blank" rel="noopener">https://github.com/urbanadventurer/whatweb</a> (web指纹识别)<br><a href="https://github.com/tanjiti/FingerPrint" target="_blank" rel="noopener">https://github.com/tanjiti/FingerPrint</a> (web应用指纹识别)<br><a href="https://github.com/nanshihui/Scan-T" target="_blank" rel="noopener">https://github.com/nanshihui/Scan-T</a> （网络爬虫式指纹识别)<br><a href="https://github.com/OffensivePython/Nscan" target="_blank" rel="noopener">https://github.com/OffensivePython/Nscan</a> (a fast Network scanner inspired by Masscan and Zmap)<br><a href="https://github.com/ywolf/F-NAScan" target="_blank" rel="noopener">https://github.com/ywolf/F-NAScan</a> (网络资产信息扫描, ICMP存活探测,端口扫描，端口指纹服务识别）<br><a href="https://github.com/ywolf/F-MiddlewareScan" target="_blank" rel="noopener">https://github.com/ywolf/F-MiddlewareScan</a> （中间件扫描）<br><a href="https://github.com/maurosoria/dirsearch" target="_blank" rel="noopener">https://github.com/maurosoria/dirsearch</a> (Web path scanner)<br><a href="https://github.com/x0day/bannerscan" target="_blank" rel="noopener">https://github.com/x0day/bannerscan</a> （C段Banner与路径扫描）<br><a href="https://github.com/RASSec/RASscan" target="_blank" rel="noopener">https://github.com/RASSec/RASscan</a> (端口服务扫描)<br><a href="https://github.com/3xp10it/bypass_waf" target="_blank" rel="noopener">https://github.com/3xp10it/bypass_waf</a> （waf自动暴破）<br><a href="https://github.com/3xp10it/mytools/blob/master/xcdn.py（获取cdn背后的真实ip）" target="_blank" rel="noopener">https://github.com/3xp10it/mytools/blob/master/xcdn.py（获取cdn背后的真实ip）</a><br><a href="https://github.com/Xyntax/BingC（基于Bing搜索引擎的C段/旁站查询，多线程，支持API）" target="_blank" rel="noopener">https://github.com/Xyntax/BingC（基于Bing搜索引擎的C段/旁站查询，多线程，支持API）</a><br><a href="https://github.com/Xyntax/DirBrute（多线程WEB目录爆破工具）" target="_blank" rel="noopener">https://github.com/Xyntax/DirBrute（多线程WEB目录爆破工具）</a><br><a href="https://github.com/zer0h/httpscan（一个爬虫式的网段Web主机发现小工具）" target="_blank" rel="noopener">https://github.com/zer0h/httpscan（一个爬虫式的网段Web主机发现小工具）</a><br><a href="https://github.com/lietdai/doom（thorn上实现的分布式任务分发的ip端口漏洞扫描器）" target="_blank" rel="noopener">https://github.com/lietdai/doom（thorn上实现的分布式任务分发的ip端口漏洞扫描器）</a><br>专用扫描器<br><a href="https://github.com/blackye/Jenkins" target="_blank" rel="noopener">https://github.com/blackye/Jenkins</a> (Jenkins漏洞探测、用户抓取爆破)<br><a href="https://github.com/code-scan/dzscan" target="_blank" rel="noopener">https://github.com/code-scan/dzscan</a> (discuz扫描)<br><a href="https://github.com/chuhades/CMS-Exploit-Framework" target="_blank" rel="noopener">https://github.com/chuhades/CMS-Exploit-Framework</a> (CMS攻击框架)<br><a href="https://github.com/lijiejie/IISshortnameScanner" target="_blank" rel="noopener">https://github.com/lijiejie/IISshortnameScanner</a> (an IIS shortname Scanner)<br><a href="https://github.com/We5ter/Scanne" target="_blank" rel="noopener">https://github.com/We5ter/Scanne</a> … ter/FlashScanner.pl (flashxss扫描)<br><a href="https://github.com/coffeehb/SSTIF（一个Fuzzing服务器端模板注入漏洞的半自动化工具）" target="_blank" rel="noopener">https://github.com/coffeehb/SSTIF（一个Fuzzing服务器端模板注入漏洞的半自动化工具）</a><br>无线网络<br><a href="https://github.com/savio-code/fern-wifi-cracker/" target="_blank" rel="noopener">https://github.com/savio-code/fern-wifi-cracker/</a> (无线安全审计工具)<br><a href="https://github.com/m4n3dw0lf/PytheM（Python网络/渗透测试工具）" target="_blank" rel="noopener">https://github.com/m4n3dw0lf/PytheM（Python网络/渗透测试工具）</a><br><a href="https://github.com/P0cL4bs/WiFi-Pumpkin（无线安全渗透测试套件）" target="_blank" rel="noopener">https://github.com/P0cL4bs/WiFi-Pumpkin（无线安全渗透测试套件）</a><br>综合类<br><a href="https://github.com/az0ne/AZScanner" target="_blank" rel="noopener">https://github.com/az0ne/AZScanner</a> (自动漏洞扫描器，子域名爆破，端口扫描，目录爆破，常用框架漏洞检测)<br><a href="https://github.com/blackye/lalascan" target="_blank" rel="noopener">https://github.com/blackye/lalascan</a> (自主开发的分布式web漏洞扫描框架，集合owasp top10漏洞扫描和边界资产发现能力)<br><a href="https://github.com/blackye/BkScanner" target="_blank" rel="noopener">https://github.com/blackye/BkScanner</a> (BkScanner 分布式、插件化web漏洞扫描器)<br><a href="https://github.com/ysrc/GourdScanV2" target="_blank" rel="noopener">https://github.com/ysrc/GourdScanV2</a> （被动式漏洞扫描)<br><a href="https://github.com/alpha1e0/pentestdb" target="_blank" rel="noopener">https://github.com/alpha1e0/pentestdb</a> (WEB渗透测试数据库)<br><a href="https://github.com/netxfly/passive_scan" target="_blank" rel="noopener">https://github.com/netxfly/passive_scan</a> (基于http代理的web漏洞扫描器)<br><a href="https://github.com/1N3/Sn1per" target="_blank" rel="noopener">https://github.com/1N3/Sn1per</a> (自动化扫描器，包括中间件扫描以及设备指纹识别)<br><a href="https://github.com/RASSec/pentestEr_Fully-automatic-scanner" target="_blank" rel="noopener">https://github.com/RASSec/pentestEr_Fully-automatic-scanner</a> （定向全自动化渗透测试工具）<br><a href="https://github.com/3xp10it/3xp10it" target="_blank" rel="noopener">https://github.com/3xp10it/3xp10it</a> （3xp10it自动化渗透测试框架）<br><a href="https://github.com/Lcys/lcyscan（python插件化漏洞扫描器）" target="_blank" rel="noopener">https://github.com/Lcys/lcyscan（python插件化漏洞扫描器）</a><br><a href="https://github.com/Xyntax/POC-T（渗透测试插件化并发框架）" target="_blank" rel="noopener">https://github.com/Xyntax/POC-T（渗透测试插件化并发框架）</a></p>
<h2 id="CTF平台"><a href="#CTF平台" class="headerlink" title="CTF平台"></a>CTF平台</h2><p><a href="http://www.shiyanbar.com/" target="_blank" rel="noopener">http://www.shiyanbar.com/</a><br><a href="http://oj.xctf.org.cn/" target="_blank" rel="noopener">http://oj.xctf.org.cn/</a><br><a href="http://ctf.bugku.com/" target="_blank" rel="noopener">http://ctf.bugku.com/</a><br><a href="http://rookiehacker.org/" target="_blank" rel="noopener">http://rookiehacker.org/</a></p>
<blockquote>
<p>作者：初识微夏<br>链接：<a href="https://www.zhihu.com/question/23190460/answer/398906959" target="_blank" rel="noopener">https://www.zhihu.com/question/23190460/answer/398906959</a><br>来源：知乎<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>
</blockquote>
]]></content>
      <tags>
        <tag>汇总</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux添加系统调用</title>
    <url>/2019/12/01/Linux%E6%B7%BB%E5%8A%A0%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8/</url>
    <content><![CDATA[<ol>
<li>重新编译Linux内核</li>
<li>增加一个Linux的系统调用。</li>
<li>写一个程序进行调用。<a id="more"></a>

</li>
</ol>
<h2 id="一、实验目的"><a href="#一、实验目的" class="headerlink" title="一、实验目的"></a>一、实验目的</h2><ol>
<li>重新编译Linux内核。</li>
<li>增加一个Linux的系统调用。</li>
<li>写一个程序进行调用。</li>
</ol>
<h2 id="二、实验环境"><a href="#二、实验环境" class="headerlink" title="二、实验环境"></a>二、实验环境</h2><blockquote>
<ul>
<li>电脑型号  华硕 X542UQR</li>
<li>操作系统  Microsoft Windows 10 专业版 (64位)</li>
<li>CPU  (英特尔)Intel(R) Core(TM) i7-8550U CPU @ 1.80GHz(1992 MHz)</li>
<li>主板  华硕 X542UQR</li>
<li>内存  8.00 GB (   2400 MHz)</li>
<li>主硬盘  1000 GB (东芝 67TAW48 已使用时间: 1875小时)</li>
<li>实验软件  VMware® Workstation 14 Pro</li>
<li>实验系统  Centos 7</li>
<li>实验内核版本  Linux 4.20.1</li>
</ul>
</blockquote>
<h2 id="三、实验内容与步骤"><a href="#三、实验内容与步骤" class="headerlink" title="三、实验内容与步骤"></a>三、实验内容与步骤</h2><h3 id="3-1-准备阶段——构造环境"><a href="#3-1-准备阶段——构造环境" class="headerlink" title="3.1 准备阶段——构造环境"></a>3.1 准备阶段——构造环境</h3><ol>
<li><p>安装Developement Tools：</p>
<blockquote>
<p>[root@localhost ~]# yum groupinstall ‘Developement Tools’</p>
</blockquote>
</li>
<li><p>安装ncurses：</p>
<blockquote>
<p>[root@localhost ~]# yum install -y ncurses</p>
</blockquote>
</li>
<li><p>安装elfutils-libelf-devel：</p>
<blockquote>
<p>[root@localhost ~]# yum install ncurses-devel bison flex elfutils-libelf-devel openssl-devel</p>
</blockquote>
</li>
</ol>
<h3 id="3-2-实验阶段"><a href="#3-2-实验阶段" class="headerlink" title="3.2 实验阶段"></a>3.2 实验阶段</h3><ol>
<li><p>下载新内核：到官网：<a href="http://www.kenerl.org" target="_blank" rel="noopener">www.kenerl.org</a> 中下载内核版本Linux-4.20.1。</p>
</li>
<li><p>解压内核压缩包：</p>
<blockquote>
<p>[root@localhost 下载]# tar -xvJf linux-4.20.1 -C /usr/src/kenerls</p>
</blockquote>
</li>
<li><p>进入内核4.20.1中：</p>
<blockquote>
<p>[root@localhost jhuang]# cd /usr/src/kernels/linux-4.20.1</p>
</blockquote>
</li>
<li><p>添加声明：</p>
<blockquote>
<p>[root@localhost linux-4.20.1]# gedit include/linux/syscalls.h</p>
</blockquote>
</li>
</ol>
<p><img src="/2019/12/01/Linux%E6%B7%BB%E5%8A%A0%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8/1.png" alt></p>
<ol start="5">
<li>添加系统函数：<blockquote>
<p>[root@localhost linux-4.20.1]# gedit kernel/sys.c</p>
</blockquote>
</li>
</ol>
<p><img src="/2019/12/01/Linux%E6%B7%BB%E5%8A%A0%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8/2.png" alt></p>
<ol start="6">
<li>添加系统调用<blockquote>
<p>[root@localhost linux-4.20.1]# gedit arch/x86/entry/syscalls/syscall_64.tbl</p>
</blockquote>
</li>
</ol>
<p><img src="/2019/12/01/Linux%E6%B7%BB%E5%8A%A0%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8/3.png" alt> <img src="/2019/12/01/Linux%E6%B7%BB%E5%8A%A0%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8/4.png" alt></p>
<ol start="7">
<li>编译内核<blockquote>
<p>[root@localhost linux-4.20.1]# make oldconfig<br>[root@localhost linux-4.20.1]# make menuconfig</p>
</blockquote>
</li>
</ol>
<p><img src="/2019/12/01/Linux%E6%B7%BB%E5%8A%A0%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8/5.png" alt></p>
<p>直接选择默认设置</p>
<blockquote>
<p>[root@localhost linux-4.20.1]# make -j 4<br>[root@localhost linux-4.20.1]# make modules_install<br>[root@localhost linux-4.20.1]# make install<br>[root@localhost linux-4.20.1]# reboot</p>
</blockquote>
<p>选择第一个内核版本进行编译</p>
<ol start="8">
<li>编程<blockquote>
<p>[root@localhost ~]# cd /home/jhuang/桌面/note/<br>[root@localhost note]# touch myc.c<br>[root@localhost note]# gedit myc.c</p>
</blockquote>
</li>
</ol>
<p>进入页面：<br><img src="/2019/12/01/Linux%E6%B7%BB%E5%8A%A0%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8/7.png" alt></p>
<p>编译程序：</p>
<blockquote>
<p>[root@localhost note]# gcc -c myc.c<br>[root@localhost note]# gcc -o myc myc.o<br>[root@localhost note]# ./myc</p>
</blockquote>
<h2 id="四、实验结果分析"><a href="#四、实验结果分析" class="headerlink" title="四、实验结果分析"></a>四、实验结果分析</h2><p><img src="/2019/12/01/Linux%E6%B7%BB%E5%8A%A0%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8/8.png" alt><br><img src="/2019/12/01/Linux%E6%B7%BB%E5%8A%A0%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8/9.png" alt></p>
<h2 id="五、几个问题"><a href="#五、几个问题" class="headerlink" title="五、几个问题"></a>五、几个问题</h2><h3 id="1-为什么你要添加三个调用并使用不同的调用方式，如64、common、x32？"><a href="#1-为什么你要添加三个调用并使用不同的调用方式，如64、common、x32？" class="headerlink" title="1. 为什么你要添加三个调用并使用不同的调用方式，如64、common、x32？"></a>1. 为什么你要添加三个调用并使用不同的调用方式，如64、common、x32？</h3><blockquote>
<p>答：为了保证我能成功调用我添加的系统函数，我觉得写多个方式的函数比较保险，并且用不同的输出信息予以区分，这样会让我更加深入了解系统调用的原理。</p>
</blockquote>
<h3 id="2-刚刚安装的内核是缺少很多必要的环境组件的，这会导致内核编译不成功，你是怎么解决的？"><a href="#2-刚刚安装的内核是缺少很多必要的环境组件的，这会导致内核编译不成功，你是怎么解决的？" class="headerlink" title="2. 刚刚安装的内核是缺少很多必要的环境组件的，这会导致内核编译不成功，你是怎么解决的？"></a>2. 刚刚安装的内核是缺少很多必要的环境组件的，这会导致内核编译不成功，你是怎么解决的？</h3><blockquote>
<p>答：我先是升级了所有现有的软件，然后再在接下来的编译过程中，遇到缺少什么套件，就安装什么套件。</p>
</blockquote>
<h3 id="3-我看到你编译了多次不同的内核，是因为遇到什么问题吗？"><a href="#3-我看到你编译了多次不同的内核，是因为遇到什么问题吗？" class="headerlink" title="3. 我看到你编译了多次不同的内核，是因为遇到什么问题吗？"></a>3. 我看到你编译了多次不同的内核，是因为遇到什么问题吗？</h3><blockquote>
<p>答：第一次我安装了版本为3.2.75的内核，由于它不是在官网下的，所以可能存在被人修改过的嫌疑，虽然内核编译成功了，但是不能成功进入我所期待的页面，所以放弃了，重新找了个内核版本为3.10.89的内核，这也不是在kernel.org上下的，所以同样遇到问题，这个问题是：开机时虚拟机显示被客户机操作系统禁用了cpu，由于在网上搜不到较好的解决方案，所以去官网下载了如今的4.20.1版本的内核，最后编译成功。</p>
</blockquote>
]]></content>
      <tags>
        <tag>操作系统</tag>
        <tag>课程</tag>
      </tags>
  </entry>
  <entry>
    <title>DNSTunnel技术攻防</title>
    <url>/2019/12/01/DNSTunnel%E6%8A%80%E6%9C%AF%E6%94%BB%E9%98%B2/</url>
    <content><![CDATA[<h2 id="1-DNS概述"><a href="#1-DNS概述" class="headerlink" title="1. DNS概述"></a>1. DNS概述</h2><p>DNS在我们的网络世界中是一个非常重要的协议，它将长串的不适合记忆的IP地址映射成可读性较强的字符域名。整个域名空间呈层次化的树状结构，顶层是根域，全球一共有13个根域。根域下为我们平常熟悉的顶级域，如.com,.net,.org等。域名的存储、解析和管理都要通过域名服务器来实现。根据域名所属域和授权范围可以划分Zone，Zone上的主服务器和辅服务器均被称为权威域名服务器。权威域名服务器上保存了该域的所有主机信息。</p>
<a id="more"></a>
<p>DNS的记录类型有很多，大家常见的有A，AAAA,CNAME,MX,SOA,NS等。DNS的解析过程可以分为两种类型：迭代查询和递归查询。通常本机到Local DNS Server的过程属于递归查询，而Local DNS Server对查询域名的解析过程属于迭代查询。为了减轻Local DNS Server的压力，提高解析速度，引入了缓存机制。缓存和TTL紧密相连，当TTL过期，Local DNS Server则会丢弃缓存的数据，重新从权威域名服务器上获取新的数据。</p>
<h2 id="2-隧道技术"><a href="#2-隧道技术" class="headerlink" title="2. 隧道技术"></a>2. 隧道技术</h2><p>为了逃避监测，绕过杀软，更好的隐藏自身，很多木马的传输层都使用了隧道技术，隧道技术是一种通过使用互联网络的基础设施在网络之间传递数据的方式，使用隧道传递的Data(数据)或Payload(负载）可以是不同协议的数据帧或包。</p>
<p>隧道协议将其它协议的数据帧或包，重新封装然后通过隧道发送，新的帧头提供路由信息，以便通过互联网传递被封装的 Payload。其数据传输特点（Feature）就是不通过网络直接发送数据包，通过封装技术在另一个(通常是加密的)连接中发送数据。</p>
<p>常见基于数据包隧道有IPsec、L2TP、PPTP、PPPoE、SSH、TLS、SOCKS等等，其主要作用是规避防火墙。</p>
<p>一个被防火墙阻挡的协议可被包在另一个没被防火墙阻挡的协议里，如HTTP。如果防火墙并没有排除此种包装，这技巧可用来逃避防火墙政策。隧道可按要求创建起一条与其他服务器的通信线路，届时使用SSL等加密手段进行通信。</p>
<h2 id="3-DNS隧道介绍"><a href="#3-DNS隧道介绍" class="headerlink" title="3. DNS隧道介绍"></a>3. DNS隧道介绍</h2><p>DNS隧道技术就是指利用DNS协议建立隐蔽信道，实现隐蔽数据传输。</p>
<p>传统socket隧道已极少，TCP、UDP大量被防御系统拦截，DNS、ICMP、HTTP/HTTPS等难于禁止的协议已成为黑客控制隧道的主流。比如在安全策略严格的内网环境中，常见的C&amp;C通讯端口都被众多安全设备所监控。在对目标内网的终端进行渗透时，网段只允许白名单流量出站，同时其它端口都被屏蔽时，传统C&amp;C通讯手段无法建立，反弹Shell变得十分困难。</p>
<p>在这种情况下，DNS隧道往往可以成功，一方面是因为 DNS 报文具有天然的穿透防火墙的能力;另一方面,目前的杀毒软件、IDS 等安全策略很少对 DNS 报文进行有效的监控管理。<br> <br>最早是在2004年DanKaminsky在Defcon大会上发布的基于NSTX的DNS隐蔽隧道工具，之后出现了越来越多的DNS隐蔽通道工具</p>
<ol>
<li>iodine: <a href="https://github.com/yarrick/iodine" target="_blank" rel="noopener">https://github.com/yarrick/iodine</a></li>
<li>Dns2tcp: <a href="https://www.aldeid.com/wiki/Dns2tcp" target="_blank" rel="noopener">https://www.aldeid.com/wiki/Dns2tcp</a></li>
<li>tcp-over-dns: <a href="http://analogbit.com/software/tcp-over-dns/" target="_blank" rel="noopener">http://analogbit.com/software/tcp-over-dns/</a></li>
<li>Heyoka: <a href="http://heyoka.sourceforge.net/" target="_blank" rel="noopener">http://heyoka.sourceforge.net/</a></li>
<li>Dnscat: <a href="https://wiki.skullsecurity.org/Dnscat" target="_blank" rel="noopener">https://wiki.skullsecurity.org/Dnscat</a></li>
<li>OzymanDNS <a href="https://dnstunnel.de/" target="_blank" rel="noopener">https://dnstunnel.de/</a></li>
<li>DNSScapy <a href="https://code.google.com/archive/p/dnscapy/" target="_blank" rel="noopener">https://code.google.com/archive/p/dnscapy/</a></li>
<li>DnsShell <a href="https://github.com/sensepost/DNS-Shell" target="_blank" rel="noopener">https://github.com/sensepost/DNS-Shell</a></li>
<li>ReverseDnsShell <a href="https://github.com/ahhh/Reverse_DNS_Shell" target="_blank" rel="noopener">https://github.com/ahhh/Reverse_DNS_Shell</a></li>
<li>…</li>
</ol>
<h2 id="4-DNS隧道分类"><a href="#4-DNS隧道分类" class="headerlink" title="4. DNS隧道分类"></a>4. DNS隧道分类</h2><h3 id="4-1-IP直连型"><a href="#4-1-IP直连型" class="headerlink" title="4.1 IP直连型"></a>4.1 IP直连型</h3><p>如果DNS隧道的服务器可以与本地主机通过IP直接通信，传输协议采用DNS协议，则称为IP直连型。</p>
<p>IP直连型DNS隧道木马的服务器端开放53端口，被控端利用UDP Socket套接字直接与C&amp;C服务建立连接。在这种情况下，两者传输的内容实际上是基于UDP服务。<br>这种木马与传统UDP木马的几点不同</p>
<ol>
<li>利用53端口进行传输交互数据，而53端口的外联基本上在所有机器上都必须开放，否则则无法使用互联网DNS服务；</li>
<li>精心构造传输的载荷内容，使其至少从格式上是符合DNS query包格式，因为如果攻击者构造的UDP载荷内容不符合DNS报文格式，在Wireshark等流量分析工具的流量解析下，很容易出现DNS报文异常的情况。</li>
</ol>
<h3 id="4-2-域名解析型"><a href="#4-2-域名解析型" class="headerlink" title="4.2 域名解析型"></a>4.2 域名解析型</h3><p>域名解析型也可以叫做DNS迭代查询中继型，基本通信架构如下图所示<br><img src="/2019/12/01/DNSTunnel%E6%8A%80%E6%9C%AF%E6%94%BB%E9%98%B2/4.1.png" alt></p>
<ol>
<li>被控端把要传输的内容封装在DNS请求包中，发起一次正常的DNS解析请求；</li>
<li>当被控端向任意一台DNS服务器请求该域名下的子域名时，本地DNS服务器无论是通过递归查询还是迭代查询，都会向外转发这个DNS请求，最终这个DNS请求都会被送到黑客控制的权威NS服务器中（这意味着黑客必须事先配置好NS以及A记录解析）；</li>
<li>DNS服务器控制端解析请求报文，得到被控端传来的信息，然后将攻击控制命令通过封装在DNS响应报文中；</li>
<li>从而实现双方通信，所有的通信都必须由被控端（Client端）主动发起，不断回传数据并接受新指令。</li>
</ol>
<p>中继过程中的一个关键点是对DNS缓存机制的规避，因为如果需要解析的域名在Local DNS Server中已经有缓存时，Local DNS Server就不会转发数据包。所以在我们构造的请求中，每次查询的域名都是不一样的或者是已经是过期的。</p>
<p>这个特征同时也包含了一个可用于检测的规律，即在DNS Tunnel的会话中，Dns Query Host的数量会比正常情况下要多，对DNS载荷的编码是DNS Tunnel的另一个核心技术，从高层来看，载荷只是客户端和服务器通信的正常流量。</p>
<p>例如客户端发送一个A记录请求给服务器，查询的主机名为<strong>2roAUwBaCGRuc3R1bm5lbGluZwo.test.domain.com</strong>,其中<strong>2roAUwBaCGRuc3R1bm5lbGluZwo</strong>则是客户端传递给服务器的信息，这串字符解码后的信息便是<strong>dnstunneling</strong>。</p>
<p>在大多数场景下，内网的Client位于防火墙后，Server不可能发起连接。所以大多数工具，Client会定时向Server发送请求，保证二者之间的通信状态。</p>
<h3 id="4-3-IP直连型和域名解析型异同点"><a href="#4-3-IP直连型和域名解析型异同点" class="headerlink" title="4.3 IP直连型和域名解析型异同点"></a>4.3 IP直连型和域名解析型异同点</h3><p>这2种方法虽然工作原理上存在差别，但是从流量角度上来看都是基于DNS协议，但是这里在实际工程中也要注意，你旁路采集的方式可能会影响到你最终能否采集到完整的通信日志，例如如果你是采用记录DNS解析的方法，则可能会漏过UDP IP直连的这种通信方式，如果直接在网关上进行“端口和协议解析”则可以保证全流量采集。</p>
<p>IP直连型DNS隧道木马直接与DNS服务器通过UDP Socket通信，因此通信效率要比域名型DNS隧道木马高，但是这种DNS隧道木马致命的弱点是直接把IP暴露在网络流量中，如果客户端指定信任的DNS服务器解析DNS服务，那么IP直连型DNS隧道木马就很容易被IP黑白名单封杀；</p>
<p>对于域名型DNS隧道木马而言，只要客户机能与任意一台外网的DNS服务器通信，那么域名型DNS隧道木马就可以工作，因此域名型 DNS隧道木马生存能力更强，隐蔽性更高，更适合进行隐蔽的控制渗透任务。</p>
<h2 id="5-DNS隧道案例"><a href="#5-DNS隧道案例" class="headerlink" title="5. DNS隧道案例"></a>5. DNS隧道案例</h2><p>DNS隧道有诸多优点，也被各种黑客组织所用，经过各种变形、加密，制作各种后门和木马程序，复杂程度越来越高。</p>
<h3 id="5-1-XshellGhost"><a href="#5-1-XshellGhost" class="headerlink" title="5.1 XshellGhost"></a>5.1 XshellGhost</h3><p>2017年8月NetSarang旗下多款软件的关键模块被植入了高级后门，这是一起入侵感染供应链软件的大规模攻击事件，被称为为“XshellGhost”。</p>
<p>后门会将主机的用户信息通过特定DGA(域名生成算法)产生的DNS域名传送至黑客的远程命令控制服务器，同时黑客的服务器会动态下发任意的恶意代码至用户机器执行，其中具有TCP、HTTP、UDP、DNS、HTTPS、SSL网络协议进行远程控制能力，其中DNS通信模块因主动运行被发现。</p>
<p>在发送数据包时，会将数据嵌套到 DNS 协议中发送，其中数据会编码成特定的字符串，添加在要配置文件中的 CCDNS URL前，实现DNS隧道通讯。</p>
<p>也是因为该事件的爆发，DNS隧道的防御逐渐被重视，各大公司纷纷启动对DNS隧道的监控。
 </p>
<h3 id="5-2-ALMA-Communicator"><a href="#5-2-ALMA-Communicator" class="headerlink" title="5.2 ALMA Communicator"></a>5.2 ALMA Communicator</h3><p>ALMA Communicator在2017年12月被发现来自OilRig黑客组织，它使用了DNS隧道来作为C2通信信道，使用了专门的子域名来给C2服务器传输数据，服务器使用了专门的IPv4地址来给木马发送数据。</p>
<p>在构建这种专门的子域名时，木马会生成一个随机的四位数字，并连接一个硬编码字符串，最后再在字符串末尾添加一个用于标识受感染系统的唯一标识符。最后，它会添加硬编码的-0-2D-2D字符串来结束子域名（用于C2服务器通信）的构造，下图显示的是域名的结构<br><img src="/2019/12/01/DNSTunnel%E6%8A%80%E6%9C%AF%E6%94%BB%E9%98%B2/5.2.png" alt><br>该木马在向C2服务器发送数据时所使用的DNS查询语句的结构，其中每一次DNS请求一次只能发送10个字节的数据，下图是DNS查询时的结构<br><img src="/2019/12/01/DNSTunnel%E6%8A%80%E6%9C%AF%E6%94%BB%E9%98%B2/5.2.1.png" alt><br>目前OilRig黑客组织仍在他们的攻击活动中使用这种技术，并不断变种更新</p>
<h3 id="5-3-Trojan-Win32-Ismdoor-gen"><a href="#5-3-Trojan-Win32-Ismdoor-gen" class="headerlink" title="5.3 Trojan.Win32.Ismdoor.gen"></a>5.3 Trojan.Win32.Ismdoor.gen</h3><p>该木马在2017年被发现，是一个有多层的C2通信协议结构，使用DNS隧道传输，并将传出“datagrams”（数据报）的长度被限制在60字符，C2服务器的命令解析到IPv6地址，一个典型的查询发送到C2服务器如下:n.n.c.<Session id>.<Serverdomain>.com<br><img src="/2019/12/01/DNSTunnel%E6%8A%80%E6%9C%AF%E6%94%BB%E9%98%B2/5.3.png" alt></Serverdomain></Session></p>
<p>在DNS隧道传输层上面适当的位置有一个会话层协议,这意味着交换“短”和“长”数据包的能力。会话层与传输层的不同之处在于,它有一种机制来检查丢失的消息。当传输层通过一种数据交换关闭会话时（该数据交换是关于发送和接收数据包的数量），会话层便检查确保每一个发送的数据包已经被正确接收进而关闭。由服务器决定使用哪个选项；例如,“长”数据包协议是用来从受感染的电脑上传文件。</p>
<blockquote>
<ul>
<li>短消息<br>在这个层次上,机器人的操作可分为五个步骤:</li>
</ul>
<ol>
<li>向服务器声明会话ID;</li>
<li>在数据包中发送消息;</li>
<li>发送已发送数据包数量;</li>
<li>接收传入数据包的数量;</li>
<li>接收传入的数据包。</li>
</ol>
<ul>
<li>长消息<br>在这种情况下,与服务器通信可以分为以下步骤:</li>
</ul>
<ol>
<li>发送文件分成的数据包的数量;</li>
<li>发送文件;</li>
<li>向服务器发送周期查询以检查丢失的数据包;</li>
<li>重新发送丢失的数据包。</li>
</ol>
</blockquote>
<h3 id="5-4-PlugX"><a href="#5-4-PlugX" class="headerlink" title="5.4 PlugX"></a>5.4 PlugX</h3><p>该后门木马结合DNS隧道传输技术和PlugX远控程序，通过建立的DNS隧道进行攻击控制，和XshellGhost相似，将用户信息编码到子域名部分发起TXT类型的DNS查询进行受控端上线。但不同的是它将编码后的全域名发送到公共DNS服务器来建立通信隧道，并且也是通过查询TXT来返回数据。</p>
<p>程序就对接收到的TXT回包进行校验和解码，除了正常编码的TXT数据外，还添加一条长度为0的空Text作为结尾才可以通过程序检查到达下一步控制流程<br><img src="/2019/12/01/DNSTunnel%E6%8A%80%E6%9C%AF%E6%94%BB%E9%98%B2/5.4.png" alt></p>
<h3 id="5-5-DarkHydrus-APT组织"><a href="#5-5-DarkHydrus-APT组织" class="headerlink" title="5.5 DarkHydrus APT组织"></a>5.5 DarkHydrus APT组织</h3><p>2019年1月被发现针对中东地区的定向攻击活动，后门程序利用了复杂的DNS隧道技术与C2进行通信并执行指令，且通过GoogleDrive API实现文件的上传下载。</p>
<p>后门使用了第二类也就是域名型隧道，而且会根据不同的查询类型，使用不同的正则表达式去匹配DNS服务器返回的结果数据。</p>
<p>木马先会通过向攻击者控制的DNS服务器发送DNS查询请求来发送当前木马的上线ID给攻击者接着根据当前DNS请求的类型分别用不同的正则表达式规则匹配其返回的数据结果，并取取其中的数据<br><img src="/2019/12/01/DNSTunnel%E6%8A%80%E6%9C%AF%E6%94%BB%E9%98%B2/5.5.png" alt><br>比如执行nslookup并使用查询类型为A进行查询，最终使用以下正则表达式匹配返回的数据结果<br><img src="/2019/12/01/DNSTunnel%E6%8A%80%E6%9C%AF%E6%94%BB%E9%98%B2/5.5.1.png" alt><br>使用查询类型AC得到返回的数据，并使用以下正则表达式匹配返回的数据结果<br><img src="/2019/12/01/DNSTunnel%E6%8A%80%E6%9C%AF%E6%94%BB%E9%98%B2/5.5.2.png" alt><br>使用查询类型为AAAA得到的数据使用以下正则表达式匹配返回的数据结果<br><img src="/2019/12/01/DNSTunnel%E6%8A%80%E6%9C%AF%E6%94%BB%E9%98%B2/5.5.3.png" alt><br>使用其他DNS查询类型得到的数据使用以下正则表达式匹配返回的数据结果<br><img src="/2019/12/01/DNSTunnel%E6%8A%80%E6%9C%AF%E6%94%BB%E9%98%B2/5.5.4.png" alt><br>该木马共使用了A、AAAA、AC、CNAME、TXT、SRV、SOA、MX等DNS查询类型</p>
<h2 id="6-防御检测"><a href="#6-防御检测" class="headerlink" title="6. 防御检测"></a>6. 防御检测</h2><p>目前安全产品多是基于监控终端请求异常长度的域名等规则方式进行DNS隧道检测，但可以通过修改域名长度、请求频率等特征轻易绕过传统基于规则的DNS隧道的检测模型，相比于基于规则的静态阈值检测误报高，易被绕过等问题，还可以使用机器学习技术从历史数据中学习出一个DNS隧道模式用于检测。</p>
<p>主要可以从以下几个方面对DNS隧道进行检测。</p>
<h3 id="6-1-DNS-Query-Type成分组成异常检测"><a href="#6-1-DNS-Query-Type成分组成异常检测" class="headerlink" title="6.1 DNS Query Type成分组成异常检测"></a>6.1 DNS Query Type成分组成异常检测</h3><ol>
<li>DNS Tunnel<br>很多DNS Tunneling使用TXT记录类型发送请求和响应（例如文件上传等大数据量功能），而在正常的DNS网络流量中，TXT记录的比例可能只有1%-2%，如果时间窗口内，TXT记录的比例激增，那么也意味着可能存在异常。</li>
<li>DNS FF Botnet<br>另外，在FF Botnet中，NXDOMAIN的比例也会比正常情况下要高。</li>
<li>DNS Query Types Numbers<br>僵尸网络的DNS查询主要是查找C2的IP地址，查询类型的数量是有限的，四种主要的查询类型是A，AAAA，MX和NS。但是，良性名称查询的类型多于那些，其可能还包括ANY，TXT，SRV，SOA，CNAME，A6等。那么可以统计一个会话中的DNS Type数量，判断异常</li>
</ol>
<h3 id="6-2-基于Zipf定律的异常检测"><a href="#6-2-基于Zipf定律的异常检测" class="headerlink" title="6.2 基于Zipf定律的异常检测"></a>6.2 基于Zipf定律的异常检测</h3><p>根据Zipf定律，在自然语言的语料库里，词频往往会集中于某些小子集中，并且高频词到低频次的频率逐渐下降。<br><img src="/2019/12/01/DNSTunnel%E6%8A%80%E6%9C%AF%E6%94%BB%E9%98%B2/6.2.png" alt></p>
<p>DNS Tunneling中由于域名做了编码，不符合Zipf定律（例如dns2tcp），整个分布趋于平稳。我们可以通过检测排序后的词频平均斜率来检测是否符合Zipf定律。
 </p>
<h3 id="6-3-DNS会话时长检测"><a href="#6-3-DNS会话时长检测" class="headerlink" title="6.3 DNS会话时长检测"></a>6.3 DNS会话时长检测</h3><p>TCP会话在建立通信过程中存在“三次握手”和断开连接的“四次握手”行为，因此TCP会话可以计算会话时长。</p>
<p>DNS会话属于UDP会话的其中一种，由于UDP无连接的特性，DNS没有会话时长的严格定义。定义在一次DNS会话中，最后一个DNS报文的时间和第一个DNS报文的时间差就作为这个DNS会话的时长。</p>
<p>正常情况下，一次DNS解析过程首先由客户机在本地随机开启一个UDP端口，然后向指定的DNS服务器53端口发送DNS请求报文，两者由此建立一个UDP通道。客户机一旦得到相应DNS回复报文，这个 DNS解析过程就结束了，如果没有后继的DNS解析任务，创建的UDP套接字会保存一段时间然后关闭，完成一次DNS会话，再次进行DNS解析的时候，再随机开启另一个UDP端口，重复上述过程。因此，正常域名解析DNS会话的时间短；</p>
<p>对于DNS隧道木马而言，创建的UDP套接字通常会等到木马下线或者木马生命结束才关闭，UDP套接字会被复用，导致DNS隧道木马的DNS会话时长远大于正常DNS会话时长。</p>
<h3 id="6-4-DNS会话中数据包总数"><a href="#6-4-DNS会话中数据包总数" class="headerlink" title="6.4 DNS会话中数据包总数"></a>6.4 DNS会话中数据包总数</h3><p>因为DNS隧道木马的会话一般随着木马生命周期的结束而结束，在整个木马的生命周期里会向外发送心跳报文、传输本机敏感信息、资源文件等，控制端会下达相关的远程控制指令等。所以在DNS隧道木马会话中DNS报文数量大。<br>然而，正常客户端产生的DNS会话随着一次DNS解析任务结束而结束，DNS会话比较简短。大多数情况是2个，由1个DNS请求报文和1个DNS响应报文组成。</p>
<h3 id="6-3-“上行大包”请求比例"><a href="#6-3-“上行大包”请求比例" class="headerlink" title="6.3 “上行大包”请求比例"></a>6.3 “上行大包”请求比例</h3><p>在DNS请求报文中，如果Queries字段大于50字节，那么定义该DNS请求报文为上行大包。</p>
<p>DNS隧道木马被控端把要传输的内容封装在Queries字段的域名中，DNS隧道木马为了在一次传输过程中携带尽可能多的隐蔽信息，往往造成Queries字段中的域名长度偏长。与正常DNS会话相比，DNS隧道木马会话中“上行大包”占请求报文总数的比例较大。</p>
<p>另一方面，如果攻击者为规避检测，强制拆分构造相对短小的域名，从而减少每次发送的报文携带的隐蔽通信内容。当被控端传送某一固定的敏感资源文件，由于传送的资源文件大小是固定的,如果牺牲一次携带的隐蔽信息的内容，势必造成整个DNS会话的DNS报文总数的增加，所以在一次DNS隧道木马的会话中，DNS报文总数和DNS报文长度是负相关的。</p>
<h3 id="6-4-“下行小包”响应比例"><a href="#6-4-“下行小包”响应比例" class="headerlink" title="6.4 “下行小包”响应比例"></a>6.4 “下行小包”响应比例</h3><p>将DNS应答报文中Answers字段小于50字节的数据包称为“下行小包”。</p>
<p>DNS隧道木马在交互过程中，控制端发送的控制命令一般有特定含义，且短小精简，因此DNS隧道回复报文一般是“下行小包”。</p>
<p>对于正常本机DNS解析请求而言，客户机是资源请求者，DNS服务器返回的数据除了Answers字段外，还经常返回授权和额外信息字段信息，因此正常的DNS响应报文相对较大。</p>
<h3 id="6-5-域名对应的主机名数量"><a href="#6-5-域名对应的主机名数量" class="headerlink" title="6.5. 域名对应的主机名数量"></a>6.5. 域名对应的主机名数量</h3><p>对于DNS隧道木马而言，控制端要不断借助DNS Query的Query_name来承载要传输的内容，所以从主机数量这个维度来看，在一个DNS Tunnel会话中，域名对应的主机名数量会明显大于正常的DNS通信。</p>
<h3 id="6-6-FQDN数异常检测"><a href="#6-6-FQDN数异常检测" class="headerlink" title="6.6. FQDN数异常检测"></a>6.6. FQDN数异常检测</h3><p>域名有全称和简称的区别。全称的域名，直译为”完全的合格的域名”(FQDN，Fully Qualified Domain Name)，表现为由”.”隔开的点分式层次结构，叫名称空间，它指定了一台主机和它所属域的隶属关系，而简称通常就是这台主机的计算机名，在域名的最左边。</p>
<p>可以这么说FQDN(完全合格的域名)，是域加计算机名的总称。比如:  <a href="http://www.microsoft.com" target="_blank" rel="noopener">www.microsoft.com</a> 这个FQDN中，www是主机名，microsoft.com是域。 www+microsoft.com 组合在一块就成了一个完整的域名(FQDN)。</p>
<p>可以通过分析一定时间窗口内所产生的FQDN数，通常DNS Tunneling的FQDN数在一定时间窗口内会远高于正常的DNS流量。</p>
<h3 id="6-7-响应时间特征"><a href="#6-7-响应时间特征" class="headerlink" title="6.7 响应时间特征"></a>6.7 响应时间特征</h3><p>正常的DNS Server会在较短时间内完成DNS响应，而DNS Tunnel由于需要进行数据的解码以及后续处理逻辑，响应时间会稍微较长。</p>
<h3 id="6-8-发包频率行为"><a href="#6-8-发包频率行为" class="headerlink" title="6.8 发包频率行为"></a>6.8 发包频率行为</h3><p>DNS Tunnel中DNS请求数量会很大，可以作为检测依据，但在实际的环境中，存在一些DNS Flood攻击行为，这部分攻击触发的行为日志很容易命中到DNS Tunnel模型，对于这种情况，需要将所有DNS会话包之前的间隔统计出来，计算它们的均值/方差等特征</p>
<h2 id="7-总结"><a href="#7-总结" class="headerlink" title="7. 总结"></a>7. 总结</h2><p>DNS隧道技术由于隐蔽性高，穿透性强，备受黑客组织青睐，逐渐发展出复杂的通信技术手段。又由于防御手段有限，传统规则检测技术高误报，易绕过，数据科学和机器学习技术逐渐被使用，同时也出现了对抗数据分析和机器学习的更高级设计，但总能在统计分析上找到一些特定的规律。</p>
]]></content>
      <categories>
        <category>理论</category>
      </categories>
      <tags>
        <tag>DNS</tag>
        <tag>攻防</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript基础知识</title>
    <url>/2019/11/24/JavaScript%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</url>
    <content><![CDATA[<h1 id="JavaScript的基本知识"><a href="#JavaScript的基本知识" class="headerlink" title="JavaScript的基本知识"></a>JavaScript的基本知识</h1><h2 id="一、在html中的使用"><a href="#一、在html中的使用" class="headerlink" title="一、在html中的使用"></a>一、在html中的使用</h2><a id="more"></a>
<h3 id="1-1-在页面中直接嵌入JavaScript"><a href="#1-1-在页面中直接嵌入JavaScript" class="headerlink" title="1.1 在页面中直接嵌入JavaScript"></a>1.1 在页面中直接嵌入JavaScript</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;!doctype html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">&lt;meta charset=<span class="string">"utf-8"</span>&gt;</span><br><span class="line"></span><br><span class="line">&lt;script language=<span class="string">"javascript"</span>&gt;</span><br><span class="line">	alert(<span class="number">1</span>)</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">&lt;/</span>head&gt;</span><br><span class="line">&lt;<span class="regexp">/html&gt;</span></span><br></pre></td></tr></table></figure>
<p>执行后会直接弹出框。</p>
<h3 id="1-2-script标签常用的属性和说明"><a href="#1-2-script标签常用的属性和说明" class="headerlink" title="1.2 script标签常用的属性和说明"></a>1.2 script标签常用的属性和说明</h3><table>
<thead>
<tr>
<th>属性</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>language</td>
<td>设置所使用的的脚本语言及版本</td>
</tr>
<tr>
<td>src</td>
<td>设置一个外部文件的路径位置</td>
</tr>
<tr>
<td>type</td>
<td>设置所使用的脚本语言，此属性已经代替language</td>
</tr>
<tr>
<td>defer</td>
<td>此属性表示当html文档加载完毕之后再执行脚本语言</td>
</tr>
</tbody></table>
<h3 id="1-3-外部调用"><a href="#1-3-外部调用" class="headerlink" title="1.3 外部调用"></a>1.3 外部调用</h3><ol>
<li>使用src调用js文件（外部js文件不需要用<script></script>括起来）</li>
<li>使用函数调用本文档中的script函数如：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;input onclick=&quot;myjsFun()&quot; /&gt;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h2 id="二、基础"><a href="#二、基础" class="headerlink" title="二、基础"></a>二、基础</h2><h3 id="2-1-变量"><a href="#2-1-变量" class="headerlink" title="2.1 变量"></a>2.1 变量</h3><h4 id="2-1-1-变量类型"><a href="#2-1-1-变量类型" class="headerlink" title="2.1.1 变量类型"></a>2.1.1 变量类型</h4><p>有很多，基本的都有，如果想表达十六进制，则在数据之前加上<strong>0x</strong>即可。<br>然而JavaScript是无类型语言，所以，<strong>声明变量</strong>直接用<strong>var</strong>即可</p>
<h4 id="2-1-2-未定义值和空值"><a href="#2-1-2-未定义值和空值" class="headerlink" title="2.1.2 未定义值和空值"></a>2.1.2 未定义值和空值</h4><ul>
<li>空值（null）不是0也不是空的字符串</li>
<li>一个值是空值表示已经赋过值，而未定义（undefined）表示没有赋值，两者不一样。</li>
</ul>
<h3 id="2-2-运算符和表达式"><a href="#2-2-运算符和表达式" class="headerlink" title="2.2 运算符和表达式"></a>2.2 运算符和表达式</h3><h4 id="2-2-1-比较运算符"><a href="#2-2-1-比较运算符" class="headerlink" title="2.2.1 比较运算符"></a>2.2.1 比较运算符</h4><p>只挑一些讲</p>
<table>
<thead>
<tr>
<th>运算符</th>
<th>描述</th>
<th>示例</th>
</tr>
</thead>
<tbody><tr>
<td>==</td>
<td>等于，只涉及表面值的判断，不涉及数据类型</td>
<td>“17”==17 return true</td>
</tr>
<tr>
<td>===</td>
<td>绝对等于，同时涉及表面值和数据类型的判断</td>
<td>“17”==17 return false</td>
</tr>
</tbody></table>
<p>注：这个在php中也适用。而不等于分别是!= 和!==</p>
<h4 id="2-2-2-条件运算符"><a href="#2-2-2-条件运算符" class="headerlink" title="2.2.2 条件运算符"></a>2.2.2 条件运算符</h4><blockquote>
<p>操作数？结果1：结果2</p>
</blockquote>
<p>这个跟C++一样啊？<br>这里来个九九乘法表练习！</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!doctype html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"utf-8"</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">language</span>=<span class="string">"javascript"</span>&gt;</span></span><br><span class="line"><span class="javascript">	<span class="built_in">document</span>.write(<span class="string">"&lt;table&gt;"</span>);</span></span><br><span class="line"><span class="actionscript">	<span class="keyword">var</span> str = <span class="string">"javascript 9*9"</span>;</span></span><br><span class="line"><span class="javascript">	<span class="built_in">document</span>.write(<span class="string">"&lt;h1&gt;"</span>+str+<span class="string">"&lt;/h1&gt;"</span>);</span></span><br><span class="line"><span class="actionscript">	<span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">1</span>;i&lt;<span class="number">10</span>;i++)</span></span><br><span class="line">	&#123;</span><br><span class="line"><span class="javascript">		<span class="built_in">document</span>.write(<span class="string">"&lt;tr&gt;"</span>);</span></span><br><span class="line"><span class="actionscript">		<span class="keyword">for</span>(<span class="keyword">var</span> j = <span class="number">1</span>;j&lt;=i;j++)</span></span><br><span class="line">		&#123;</span><br><span class="line"><span class="javascript">			<span class="built_in">document</span>.write(i!=j?<span class="string">"&lt;th&gt;"</span>:<span class="string">"&lt;th bgcolor='#FF0000'&gt;"</span>);</span></span><br><span class="line"><span class="javascript">			<span class="built_in">document</span>.write(i+<span class="string">"*"</span>+j+<span class="string">"="</span>+i*j);</span></span><br><span class="line"><span class="javascript">			<span class="built_in">document</span>.write(<span class="string">"&lt;/th&gt;"</span>);</span></span><br><span class="line">		&#125;</span><br><span class="line"><span class="javascript">		<span class="built_in">document</span>.write(<span class="string">"&lt;/tr&gt;"</span>);</span></span><br><span class="line">	&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="三、函数"><a href="#三、函数" class="headerlink" title="三、函数"></a>三、函数</h2><p>格式如下：</p>
<blockquote>
<p>function 自定义函数名（形参1，形参2…）<br>｛<br>       函数体<br>｝</p>
</blockquote>
<p>函数要在script标签中定义，使用的话，直接在html中调用函数名和参数即可，如onclick=”myFun()”。</p>
<p>几种特殊内置的函数：</p>
<table>
<thead>
<tr>
<th>函数</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>eval()</td>
<td>求字符串中表达式的值</td>
</tr>
<tr>
<td>isFinite()</td>
<td>判断一个数值是否是无穷大</td>
</tr>
<tr>
<td>isNaN()</td>
<td>判断一个数值时都是NaN</td>
</tr>
<tr>
<td>parseInt()</td>
<td>将字符型转化为整型</td>
</tr>
<tr>
<td>parseFloat()</td>
<td>将字符型转化为浮点型</td>
</tr>
<tr>
<td>encodeURI()</td>
<td>将字符串转化为有效的URL</td>
</tr>
<tr>
<td>encodeURIComponent()</td>
<td>将字符串转化为有效的URL组件</td>
</tr>
<tr>
<td>decodeURI()</td>
<td>对encodeURI()编码的文本进行解码</td>
</tr>
<tr>
<td>decodeURIComponent()</td>
<td>encodeURIComponent()编码的文本进行解码</td>
</tr>
</tbody></table>
<h2 id="四、对象编程"><a href="#四、对象编程" class="headerlink" title="四、对象编程"></a>四、对象编程</h2><h3 id="4-1-Window对象"><a href="#4-1-Window对象" class="headerlink" title="4.1 Window对象"></a>4.1 Window对象</h3><h4 id="4-1-1-属性"><a href="#4-1-1-属性" class="headerlink" title="4.1.1 属性"></a>4.1.1 属性</h4><table>
<thead>
<tr>
<th>属性</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>document</td>
<td>对话框中显示的当前文档</td>
</tr>
<tr>
<td>location</td>
<td>指定当前文档的url</td>
</tr>
<tr>
<td>name</td>
<td>对话框名字</td>
</tr>
<tr>
<td>navigator</td>
<td>表示浏览器对象，用于获取与浏览器相关的信息</td>
</tr>
<tr>
<td>这个可以直接调用，如document.write()</td>
<td></td>
</tr>
<tr>
<td>document.getelementById(‘test’)</td>
<td></td>
</tr>
</tbody></table>
<h4 id="4-1-2-方法"><a href="#4-1-2-方法" class="headerlink" title="4.1.2 方法"></a>4.1.2 方法</h4><table>
<thead>
<tr>
<th>方法</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>prompt</td>
<td>弹出一个提示对话框（有输入框）</td>
</tr>
<tr>
<td>alert</td>
<td>弹出一个确认框</td>
</tr>
<tr>
<td>open</td>
<td>打开URL路径下的文件</td>
</tr>
<tr>
<td>close</td>
<td>关闭被引用的对话框</td>
</tr>
<tr>
<td>navigate(URL)</td>
<td>在对话框中显示URL下的文件内容</td>
</tr>
</tbody></table>
<h3 id="4-2-对话框"><a href="#4-2-对话框" class="headerlink" title="4.2 对话框"></a>4.2 对话框</h3><ol>
<li>prompt（带输入的）对话框</li>
<li>alert直接提示对话框（仅仅是提示）</li>
<li>confirm（带确认的）对话框</li>
</ol>
<h3 id="4-3-history"><a href="#4-3-history" class="headerlink" title="4.3 history"></a>4.3 history</h3><h4 id="4-3-1-属性"><a href="#4-3-1-属性" class="headerlink" title="4.3.1 属性"></a>4.3.1 属性</h4><table>
<thead>
<tr>
<th>属性</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>length</td>
<td>历史列表长度</td>
</tr>
<tr>
<td>current</td>
<td>当前文档URL（这个在火狐没有！？）</td>
</tr>
<tr>
<td>next</td>
<td>列表中下个URL</td>
</tr>
<tr>
<td>previous</td>
<td>前一个URL</td>
</tr>
</tbody></table>
<h4 id="4-3-2-方法"><a href="#4-3-2-方法" class="headerlink" title="4.3.2 方法"></a>4.3.2 方法</h4><table>
<thead>
<tr>
<th>方法</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>back</td>
<td>回到上一个URL</td>
</tr>
<tr>
<td>forward</td>
<td>去后一个（下一页）URL</td>
</tr>
<tr>
<td>go</td>
<td>进入指定页面(go(-1)==back())</td>
</tr>
</tbody></table>
<h3 id="4-4-Document文档对象"><a href="#4-4-Document文档对象" class="headerlink" title="4.4 Document文档对象"></a>4.4 Document文档对象</h3><p>常用方法及实现：</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>close</td>
<td>文档的输出流</td>
</tr>
<tr>
<td>open</td>
<td>打开一个文档并接收write和writen方法的创建页面内容</td>
</tr>
<tr>
<td>write</td>
<td>可以在文档中写入HTML语句或者JavaScript语句</td>
</tr>
<tr>
<td>writeln</td>
<td>与write一样，但是以换行符结束</td>
</tr>
<tr>
<td>createElement</td>
<td>创建一个HTML标记</td>
</tr>
<tr>
<td>getElementById</td>
<td>获取指定id的HTML标记（如果内容多则以元组形式保存，需要用[*]访问）</td>
</tr>
</tbody></table>
<h3 id="4-5-DOM（文档对象模型）"><a href="#4-5-DOM（文档对象模型）" class="headerlink" title="4.5 DOM（文档对象模型）"></a>4.5 DOM（文档对象模型）</h3><h4 id="4-5-1-DOM分层"><a href="#4-5-1-DOM分层" class="headerlink" title="4.5.1 DOM分层"></a>4.5.1 DOM分层</h4><p>如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;tr&gt;</span><br><span class="line">	&lt;th&gt;&lt;/th&gt;</span><br><span class="line">	&lt;input ... /&gt;</span><br><span class="line">&lt;tr&gt;</span><br></pre></td></tr></table></figure>
<p>这里面tr是th和input的parentNode，而返过来，input和th是tr的childNode。<br>而th和input是兄弟节点。</p>
<h4 id="4-5-2-节点属性如下："><a href="#4-5-2-节点属性如下：" class="headerlink" title="4.5.2 节点属性如下："></a>4.5.2 节点属性如下：</h4><table>
<thead>
<tr>
<th>属性</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>nodeName</td>
<td>节点名称</td>
</tr>
<tr>
<td>nodeType</td>
<td>节点的类型</td>
</tr>
<tr>
<td>nodeValue</td>
<td>节点的值，通常只应用于文本节点</td>
</tr>
<tr>
<td>parentNode</td>
<td>返回当前节点的额父节点</td>
</tr>
<tr>
<td>childNodes</td>
<td>子节点列表</td>
</tr>
<tr>
<td>firstChild</td>
<td>返回第一个子节点</td>
</tr>
<tr>
<td>lastChild</td>
<td>返回最后一个子节点</td>
</tr>
<tr>
<td>previousSibling</td>
<td>返回当前节点的前一个兄弟节点</td>
</tr>
<tr>
<td>nextSibling</td>
<td>…后一个兄弟节点</td>
</tr>
<tr>
<td>attributes</td>
<td>元素的属性列表</td>
</tr>
</tbody></table>
<h4 id="4-5-3-节点操作"><a href="#4-5-3-节点操作" class="headerlink" title="4.5.3 节点操作"></a>4.5.3 节点操作</h4><table>
<thead>
<tr>
<th>操作</th>
<th>方法</th>
</tr>
</thead>
<tbody><tr>
<td>创建</td>
<td>appendChild</td>
</tr>
<tr>
<td>插入追加</td>
<td>insertBefore(new,ref) new新节点，ref指定在哪个节点后面添加</td>
</tr>
<tr>
<td>拷贝</td>
<td>clone(bool) true深拷贝，false浅拷贝</td>
</tr>
<tr>
<td>删除</td>
<td>removeChild</td>
</tr>
<tr>
<td>替换</td>
<td>replaceChild</td>
</tr>
</tbody></table>
<h4 id="4-5-4-DHTML与相应的DOM"><a href="#4-5-4-DHTML与相应的DOM" class="headerlink" title="4.5.4 DHTML与相应的DOM"></a>4.5.4 DHTML与相应的DOM</h4><ol>
<li>innerText 返回除去标签的文本内容</li>
<li>innerHTML 返回带有HTML标签的文本内容</li>
</ol>
<h2 id="五、事件处理"><a href="#五、事件处理" class="headerlink" title="五、事件处理"></a>五、事件处理</h2><p><em>注：如同onclick这种事件我就不多讲啦！</em></p>
<h3 id="5-1-事件流"><a href="#5-1-事件流" class="headerlink" title="5.1 事件流"></a>5.1 事件流</h3><p>就是说一个事件触发后该先交给谁处理，然后再给谁，然后怎么返回。</p>
<h3 id="5-2-DOM事件模型"><a href="#5-2-DOM事件模型" class="headerlink" title="5.2 DOM事件模型"></a>5.2 DOM事件模型</h3><p>看图：<br><img src="/2019/11/24/JavaScript%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/5.1.jpg" alt><br>还可以用以下程序验证：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;!doctype html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">&lt;meta charset=<span class="string">"utf-8"</span>&gt;</span><br><span class="line">&lt;title&gt;事件处理测试&lt;<span class="regexp">/title&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;button id=<span class="string">'clickMe'</span>&gt;点了我&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">&lt;script&gt;</span></span><br><span class="line"><span class="regexp"> var buttonClick=document.getElementById('clickMe') </span></span><br><span class="line"><span class="regexp"> buttonClick.onclick=function()&#123;</span></span><br><span class="line"><span class="regexp"> console.log('我点击了button');&#125;</span></span><br><span class="line"><span class="regexp"> document.body.onclick=function()&#123;</span></span><br><span class="line"><span class="regexp"> console.log('我点击了body');&#125;</span></span><br><span class="line"><span class="regexp"> document.onclick=function()&#123;</span></span><br><span class="line"><span class="regexp"> console.log('我点击了document');&#125;</span></span><br><span class="line"><span class="regexp"> window.onclick=function()&#123;</span></span><br><span class="line"><span class="regexp"> console.log('我点击了window');&#125;</span></span><br><span class="line"><span class="regexp"> &lt;/</span>script&gt;</span><br><span class="line"> &lt;<span class="regexp">/body&gt;</span></span><br><span class="line"><span class="regexp"> &lt;/</span>html&gt;</span><br></pre></td></tr></table></figure>

<h3 id="5-3-事件对象"><a href="#5-3-事件对象" class="headerlink" title="5.3 事件对象"></a>5.3 事件对象</h3><p>当触发DOM上的某个事件时，会产生一个时间的对象。<br>如键盘信息，鼠标信息等。<br>如：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> buttonClick=<span class="built_in">document</span>.getElementById(<span class="string">'clickMe'</span>) </span><br><span class="line"> buttonClick.onclick=<span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123;</span><br><span class="line"> <span class="built_in">console</span>.log(<span class="string">'我点击了button'</span>);</span><br><span class="line"> <span class="built_in">console</span>.log(event);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其结果如下：<br><img src="/2019/11/24/JavaScript%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/5.3.jpg" alt><br>这里，event是自带的。它返回了很多信息！</p>
<p>总结：这差不多就是全部内容了。</p>
]]></content>
      <categories>
        <category>理论</category>
        <category>代码编程</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>HTML</tag>
      </tags>
  </entry>
  <entry>
    <title>工具OllyDbg的使用</title>
    <url>/2019/11/10/%E5%B7%A5%E5%85%B7OllyDbg%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h1 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h1><p>OllyDbg简称OD，是一款具有可视化界面的用户模式调试器，<a id="more"></a>结合了动态调试和静态分析，具有强大的反汇编引擎，能够识别数千个被C和Windows所使用的函数，并能将其参数注释出，能自动分析函数过程，循环语句，代码中的字符串等，非常容易上手，并且对异常的跟踪处理相当灵活，这些特性使得OllyDbg成为调试ring3级程序的首选工具，爱好者不断地修改，扩充OllyDbg，脚本执行能力和开发插件接口使得其变得越来越强大。</p>
<h1 id="二、界面构成"><a href="#二、界面构成" class="headerlink" title="二、界面构成"></a>二、界面构成</h1><h2 id="2-1-开始页面"><a href="#2-1-开始页面" class="headerlink" title="2.1 开始页面"></a>2.1 开始页面</h2><p>开始页面如图：<br><img src="/2019/11/10/%E5%B7%A5%E5%85%B7OllyDbg%E7%9A%84%E4%BD%BF%E7%94%A8/%E7%95%8C%E9%9D%A2.jpg" alt></p>
<h2 id="2-2-实验准备"><a href="#2-2-实验准备" class="headerlink" title="2.2 实验准备"></a>2.2 实验准备</h2><p>现在我编译一个很简单的C++程序（normal.exe）：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> flag = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">if</span>(flag)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"hello world!"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"you have cracked it!"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125;	</span><br><span class="line">	system(<span class="string">"pause"</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其正常输出如下：<br><img src="/2019/11/10/%E5%B7%A5%E5%85%B7OllyDbg%E7%9A%84%E4%BD%BF%E7%94%A8/%E6%AD%A3%E5%B8%B8.jpg" alt></p>
<h2 id="2-3-载入程序，解释界面"><a href="#2-3-载入程序，解释界面" class="headerlink" title="2.3 载入程序，解释界面"></a>2.3 载入程序，解释界面</h2><p>单击“File”-&gt;“open”选项，打开一个EXE文件，这次打开的是之前编译过的C++程序。</p>
<p>载入程序后的界面如下：<br><img src="/2019/11/10/%E5%B7%A5%E5%85%B7OllyDbg%E7%9A%84%E4%BD%BF%E7%94%A8/%E8%BF%90%E8%A1%8C%E7%95%8C%E9%9D%A2.jpg" alt><br>下面解释各个部分的功能含义：</p>
<ol>
<li><p>标题栏<br>显示当前线程（main）和当前运行的程序名（normal）</p>
</li>
<li><p>菜单栏</p>
</li>
<li><p>快捷入口<br>里面集成了许多系统工具，如文本编辑器(notepad)，计算器(calc)等</p>
</li>
<li><p>调试快捷键</p>
<blockquote>
<p>(1)   打开新的可执行文件[快捷键F3]<br>(2)   重新载入程序[快捷键Ctrl+F2]<br>(3)   关闭程序 [快捷键Alt+F2]<br>(4)   运行程序[快捷键F9]<br>(5)   暂停执行程序 [快捷键F12]<br>(6)   单步步入[快捷键F7]<br>(7)   单步步过[快捷键F8]<br>(8)   跟踪步入[快捷键Ctrl+F11]<br>(9)   跟踪步过[快捷键Ctrl+F12]<br>(10)  执行到返回[快捷键Ctrl+F9]<br>(11)  转到反汇编窗中口的地址(转到表达式)[快捷键Ctrl+G]</p>
</blockquote>
</li>
<li><p>窗口快捷键<br>使用OD打开目标程序后，OD会打开多个子窗口，单击各个标签按钮可以在各个子窗口之间切换，这些按钮依次对应Log窗口，Executable modules窗口，Memory窗口，Threads窗口，Windows窗口，Handles窗口，CPU窗口，Patches窗口，Call stack窗口，Breakpoints窗口，References窗口，Run trace窗口，Source窗口。</p>
</li>
<li><p>反汇编面板窗口</p>
<ul>
<li>Address列：显示被双击行地址的<strong>相对地址</strong>，再次双击返回<strong>标准地址模式</strong></li>
<li>Hex dump列:设置或取消无条件断点，对应的快捷键是“F2”键。</li>
<li>Disassembly列:调用汇编器，可直接修改汇编代码，对应的快捷键是空格键。</li>
<li>Comment列:允许增加或编辑注释，对应的快捷键是“；”键。</li>
</ul>
</li>
<li><p>寄存器面板窗口<br>寄存器面板窗口（ Registers window）显示CP各寄存器的值，支持浮点、MM和3DNow寄存器。可以单击右键或窗口标题切换显示寄存器的方式。</p>
</li>
<li><p>信息面板窗口<br>在进行动态跟踪时，信息面板窗口（Information window）将显示与指令相关的各寄存器的值、API函数调用提示和跳转提示等信息。</p>
</li>
<li><p>数据面板窗口<br>数据面板窗口（ Dump window）以十六进制和字符方式显示文件在内存中的数据。要显示指定内存地址的数据，可单击右键快捷菜单中的Go to expression命令或按“Ctrl+G”快捷键，打开地址窗口，输入地址。</p>
</li>
<li><p>栈面板窗口<br>栈面板窗口（Stack window）显示栈的内容，即ESP指向地址的内容。将数据放入栈的操作称为入栈（push），从栈中取出数据的操作称为出栈（pop）栈窗口非常重要，各API函数和子程序都利用它传递参数和变量等。</p>
</li>
</ol>
<h1 id="三、实战：运用OD"><a href="#三、实战：运用OD" class="headerlink" title="三、实战：运用OD"></a>三、实战：运用OD</h1><p>现在运用OD将一个软件（名为URLegal.exe）进行注册码破解。</p>
<h2 id="3-1-简单测试"><a href="#3-1-简单测试" class="headerlink" title="3.1 简单测试"></a>3.1 简单测试</h2><p>软件界面如下：<br><img src="/2019/11/10/%E5%B7%A5%E5%85%B7OllyDbg%E7%9A%84%E4%BD%BF%E7%94%A8/%E4%BE%8B%E5%AD%901.1.jpg" alt="软件界面"><br>点开注册页面如下：<br><img src="/2019/11/10/%E5%B7%A5%E5%85%B7OllyDbg%E7%9A%84%E4%BD%BF%E7%94%A8/%E4%BE%8B%E5%AD%901.2.jpg" alt="注册页面"><br>尝试注册（注册信息：Name:hjf 、Code:123456）：<br><img src="/2019/11/10/%E5%B7%A5%E5%85%B7OllyDbg%E7%9A%84%E4%BD%BF%E7%94%A8/%E4%BE%8B%E5%AD%901.3.jpg" alt="输入注册信息"> <img src="/2019/11/10/%E5%B7%A5%E5%85%B7OllyDbg%E7%9A%84%E4%BD%BF%E7%94%A8/%E4%BE%8B%E5%AD%901.4.jpg" alt="注册失败"></p>
<h2 id="3-2-开始逆向"><a href="#3-2-开始逆向" class="headerlink" title="3.2 开始逆向"></a>3.2 开始逆向</h2><h3 id="3-2-1-加载程序后，点击运行，运行后OD界面如下："><a href="#3-2-1-加载程序后，点击运行，运行后OD界面如下：" class="headerlink" title="3.2.1 加载程序后，点击运行，运行后OD界面如下："></a>3.2.1 加载程序后，点击运行，运行后OD界面如下：</h3><p><img src="/2019/11/10/%E5%B7%A5%E5%85%B7OllyDbg%E7%9A%84%E4%BD%BF%E7%94%A8/%E9%80%86%E5%90%911.1.jpg" alt="运行界面"></p>
<h3 id="3-2-2-查找字符串"><a href="#3-2-2-查找字符串" class="headerlink" title="3.2.2 查找字符串"></a>3.2.2 查找字符串</h3><p>由于注册失败界面有提示框，里面包含字符串，则搜索字符串，双击便可以进入实现注册判断的代码部分。<br><img src="/2019/11/10/%E5%B7%A5%E5%85%B7OllyDbg%E7%9A%84%E4%BD%BF%E7%94%A8/%E9%80%86%E5%90%911.2.jpg" alt="查找字符串"></p>
<h3 id="3-2-3-判断关键跳"><a href="#3-2-3-判断关键跳" class="headerlink" title="3.2.3 判断关键跳"></a>3.2.3 判断关键跳</h3><p>进入后视图如下：<br><img src="/2019/11/10/%E5%B7%A5%E5%85%B7OllyDbg%E7%9A%84%E4%BD%BF%E7%94%A8/%E9%80%86%E5%90%911.3.jpg" alt><br>可以看到<strong>标记1</strong>处为跳到<strong>标记2</strong>处的关键跳之一，还有另外一个关键跳为JNZ下面的<strong>JE跳</strong>，而一般而言，关键跳的前一个<strong>CALL指令</strong>为关键CALL指令，现对JNZ上的CALL指令进行断点。<br>我们还可以看到堆栈中（<strong>标记3</strong>）的内容，有我们刚输入的<strong>CODE</strong>，大概猜测是用于<strong>比较</strong>用的。</p>
<h3 id="3-2-4-找真正的关键跳"><a href="#3-2-4-找真正的关键跳" class="headerlink" title="3.2.4 找真正的关键跳"></a>3.2.4 找真正的关键跳</h3><p>由于可能的关键跳有两个，一个是JNZ一个是JE，接下来判断哪个是关键跳，下断点后运行如图：<br><img src="/2019/11/10/%E5%B7%A5%E5%85%B7OllyDbg%E7%9A%84%E4%BD%BF%E7%94%A8/%E9%80%86%E5%90%911.4.jpg" alt><br>可以看到：EAX寄存器中的值为0，则test指令执行后零标志寄存器ZF=1，JNZ不会进行跳转</p>
<blockquote>
<p>text eax,eax是与运算，只有当eax为00000000才能保证0标志位ZF=1 即满足下面的跳转。换言之，这个是测试eax是否为0，为0则跳 。</p>
</blockquote>
<p>继续进行步过(F8)，到达JE跳中（<strong>标记3</strong>），可以从下图中看到，JE下的跳转是红色的（会执行跳转），则判断JE上的CALL指令（<strong>标记2</strong>）为关键指令。<br>而且，在CALL和JE中间还有指令AND和TEST，这些都是对EAX寄存器进行操作。<br><img src="/2019/11/10/%E5%B7%A5%E5%85%B7OllyDbg%E7%9A%84%E4%BD%BF%E7%94%A8/%E9%80%86%E5%90%911.5.jpg" alt></p>
<h3 id="3-2-5-进入关键CALL"><a href="#3-2-5-进入关键CALL" class="headerlink" title="3.2.5 进入关键CALL"></a>3.2.5 进入关键CALL</h3><p>判断完关键跳为JE，则尝试进入关键CALL，如下图所示：<br><img src="/2019/11/10/%E5%B7%A5%E5%85%B7OllyDbg%E7%9A%84%E4%BD%BF%E7%94%A8/%E9%80%86%E5%90%911.6.jpg" alt="进关键CALL"><br>可以看到函数对堆栈进行push操作，可以大致肯定其用于比较操作。也就是说以下信息就是我们的正确CODE!可以直接拿来注册（经过验证是正确的）。</p>
<blockquote>
<p>0019F950   00A3A030  ASCII “0781B2666326E5574C053884D070882E”</p>
</blockquote>
<h3 id="3-2-6-爆破"><a href="#3-2-6-爆破" class="headerlink" title="3.2.6 爆破"></a>3.2.6 爆破</h3><p>既然已经发现跳转时由于EAX寄存器的值，那么可以推断是由于在关键CALL中修改了EAX导致后面的关键跳执行，则找到最后修改EAX的指令，进行NOP填充，如图：<br><img src="/2019/11/10/%E5%B7%A5%E5%85%B7OllyDbg%E7%9A%84%E4%BD%BF%E7%94%A8/%E9%80%86%E5%90%911.7.jpg" alt="爆破"><br>跳出CALL后可以看到JE不执行了<br><img src="/2019/11/10/%E5%B7%A5%E5%85%B7OllyDbg%E7%9A%84%E4%BD%BF%E7%94%A8/%E9%80%86%E5%90%911.8.jpg" alt></p>
<h3 id="3-2-7-运行成功！"><a href="#3-2-7-运行成功！" class="headerlink" title="3.2.7 运行成功！"></a>3.2.7 运行成功！</h3><p>关键跳不执行，则可以直接运行了，可以看到注册成功页面：<br><img src="/2019/11/10/%E5%B7%A5%E5%85%B7OllyDbg%E7%9A%84%E4%BD%BF%E7%94%A8/%E4%BE%8B%E5%AD%901.5.jpg" alt="破解成功"></p>
<h2 id="3-3-其他功能"><a href="#3-3-其他功能" class="headerlink" title="3.3 其他功能"></a>3.3 其他功能</h2><h3 id="3-3-1-断点查看"><a href="#3-3-1-断点查看" class="headerlink" title="3.3.1 断点查看"></a>3.3.1 断点查看</h3><p>可以在快捷菜单选择<strong>B</strong>，或者快捷键alt+b，可以看到我下的全部断点：<br><img src="/2019/11/10/%E5%B7%A5%E5%85%B7OllyDbg%E7%9A%84%E4%BD%BF%E7%94%A8/%E6%96%AD%E7%82%B9%E9%A1%B5%E9%9D%A2.jpg" alt><br>可以对断点进行Disable、Remove等操作</p>
<h3 id="3-3-2-函数参考"><a href="#3-3-2-函数参考" class="headerlink" title="3.3.2 函数参考"></a>3.3.2 函数参考</h3><p>加载程序执行后，按下快捷键ctrl+N就可以看到调用的全部函数了，如图：<br><img src="/2019/11/10/%E5%B7%A5%E5%85%B7OllyDbg%E7%9A%84%E4%BD%BF%E7%94%A8/%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E9%A1%B5%E9%9D%A2.jpg" alt><br>这样我们就可以很方便地对函数出现处进行断点：<br><img src="/2019/11/10/%E5%B7%A5%E5%85%B7OllyDbg%E7%9A%84%E4%BD%BF%E7%94%A8/%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E6%96%AD%E7%82%B9.jpg" alt></p>
<h3 id="3-3-3-内存"><a href="#3-3-3-内存" class="headerlink" title="3.3.3 内存"></a>3.3.3 内存</h3><p>通过分析上面的关键CALL指令，知道EAX是装有我们的伪CODE的地址<strong>005E9F40</strong>，则可以找到在内存中的数据如下：<br><img src="/2019/11/10/%E5%B7%A5%E5%85%B7OllyDbg%E7%9A%84%E4%BD%BF%E7%94%A8/%E5%86%85%E5%AD%98%E6%96%AD%E7%82%B9.jpg" alt><br>可以看到，我们输入的<strong>123456</strong>就在内存中。</p>
<h3 id="3-3-4-消息"><a href="#3-3-4-消息" class="headerlink" title="3.3.4 消息"></a>3.3.4 消息</h3><p>先打开注册页面，输入注册信息，不要点击确认，在OD里按下快捷菜单中的<strong>W</strong>，便可以看到注册框中的消息：<br><img src="/2019/11/10/%E5%B7%A5%E5%85%B7OllyDbg%E7%9A%84%E4%BD%BF%E7%94%A8/%E6%B6%88%E6%81%AF1.jpg" alt><br>在Vaildate My Codes字段上右击，选择消息断点，进入以下页面<br><img src="/2019/11/10/%E5%B7%A5%E5%85%B7OllyDbg%E7%9A%84%E4%BD%BF%E7%94%A8/%E6%B6%88%E6%81%AF2.jpg" alt><br>选择202左键触发<br><img src="/2019/11/10/%E5%B7%A5%E5%85%B7OllyDbg%E7%9A%84%E4%BD%BF%E7%94%A8/%E6%B6%88%E6%81%AF3.jpg" alt></p>
<p>然后开启<strong>RUN跟踪</strong></p>
<blockquote>
<p>RUN跟踪是干什么的?简单的说，RUN跟踪就是把被调试程序执行过的指令保存<br>下来，让你可以查看被调试程序运行期间干了哪些事。RUN跟踪会把地址、寄存器的内容、消息以及已知的操作数记录<br>到RUN跟踪缓冲区中，你可以通过查看RUN跟踪的记录来了解程序执行了那些指令。在这还要注意一个缓冲区大小的<br>问题，如果执行的指令太多，缓冲区满了的话，就会自动丢弃前面老的记录。</p>
</blockquote>
<p>我们可以在调试选项-&gt;跟踪中设置:<br><img src="/2019/11/10/%E5%B7%A5%E5%85%B7OllyDbg%E7%9A%84%E4%BD%BF%E7%94%A8/%E6%B6%88%E6%81%AF4.jpg" alt><br>然后设置：<br><img src="/2019/11/10/%E5%B7%A5%E5%85%B7OllyDbg%E7%9A%84%E4%BD%BF%E7%94%A8/%E6%B6%88%E6%81%AF5.jpg" alt><br>效果如下：（灰条）<br><img src="/2019/11/10/%E5%B7%A5%E5%85%B7OllyDbg%E7%9A%84%E4%BD%BF%E7%94%A8/%E6%B6%88%E6%81%AF6.jpg" alt></p>
<p>现在回到软件点击Vaildate My Codes，便可以直达断点：<br><img src="/2019/11/10/%E5%B7%A5%E5%85%B7OllyDbg%E7%9A%84%E4%BD%BF%E7%94%A8/%E6%B6%88%E6%81%AF7.jpg" alt><br>然后一步步走，会有刚输入的字符串放在堆栈和内存里的。<br><img src="/2019/11/10/%E5%B7%A5%E5%85%B7OllyDbg%E7%9A%84%E4%BD%BF%E7%94%A8/%E6%B6%88%E6%81%AF13.jpg" alt></p>
<p>现在可以呼出内存映射页面<strong>M</strong>，并在CODE代码处下断点：<br><img src="/2019/11/10/%E5%B7%A5%E5%85%B7OllyDbg%E7%9A%84%E4%BD%BF%E7%94%A8/%E6%B6%88%E6%81%AF8.jpg" alt><br>然后回到反汇编页面，运行，直达页面：<br><img src="/2019/11/10/%E5%B7%A5%E5%85%B7OllyDbg%E7%9A%84%E4%BD%BF%E7%94%A8/%E6%B6%88%E6%81%AF9.jpg" alt><br>还可以查看RUN跟踪，选择统计（profile）：<br><img src="/2019/11/10/%E5%B7%A5%E5%85%B7OllyDbg%E7%9A%84%E4%BD%BF%E7%94%A8/%E6%B6%88%E6%81%AF10.jpg" alt><br>这样就可以看到那些指令被执行过<br><img src="/2019/11/10/%E5%B7%A5%E5%85%B7OllyDbg%E7%9A%84%E4%BD%BF%E7%94%A8/%E6%B6%88%E6%81%AF11.jpg" alt><br>双击后便可以直达指令处：<br><img src="/2019/11/10/%E5%B7%A5%E5%85%B7OllyDbg%E7%9A%84%E4%BD%BF%E7%94%A8/%E6%B6%88%E6%81%AF12.jpg" alt></p>
]]></content>
      <tags>
        <tag>课程</tag>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title>汇编语言(入门学习)</title>
    <url>/2019/11/10/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80-%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<h4 id="简介：本篇旨在对汇编的基础知识进行汇总，汇总的都是要点（简明扼要），目前还在更新中。"><a href="#简介：本篇旨在对汇编的基础知识进行汇总，汇总的都是要点（简明扼要），目前还在更新中。" class="headerlink" title="简介：本篇旨在对汇编的基础知识进行汇总，汇总的都是要点（简明扼要），目前还在更新中。"></a>简介：本篇旨在对汇编的基础知识进行汇总，汇总的都是要点（简明扼要），目前还在更新中。</h4><a id="more"></a>
<h1 id="第一章-基础知识"><a href="#第一章-基础知识" class="headerlink" title="第一章 基础知识"></a>第一章 基础知识</h1><h2 id="1-1-存储单元"><a href="#1-1-存储单元" class="headerlink" title="1.1 存储单元"></a>1.1 存储单元</h2><p>一个存储单元存储的信息量以<strong>bit</strong>为单位（最小）。而转换关系中8 bit=1 bytes(B)。而一个字=两个字节<br>在微型计算机存储器的存储单元中，一个单元可以存<strong>1 B</strong>（即8个进制位）。而一个存储器有128个单元，则可以存储128 B。</p>
<h2 id="1-2-CPU对存储器的读写"><a href="#1-2-CPU对存储器的读写" class="headerlink" title="1.2 CPU对存储器的读写"></a>1.2 CPU对存储器的读写</h2><p>要读写，则应该与三类信息进行交互：</p>
<blockquote>
<ol>
<li>地址信息</li>
<li>控制信息</li>
<li>数据信息</li>
</ol>
</blockquote>
<p>而逻辑上又分为3类总线，分别传输信息：</p>
<blockquote>
<ol>
<li>地址总线（指出内存中的信息放在那里(自下而上读01)）</li>
<li>控制总线（若要传输的数据多于一次性传输的宽度，则分开来多传几次）</li>
<li>数据总线</li>
</ol>
</blockquote>
<h3 id="1-2-1-影响性能的因素："><a href="#1-2-1-影响性能的因素：" class="headerlink" title="1.2.1 影响性能的因素："></a>1.2.1 影响性能的因素：</h3><h4 id="宽度（线的条数）：它决定了部件的能力（速度，控制能力等）。8086为16条，8088为8条"><a href="#宽度（线的条数）：它决定了部件的能力（速度，控制能力等）。8086为16条，8088为8条" class="headerlink" title="宽度（线的条数）：它决定了部件的能力（速度，控制能力等）。8086为16条，8088为8条"></a>宽度（线的条数）：它决定了部件的能力（速度，控制能力等）。8086为16条，8088为8条</h4><blockquote>
<p>若CPU的寻址能力为8KB，则总线宽度：8*1024/1 = $2^13$ (注意单位是B,13则为总线宽度)</p>
</blockquote>
<h1 id="第二章-寄存器"><a href="#第二章-寄存器" class="headerlink" title="第二章 寄存器"></a>第二章 寄存器</h1><h2 id="2-1-通用寄存器"><a href="#2-1-通用寄存器" class="headerlink" title="2.1 通用寄存器"></a>2.1 通用寄存器</h2><p>有<strong>AX BX CX DX</strong>四种，它们分为高位和低位以兼容以前的程序，如（AX = AH(高) + AL(低)）<br><em>要注意的是：若只用AL进行运算，若超出其范围，超出的数据不会到AH当中！</em></p>
<h2 id="2-2-CPU给出物理地址的方法"><a href="#2-2-CPU给出物理地址的方法" class="headerlink" title="2.2 CPU给出物理地址的方法"></a>2.2 CPU给出物理地址的方法</h2><blockquote>
<p>段地址(<strong>SA</strong>)：只是为了内存的管理，并不是真分段。16位地址分段，一段64KB<br>偏移地址(<strong>EA</strong>)：16位地址最多64KB<br>公式：物理地址=段地址*16+偏移地址</p>
</blockquote>
<h2 id="2-3-段寄存器"><a href="#2-3-段寄存器" class="headerlink" title="2.3 段寄存器"></a>2.3 段寄存器</h2><p>有<strong>CS DS SS ES</strong>四种。CS常存储段地址。它们提供了一下功能：</p>
<ol>
<li>CS：CPU要<strong>执行指令</strong>的地址。相当于命令指针</li>
<li>DS：读取内存的地址（返回数据）。相当于数据指针</li>
<li>SS：存储内存中的栈的顶。相当于栈顶指针</li>
</ol>
<h3 id="2-3-1-CS和IP"><a href="#2-3-1-CS和IP" class="headerlink" title="2.3.1 CS和IP"></a>2.3.1 CS和IP</h3><p>IP是存储基于CS的偏移量。修改的流程：</p>
<blockquote>
<p>一般流程：读取指令 -&gt; 修改 IP+=<em>命令长度</em> -&gt; 执行指令(可能会涉及修改CS:IP) -&gt; 读取指令…<br><em>8086PC启动时在FFFF0H单元中读取指令执行</em></p>
</blockquote>
<h2 id="2-4-疑问"><a href="#2-4-疑问" class="headerlink" title="2.4 疑问"></a>2.4 疑问</h2><h3 id="1-为什么偏移地址只能在64Kb内？"><a href="#1-为什么偏移地址只能在64Kb内？" class="headerlink" title="1. 为什么偏移地址只能在64Kb内？"></a>1. 为什么偏移地址只能在64Kb内？</h3><p>一个16位的CPU，只能有1111 1111 1111 1111，代表了4个16进制数，所以能表示2**16 bit的数据，恰好，就是64Kb。</p>
<h3 id="2-暂留"><a href="#2-暂留" class="headerlink" title="2.暂留"></a>2.暂留</h3><h1 id="第三章-寄存器（内存访问）"><a href="#第三章-寄存器（内存访问）" class="headerlink" title="第三章 寄存器（内存访问）"></a>第三章 寄存器（内存访问）</h1><h2 id="3-1-内存中字的存储"><a href="#3-1-内存中字的存储" class="headerlink" title="3.1 内存中字的存储"></a>3.1 内存中字的存储</h2><blockquote>
<p>字单元的概念：即存放一个字型数据的内存单元，由<strong>两个地址连续</strong>的内存单元（一个8位）组成。高放高位，低放低位。</p>
</blockquote>
<p>这里解释一下： 若有单元[0]-&gt;2e，[1]-&gt;33，那么我们读[0]的字型数据为：332eH（高放高位）</p>
<h2 id="3-2-DS和-address"><a href="#3-2-DS和-address" class="headerlink" title="3.2 DS和[address]"></a>3.2 DS和[address]</h2><blockquote>
<p>“[…]”表示一个内存单元，表示在段地址下的偏移量。如10000H = 1000:0 = [0]</p>
</blockquote>
<ul>
<li><p>在masm汇编编辑器中，如果单纯写mov ax,[0]，那么他会把[0]当做0来解释，即指令变成：mov ax,0<br>而若用bx作为中转，那是可以的！如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mov bx,0</span><br><span class="line">mov ax,[bx]</span><br></pre></td></tr></table></figure>
<p>这个是可以把[bx]当成段地址，返回ds:bx下的数据的！<br>而如果偏要用[idata]的话，那么就必须加上<strong>ds:</strong>前缀，如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mov ax,ds:[0]</span><br></pre></td></tr></table></figure>
</li>
<li><p>而对于Debug编译器的话，ds是自动加上的，用</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mov ax,[0]</span><br></pre></td></tr></table></figure>
<p>即可，如果使用[]的话，而且他（段寄存器）是不能直接用mov命令改变的，必须通过其他的寄存器中转才能改变。</p>
</li>
</ul>
<h2 id="3-3-字的传送（mov指令）"><a href="#3-3-字的传送（mov指令）" class="headerlink" title="3.3 字的传送（mov指令）"></a>3.3 字的传送（mov指令）</h2><p>在传送字之后， DS和[address]也会跟着变，如1000:0，若传入一个fffeH，则address会从0-&gt;2，此时，[0]存有feH，[1]存有ffH,[2]为空。</p>
<h2 id="3-4-mov、add、sub指令"><a href="#3-4-mov、add、sub指令" class="headerlink" title="3.4 mov、add、sub指令"></a>3.4 mov、add、sub指令</h2><p>主要是说说置零问题，与机械码长度问题，稍微提一下，以后会细讲。<br>举例子：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sub bx, bx</span><br><span class="line">mov bx, 0</span><br></pre></td></tr></table></figure>
<p>两个都是可以将bx寄存器置零的指令，但是sub的机械码长度为2，而mov为3，用sub更好。<br>另外说说jmp指令，他是转移指令，具有一个操作对象的指令，而上面的具有两个。</p>
<h2 id="3-5-栈"><a href="#3-5-栈" class="headerlink" title="3.5 栈"></a>3.5 栈</h2><p>他是一个FILO结构（先入后出），而且是从大变小（地址）。</p>
<h3 id="3-5-1-push和pop"><a href="#3-5-1-push和pop" class="headerlink" title="3.5.1 push和pop"></a>3.5.1 push和pop</h3><blockquote>
<p>执行push ax命令，会把ax中的数据传入ss:sp指向的地址空间。此时<strong>sp-=2</strong><br>执行pop ax命令，会把ss:sp指向的地址空间中的数据传给ax。此时<strong>sp+=2</strong></p>
</blockquote>
<p>执行之后的指针变化：</p>
<ul>
<li>push先令sp-=2，然后将ax中的数据放进去。称为出栈。</li>
<li>pop是先取出数据放到ax中，再sp+=2。称为入栈。</li>
</ul>
<p><img src="/2019/11/10/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80-%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0/3.5.png" alt></p>
<h3 id="3-5-2-数据传输"><a href="#3-5-2-数据传输" class="headerlink" title="3.5.2 数据传输"></a>3.5.2 数据传输</h3><p>如8086cpu的入栈和出栈都是以<strong>字</strong>为单位进行的。</p>
<h3 id="3-5-3-栈指针"><a href="#3-5-3-栈指针" class="headerlink" title="3.5.3 栈指针"></a>3.5.3 栈指针</h3><p>上面已经用到了：段寄存器:寄存器存储(ss:sp)<br>sp是指偏移地址，ss:sp始终指向栈顶。</p>
<h2 id="3-6-栈顶越界问题"><a href="#3-6-栈顶越界问题" class="headerlink" title="3.6 栈顶越界问题"></a>3.6 栈顶越界问题</h2><p>栈溢出问题都是大问题，如果栈顶越界了，那么执行push和pop会受影响吗？当然不会！直接刚，写！写！写！出！出！出！管你呢。<br>所以就会有可能读了其他程序的数据，或者<strong>修改了（覆盖）</strong>其他程序的数据（直接崩溃的说）<br>执行情况（取自《汇编语言第二版》王爽著）<br><img src="/2019/11/10/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80-%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0/3.6.jpg" alt></p>
<h2 id="3-7-问题"><a href="#3-7-问题" class="headerlink" title="3.7 问题"></a>3.7 问题</h2><h3 id="1-程序与数据有区别吗？"><a href="#1-程序与数据有区别吗？" class="headerlink" title="1.程序与数据有区别吗？"></a>1.程序与数据有区别吗？</h3><p>可以说有，也可以说没有。由于指令都是0和1组成的，只是用不同功能的段地址读出来的不一样，如,CS和DS都指向10000H，那么，CS会将里头的数据转化为机械码，执行指令，而DS就直接读数据，作为单纯的数据使用。</p>
<h3 id="2-空栈如（10000H-1000FH）此时ss-1000H，那么sp是多少？"><a href="#2-空栈如（10000H-1000FH）此时ss-1000H，那么sp是多少？" class="headerlink" title="2.空栈如（10000H~1000FH）此时ss=1000H，那么sp是多少？"></a>2.空栈如（10000H~1000FH）此时ss=1000H，那么sp是多少？</h3><p>因为是自下而上（自大到小），所以sp=0010H。<br>换一种方式看，若存储了一个数据，则一个存到000EH，一个存到000FH，此时的栈指针在栈顶，当然指向000EH了，此时是已经让sp-=2了，那么回溯一下，不就有sp=0010H了。</p>
<ul>
<li>好了，问题来了，如果将（10000H~1FFFFH）作为空间呢？<br>答案：sp=0000H，因为，不能变成10000H(笑)</li>
</ul>
<h3 id="3-栈会溢出，那么，为什么不设置栈大小"><a href="#3-栈会溢出，那么，为什么不设置栈大小" class="headerlink" title="3.栈会溢出，那么，为什么不设置栈大小"></a>3.栈会溢出，那么，为什么不设置栈大小</h3><p>emmm，可惜8086cpu就是没有，所以变成自己注意。</p>
<h3 id="4-只有mov可以完成传输数据吗？"><a href="#4-只有mov可以完成传输数据吗？" class="headerlink" title="4.只有mov可以完成传输数据吗？"></a>4.只有mov可以完成传输数据吗？</h3><p>push也可以哦，只要把sp定位为ds:[address]那就好了哦。直接写进去。</p>
<h1 id="第四章-第一个程序"><a href="#第四章-第一个程序" class="headerlink" title="第四章 第一个程序"></a>第四章 第一个程序</h1><h2 id="4-1-一个源程序从写出到执行的过程"><a href="#4-1-一个源程序从写出到执行的过程" class="headerlink" title="4.1 一个源程序从写出到执行的过程"></a>4.1 一个源程序从写出到执行的过程</h2><p>执行过程包括：写程序-&gt;编译连接成可执行文件-&gt;执行。</p>
<blockquote>
<p>可执行文件文件中包括以下两部分：</p>
</blockquote>
<ol>
<li>程序和数据</li>
<li>相关的描述：程序多大，占用多少运行空间</li>
</ol>
<h2 id="4-2-源程序"><a href="#4-2-源程序" class="headerlink" title="4.2 源程序"></a>4.2 源程序</h2><h3 id="4-2-1-伪指令"><a href="#4-2-1-伪指令" class="headerlink" title="4.2.1 伪指令"></a>4.2.1 伪指令</h3><p>也就是只能被编译器识别的指令，如<strong>assume</strong>、<strong>segment</strong>、<strong>end</strong>等，<strong><em>这是没有机械码的</em></strong>。<br>一般的伪指令使用如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">assume cs:code  #声明（假设）cs:段名（标号）</span><br><span class="line">code segment	#段名 segment</span><br><span class="line">_指令_</span><br><span class="line">code ends		#对应segment，表示一个段结束</span><br><span class="line">end				#对应assume，表示程序结束</span><br></pre></td></tr></table></figure>

<h3 id="4-2-2-程序返回"><a href="#4-2-2-程序返回" class="headerlink" title="4.2.2 程序返回"></a>4.2.2 程序返回</h3><p>现在考虑，如何让上一个程序把CPU控制权交给写一个程序，这时候就要使用<strong>程序返回</strong><br>其代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mov ax, 4c00H</span><br><span class="line">int 21H</span><br></pre></td></tr></table></figure>
<h2 id="4-3-程序生成流程"><a href="#4-3-程序生成流程" class="headerlink" title="4.3 程序生成流程"></a>4.3 程序生成流程</h2><p><strong>编程 -&gt; <em>1.asm</em> -&gt; 编译 -&gt; <em>1.obj</em> -&gt; 连接 -&gt; <em>1.exe</em> -&gt; 加载 -&gt; <em>内存中的程序</em> -&gt; 运行</strong><br>注：加载就是将程序加载到内存，执行就是在内存中执行程序的指令</p>
<h2 id="4-4-怎么装载程序？"><a href="#4-4-怎么装载程序？" class="headerlink" title="4.4 怎么装载程序？"></a>4.4 怎么装载程序？</h2><p>操作系统是一个模块组成庞大的系统。任何通用的系统都要提供一个称为shell的程序，用户使用这个程序来操作计算机系统进行工作。</p>
<p>如DOS中有一个程序command.com，这个程序称为：命令解释器，也就是DOS中的SHELL<br>（其实跟我们的cmd.exe差不多）</p>
<p>先运行shell，然后在加载1.exe可执行程序的时候，cmd会自动把cpu的控制权交给1.exe，执行完成再返回cmd。</p>
<h2 id="4-4-展示EXE的加载过程"><a href="#4-4-展示EXE的加载过程" class="headerlink" title="4.4 展示EXE的加载过程"></a>4.4 展示EXE的加载过程</h2><p><img src="/2019/11/10/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80-%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0/4.4.png" alt></p>
<h1 id="第五章-BX-和loop指令"><a href="#第五章-BX-和loop指令" class="headerlink" title="第五章 [BX]和loop指令"></a>第五章 [BX]和loop指令</h1><h2 id="5-1-BX"><a href="#5-1-BX" class="headerlink" title="5.1 [BX]"></a>5.1 [BX]</h2><p>这个之前就讲过：其实就是把BX中的值作为ds的偏移地址EA，然后可以用这个来访问特定地址下的数据。<br>如ds:1000H，bx=0001H，那么[BX]就是指ds*16+bx下的值。</p>
<h2 id="5-2-loop"><a href="#5-2-loop" class="headerlink" title="5.2 loop"></a>5.2 loop</h2><p>直接上程序：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">assume cs:eloop</span><br><span class="line">eloop segment</span><br><span class="line">	mov ax,128</span><br><span class="line">	mov cx,36</span><br><span class="line">  s:add ax,ax</span><br><span class="line">	loop s</span><br><span class="line">eloop ends</span><br><span class="line">end</span><br></pre></td></tr></table></figure>
<p>解释：</p>
<ol>
<li>loop是按照cx当中的值进行对有标号的s下的命令进行循环的。当cx不等于0，则执行循环，这个程序实际上是实现128*36的程序。</li>
<li>s实际上是IP值，指向s标记的地址，所以loop s实际上是给IP赋值：IP=s，然后就可以通过cs:ip来执行指令了</li>
</ol>
<blockquote>
<p>注意：汇编程序中，数据不能以字母开头，所以要在前面加个0。比如：9138h可以写成9138h，而A000h就必须写成0A000h</p>
</blockquote>
<h2 id="5-3-loop和-bx-的联合运用"><a href="#5-3-loop和-bx-的联合运用" class="headerlink" title="5.3 loop和[bx]的联合运用"></a>5.3 loop和[bx]的联合运用</h2><p>例如来一个如同C++语言中的：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int dx = 0;</span><br><span class="line">int ds[12] = &#123;1, 2, ...&#125;;</span><br><span class="line">for(int i=0; i &lt; 12; i++)</span><br><span class="line">&#123;</span><br><span class="line">	dx += ds[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>那么汇编语言就有：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">assume cs:code</span><br><span class="line">code segment:</span><br><span class="line">	mov ax, 0ffffh	;因为ds寄存器不能直接赋值，所以用ax作为中间变量</span><br><span class="line">	mov ds,ax		</span><br><span class="line">	mov bx,0		;初始化ds:bx指向ffff:0</span><br><span class="line"></span><br><span class="line">	mov dx,0		;初始化**累加寄存器**dx，让值为0</span><br><span class="line"></span><br><span class="line">	mov cx,12		;初始化循环计数寄存器cx，令值为12，指循环12次</span><br><span class="line"></span><br><span class="line"> s: mov al,[bx]		;以下两步执行ax的赋值操作</span><br><span class="line">	mov ah,0		;</span><br><span class="line">	add dx,ax		;执行加法</span><br><span class="line">	inc bx			;ds:bx指向下一个单元，因为bx的值增加了1，相当于C++代码中的*i++*</span><br><span class="line">	loop s			;loop完成一次，则cx=cx-1，然后判断cx是否等于0，如果等于则退出循环</span><br><span class="line"></span><br><span class="line">	mov ax,4c00h</span><br><span class="line">	int 21h</span><br><span class="line"></span><br><span class="line">code ends</span><br><span class="line">end</span><br></pre></td></tr></table></figure>
<p>好了，现在来说说这段代码里面有什么需要注意的点：</p>
<ol>
<li>cx寄存器一般用作loop循环的判断条件，即<strong>循环的粗次数</strong>。</li>
<li>ax寄存器的初始化有两步，是，因为一个字符型数据是8位这样的话转化为16位就得让高8位的值赋为0。</li>
<li>dx寄存器是常用的累加寄存器。</li>
<li>inc指令是让后面的值加一的指令，相当于C++语言中的‘++’自增。</li>
<li>int指令：<blockquote>
<p>由int 指令引发的中断是一种重要的内中断。<br>格式： int n   //相当于引发一个n号中断的过程,最终功能和call指令相似，都是调用一段程序。</p>
<ul>
<li>取中断类型码n</li>
<li>标志寄存器入栈，并IF=0,TF=0      //TF=0使得避免中断程序执行过程中引发单步中断</li>
<li>CS,IP寄存器入栈</li>
<li>IP=(n*4) , CS=(n*4 + 2)<br><a href="https://blog.csdn.net/u010034085/article/details/97819727" target="_blank" rel="noopener">原文链接</a></li>
</ul>
</blockquote>
</li>
</ol>
<h2 id="5-4-段前缀与其使用"><a href="#5-4-段前缀与其使用" class="headerlink" title="5.4 段前缀与其使用"></a>5.4 段前缀与其使用</h2><blockquote>
<ul>
<li>能够显示地指令内存单元的段地址的，如：”ds:”、”cs:”、”ss:”、”es:”。这就是段前缀。</li>
<li>默认的[x]是指：(dx*16)+x，而如果要用其他的段寄存器，则需要加上它的段前缀。 </li>
</ul>
</blockquote>
<h1 id="第六章-包含多个段的程序"><a href="#第六章-包含多个段的程序" class="headerlink" title="第六章 包含多个段的程序"></a>第六章 包含多个段的程序</h1><blockquote>
<p>由于软件是由数据和程序组成的，数据当然也是程序里面必不可少的部分，所以会将代码分为多段进行，如数据段、代码段等。</p>
</blockquote>
<h2 id="6-1-在代码段中使用数据"><a href="#6-1-在代码段中使用数据" class="headerlink" title="6.1 在代码段中使用数据"></a>6.1 在代码段中使用数据</h2><blockquote>
<p><strong>汇编程序若没有特殊的说明（或者注明在哪里开始），则默认从头开始！</strong><br>所以，一旦你的程序头部有数据，则将会把头部的数据翻译为<strong>机器码</strong>执行。(冤)</p>
</blockquote>
<p>那么解决方式是：在开始执行代码的地方加上 <strong>start:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">assume cs:code</span><br><span class="line">code segment</span><br><span class="line">  dw 0123h,0456h,0789h ;这里是数据部分 dw意思是定义字符型数据</span><br><span class="line">  start: mov bx,0   ;注意，从这开始，标识为start!</span><br><span class="line">         mov ax,0</span><br><span class="line"></span><br><span class="line">         mov cx,8</span><br><span class="line">	  s: add ax,cs:[bx]	;用cs作为段地址，取数据！</span><br><span class="line">         add bx,2</span><br><span class="line">         loop s</span><br><span class="line">         </span><br><span class="line">         mov ax,4c00h</span><br><span class="line">         int 2h</span><br><span class="line">code ends</span><br><span class="line">end start   ;注意end后面要加上end开始的名称！</span><br></pre></td></tr></table></figure>

<h2 id="6-2-将数据、代码、栈放入不同的段"><a href="#6-2-将数据、代码、栈放入不同的段" class="headerlink" title="6.2 将数据、代码、栈放入不同的段"></a>6.2 将数据、代码、栈放入不同的段</h2><p>上面说了，代码从哪里开始就在哪里加上<strong>start</strong>，结束就用<strong>end start</strong>（其他标识也行）<br>好，记住，那是代码，别把接下来说的混淆了。</p>
<p>不同的段可以放不同的东西，例如数据，代码等等。<br>只要记住将段名end了再定义其他段。也只有定义了，才能使用这个段</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">assume cs:b,ds:a,ss:c</span><br><span class="line">a segment</span><br><span class="line">    dw 0123h, 0456h, 0789h, 0abch, 0de fh, Ofedh, 0cbah, 0987h</span><br><span class="line">a ends</span><br><span class="line"></span><br><span class="line">c segment</span><br><span class="line">    dw 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0</span><br><span class="line">c ends</span><br><span class="line"></span><br><span class="line">b segment</span><br><span class="line">d:  mov ax,c  ;使用段c中的数据</span><br><span class="line">    mov ss,ax</span><br><span class="line">    mov sp, 20h  ;希望用c段当作栈空间，设置ss:sp指向c:20</span><br><span class="line"></span><br><span class="line">    mov ax,a	;使用段a</span><br><span class="line">    mov ds,ax  ;希望用ds:bx访问a段中的数据，ds指向a段</span><br><span class="line">    mov bx,0  ;ds:bx指向a段中的第一一个单元</span><br><span class="line">    mov Cx,8</span><br><span class="line"></span><br><span class="line">s:  push [bx]</span><br><span class="line">    add bx,2</span><br><span class="line">    1oop s   ;以上将a段中的0~15单元中的8个字型数据依次入栈</span><br><span class="line"></span><br><span class="line">    mov bx,0</span><br><span class="line">    mov cx, B</span><br><span class="line">s0:	pop [bx]</span><br><span class="line">    add bx,2</span><br><span class="line">    1oop s0  ;以上依次出栈8个字型数据到a段的0~15单元中</span><br><span class="line"></span><br><span class="line">    mov ax, 4c00hint 21h</span><br><span class="line">b ends</span><br><span class="line"></span><br><span class="line">end d  ;d处是要执行的第一- 条指令，即程序的入口</span><br></pre></td></tr></table></figure>
<h1 id="第七章-更灵活的定位内存地址的方法"><a href="#第七章-更灵活的定位内存地址的方法" class="headerlink" title="第七章 更灵活的定位内存地址的方法"></a>第七章 更灵活的定位内存地址的方法</h1><p>之前的[0]和[bx]均可以起到定位的作用，现在有更灵活的定位方式：</p>
<h2 id="7-1-and和or指令"><a href="#7-1-and和or指令" class="headerlink" title="7.1 and和or指令"></a>7.1 and和or指令</h2><blockquote>
<p>and是有零变零，而or是有一变一<br>也可以想象成and是乘法，or是加法</p>
</blockquote>
<h2 id="7-2-以字符型给出数据"><a href="#7-2-以字符型给出数据" class="headerlink" title="7.2 以字符型给出数据"></a>7.2 以字符型给出数据</h2><p>凡是以’…’形式给出数据的，都被译为是字符型数据，这样，编译器会将里面的数据变成ASCII码值。具体实例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">db &apos;unIX&apos;</span><br><span class="line">mov al,&apos;a&apos;</span><br></pre></td></tr></table></figure>
<p>这里被译为</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">db 75H,6EH,49H,58H</span><br><span class="line">mov al,61H</span><br></pre></td></tr></table></figure>
<p>而大小写转换的方法有两种：</p>
<ol>
<li>基于比较的，在ASCII码中，大写字母+20H=小写字母</li>
<li>基于二进制数的，在ASCII表达字符时，若第五位为0，则为大写字母；若第五位为1则为小写字母（这里可以用or或者and来进行转换）</li>
</ol>
<h2 id="7-3-以-bx-idata-的方式寻址"><a href="#7-3-以-bx-idata-的方式寻址" class="headerlink" title="7.3 以[bx+idata]的方式寻址"></a>7.3 以[bx+idata]的方式寻址</h2><p>现在以例题进行解析，将第一组字符串变成大写，第二组变成小写</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">assume cs:codesg,ds:datasg</span><br><span class="line">datasg segment</span><br><span class="line">  db &apos;BaSiC&apos;</span><br><span class="line">  db &apos;MinIX&apos;</span><br><span class="line">datasg ends</span><br><span class="line">codesg segment</span><br><span class="line">start:			;代码段</span><br><span class="line">codesg ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure>
<ul>
<li>原来的思想：取[bx]中的字符，再对其进行and 11011111b操作，再放回去，然后将bx自增，再重新···，而变成小写就or 00100000b。（这里要执行两次循环啊，一个变大写，一个变小写）</li>
<li>然而我们可以使用以下思想，更加便捷，就是[bx+idata]：思想和前面的一样，但是，不用执行两次循环，只要一次就够了：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">  mov ax,datasg</span><br><span class="line">  mov ds, ax</span><br><span class="line">  mov bx,0</span><br><span class="line">  </span><br><span class="line">  mov cx,5</span><br><span class="line">s:mov al,[bx]      ;定位第一个字符串的第bx个字符</span><br><span class="line">  and al,11011111b ;执行完变大工作</span><br><span class="line">  mov [bx],al      ;放回去</span><br><span class="line">  mov al[5+bx]     ;定位第二个字符串的第bx个字符（因为一个字符串只有5个字符）</span><br><span class="line">  or al,00100000b  ;执行变小工作</span><br><span class="line">  mov [5+bx],al    ;放回去</span><br><span class="line">  inc bx           ;自增</span><br><span class="line">  loop s</span><br></pre></td></tr></table></figure>
这个其实，学过高级语言都知道这方法，只不过，没想到汇编也能做吧，汇编语言也不是那么死板的。</li>
</ul>
<h2 id="7-4-si与di寄存器和多重循环"><a href="#7-4-si与di寄存器和多重循环" class="headerlink" title="7.4 si与di寄存器和多重循环"></a>7.4 si与di寄存器和多重循环</h2><p>这个只要知道是16位寄存器，功能和bx差不多，可以用作[bx+si+idata]和[bx+di+idata]就可以了。其中，idata是常量，其他的为变量。这个结构可以执行二重循环，相当于处理二维数组。<br>需要注意的是二重循环的实现：</p>
<blockquote>
<ul>
<li>问题一：cx寄存器是用作循环的判定条件的，那么二重循环对于没有两个cx的我们来说，如何是好？<br>将之前的cx用其他寄存器保存起来啊！</li>
<li>问题二：二重循环可以那样做，那么多重循环呢！？你只有有限个寄存器。<br>利用内存空间！开辟一段dw 0，让后指向它，放进去就完事了。</li>
<li>问题三：那这个方法的前提是我得知道有多少个循环，很麻烦啊，换个简单的。</li>
<li><em>在需要暂存数据的时候我们都应该使用栈*</em></li>
<li><em>在需要暂存数据的时候我们都应该使用栈*</em></li>
<li><em>在需要暂存数据的时候我们都应该使用栈*</em><br>按顺序push，然后逆向按顺序pop</li>
</ul>
</blockquote>
<h1 id="第八章-数据处理的两个基本问题"><a href="#第八章-数据处理的两个基本问题" class="headerlink" title="第八章 数据处理的两个基本问题"></a>第八章 数据处理的两个基本问题</h1><p>这两个问题是：</p>
<ol>
<li><strong>处理的数据在什么地方</strong></li>
<li><strong>要处理的数据有多长</strong></li>
</ol>
<h2 id="8-1-bx、si、di和bp"><a href="#8-1-bx、si、di和bp" class="headerlink" title="8.1 bx、si、di和bp"></a>8.1 bx、si、di和bp</h2><p>这几个都用过，主要说说bp:这个只要在[…]里使用了它，没有段地址声明，那么默认是<strong>ss</strong></p>
<h2 id="8-2-机器指令处理的数据在什么地方"><a href="#8-2-机器指令处理的数据在什么地方" class="headerlink" title="8.2 机器指令处理的数据在什么地方"></a>8.2 机器指令处理的数据在什么地方</h2><p><strong>在指令执行前</strong>，所要处理的数据可以在三个地方：</p>
<ol>
<li>CPU内部</li>
<li>内存</li>
<li>端口<br>下面举例子：<br><img src="/2019/11/10/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80-%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0/8.1.png" alt><br>上图还表明了汇编语言中数据位置的表达</li>
<li>立即数（idata）：如上图的最后一个例子，是直接赋值的</li>
<li>寄存器：如上图的第二个例子，使用寄存器名。</li>
<li>段地址：如果是[bx]则默认段地址是ds，如果是[bp]则默认段地址为ss，当然可以显性给出。</li>
</ol>
<h2 id="8-3-指令处理的数据长度"><a href="#8-3-指令处理的数据长度" class="headerlink" title="8.3 指令处理的数据长度"></a>8.3 指令处理的数据长度</h2><p>这个得看具体例子。</p>
<ol>
<li>如果是ax,bx，那么这个就是字操作</li>
<li>如说是al,bl，那么就是字节操作</li>
<li>在没有寄存器名存在的情况下，用操作符X ptr指明内存单元的长度，X在汇编中可以为word或byte（且必须显式声明）。</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mov word ptr ds:[0],1	;字</span><br><span class="line">mov byte ptr ds:[0],1	;字节</span><br></pre></td></tr></table></figure>
<ol start="4">
<li>有些指令默认了访问的是字还是字节，如<strong>push</strong>默认进行<strong>字</strong>操作，而用[…]的是字单元操作(一个8位)。</li>
</ol>
<h2 id="8-4-div指令"><a href="#8-4-div指令" class="headerlink" title="8.4 div指令"></a>8.4 div指令</h2><p>div是除法指令，使用div做除法的时候应注意以下问题.</p>
<ol>
<li>除数:有8位和16位两种，在<strong>一个reg</strong>或<strong>内存单元</strong>中。</li>
<li>被除数:默认放在<strong>AX</strong>或<strong>DX和AX</strong>中<ol>
<li>如果除数为8位，<strong>被除数则为16位</strong>，<strong>默认在AX</strong>中存放；</li>
<li>如果除数为16位，<strong>被除数则为32位</strong>，在DX和AX中存放，<strong>DX存放高16位，AX存放低16位</strong>。</li>
</ol>
</li>
<li>结果:<ol>
<li>如果<strong>除数为8位</strong>，则AL存储除法操作的商，AH存储除法操作的余数:</li>
<li>如果<strong>除数为16位</strong>，则AX存储除法操作的商，DX存储除法操作的余数。</li>
</ol>
</li>
</ol>
<p>格式如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">div reg</span><br><span class="line">div 内存单元</span><br><span class="line">div byte ptr ds:[0]</span><br><span class="line">含义：(al)=(ax)/((ds)*16+0)的商</span><br><span class="line">	 (ah)=(ax)/((ds)*16+0)的余数</span><br></pre></td></tr></table></figure>
<h2 id="8-5-实例"><a href="#8-5-实例" class="headerlink" title="8.5 实例"></a>8.5 实例</h2><p>利用除法指令计算100001/100<br>分析：</p>
<ol>
<li>由于100001大于整数最大值（16位）65535，不能用ax寄存器存放，所以只能用dx和ax两个寄存器联合存放，共32位</li>
<li>而出书100小于255（8位），但是因为被除数是32位，所以除数应该用16位的来存放除数100<br>所以有程序：</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mov dx,1</span><br><span class="line">mov ax,86A1H	;(dx)*10000H+(ax)=100001   100001=186A1H</span><br><span class="line">mov bx,100</span><br><span class="line">div bx</span><br></pre></td></tr></table></figure>

<p>执行后，(ax)=03E8H(即10000)，(dx)=1(余数为1)。</p>
<h2 id="8-6-伪指令dd"><a href="#8-6-伪指令dd" class="headerlink" title="8.6 伪指令dd"></a>8.6 伪指令dd</h2><p>之前有学过用db和dw定义字节型数据和字型数据。dd是用来定义dword（double word，双字）型数据的。</p>
<ul>
<li>db 占1个字节</li>
<li>dw 占1个字（即两个字节）</li>
<li>db 占2个字（即四个字节）</li>
</ul>
<h2 id="8-7-dup"><a href="#8-7-dup" class="headerlink" title="8.7 dup"></a>8.7 dup</h2><p>dup是一个操作符，在汇编语言中与dw,db,dd一样，都是由编译器识别处理的符号，且与它们一同配合使用，用来进行数据重复。<br>如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">db 3 dup (0)</span><br><span class="line">定义了3个字节，它们的值都是0，相当于执行了 db 0,0,0。</span><br><span class="line"></span><br><span class="line">db 3 dup (1,2,3)</span><br><span class="line">定义了3\*3=9个字节，它们是0、1、2、0、1、2、0、1、2，相当于db 0,1,2,0,1,2,0,1,2。</span><br><span class="line">字符型也适用。</span><br><span class="line"></span><br><span class="line">总结：</span><br><span class="line">d？ 重复的次数 dup (重复的(字节/字/双字型)数据）</span><br></pre></td></tr></table></figure>

<h1 id="第九章-转移指令的原理"><a href="#第九章-转移指令的原理" class="headerlink" title="第九章 转移指令的原理"></a>第九章 转移指令的原理</h1><p><strong>可以修改IP 或同事修改CS和IP的指令统称为转移指令统称为转移指令</strong>。如jmp、jno等，即可以控制CPU指令内存中某处代码的指令。<br>具体分类有：</p>
<ol>
<li>无条件转移指令（jmp）</li>
<li>条件转移指令（jno）</li>
<li>循环指令（loop）</li>
<li>过程</li>
<li>中断</li>
</ol>
<p>还有其他的分类：</p>
<ol>
<li><p>只修改IP：段内转移（jmp ax）</p>
</li>
<li><p>同时修改CS和IP：段间转移（jmp 1000:0）</p>
</li>
<li><p>短转移</p>
</li>
<li><p>近转移</p>
</li>
</ol>
<h2 id="9-1-操作符offset"><a href="#9-1-操作符offset" class="headerlink" title="9.1 操作符offset"></a>9.1 操作符offset</h2><p>offset是编译器处理符号，功能：取得标号的额编译地址。<br>如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">start: mov ax, offset start	;相当于mov ax,0</span><br><span class="line">	s: mov ax, offset s		;相当于mov ax,3</span><br></pre></td></tr></table></figure>
<p>解析：第一条指令mov … 是三个字节，所以s段的offset为3</p>
<h2 id="9-2-jmp指令和依据译为进行转移的jmp指令"><a href="#9-2-jmp指令和依据译为进行转移的jmp指令" class="headerlink" title="9.2 jmp指令和依据译为进行转移的jmp指令"></a>9.2 jmp指令和依据译为进行转移的jmp指令</h2><h3 id="9-2-1-jmp-short-标号-转移到标号出执行指令"><a href="#9-2-1-jmp-short-标号-转移到标号出执行指令" class="headerlink" title="9.2.1 jmp short 标号(转移到标号出执行指令)"></a>9.2.1 jmp short 标号(转移到标号出执行指令)</h3><pre><code>1. short标号下，它属于段内短转移，对IP的修改范围为-128~127。</code></pre><h3 id="9-2-2-立即数在机器码中的表示"><a href="#9-2-2-立即数在机器码中的表示" class="headerlink" title="9.2.2 立即数在机器码中的表示"></a>9.2.2 立即数在机器码中的表示</h3><p>在一般的汇编指令当中，汇编指令的idata（立即数），不论他是表示一个数据还是内存单元的偏移地址，都会在相应的机器指令中出现，因为CPU执行的是机器指令，他必须处理这些数据或地址。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mov ax,0123h		B8 23 01</span><br><span class="line">mov ax,ds:[0123h]	A1 23 01</span><br><span class="line">push ds:[0123h]		FF 36 23 01</span><br></pre></td></tr></table></figure>
<h3 id="9-2-3-jmp转移的机制（是怎么实现转移的）"><a href="#9-2-3-jmp转移的机制（是怎么实现转移的）" class="headerlink" title="9.2.3 jmp转移的机制（是怎么实现转移的）"></a>9.2.3 jmp转移的机制（是怎么实现转移的）<span id="jmp"></span></h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">start:	mov ax,0</span><br><span class="line">		mov bx,0</span><br><span class="line">		jmp short s</span><br><span class="line">		add ax,1</span><br><span class="line">	s:	inc ax</span><br></pre></td></tr></table></figure>

<ol>
<li>首先我们应该知道，jmp指令是2个字节，如代码中的jmp机械码是：<strong>EB 03</strong> 。这样的机械码，<strong>没有包含s段的地址</strong>！所以将jmp指令写入内存之后，IP=IP+2=0008h。</li>
<li>但是，执行完jmp后，IP=000Bh。因为执行JMP，就是执行IP=IP+(EB之后的偏移量)=IP+3=000Bh。</li>
<li>所以<strong>jmp执行的是给IP加偏移地址！</strong>。</li>
</ol>
<p>所以 jmp short 标号 的功能为：<strong>(ip)=(ip)+8位位移</strong></p>
<h3 id="9-2-4-继续上面的，8位位移是怎么得出来的？"><a href="#9-2-4-继续上面的，8位位移是怎么得出来的？" class="headerlink" title="9.2.4 继续上面的，8位位移是怎么得出来的？"></a>9.2.4 继续上面的，8位位移是怎么得出来的？</h3><p><img src="/2019/11/10/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80-%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0/9.2.4.png" alt></p>
<ol>
<li><strong>8位位移</strong>=<strong>标号处的地址</strong> - jmp指令<strong>后的第一个字节的地址</strong>.</li>
<li><strong>short</strong>指明此处的位移为<strong>8位位移</strong>;</li>
<li>8位位移的范围为-128-127，<strong>用补码表示</strong></li>
<li>8位位移由编译程序在编译时算出。</li>
</ol>
<blockquote>
<p>还有一种和”jmp short标号”功能相近的指令格式:<br><strong>jmp near ptr标号</strong><br>它实现的是段内近转移。功能为:<strong>(IP)=(LP)+16位位移</strong>。<br>(1) 16位位移=标号处的地址 - jmp指令后的第一个字节的地址:<br>(2) <strong>near ptr</strong>指明此处的位移为<strong>16位位移</strong>，进行的是<strong>段内近转移</strong>:<br>(3) 16位位移的范围为一32768~32767，用<strong>补码表示</strong>:<br>(4) 16位位移由编译程序在编译时算出。</p>
</blockquote>
<h3 id="9-2-5-jmp-far-ptr-标号（段间转移-远转移）"><a href="#9-2-5-jmp-far-ptr-标号（段间转移-远转移）" class="headerlink" title="9.2.5 jmp far ptr 标号（段间转移/远转移）"></a>9.2.5 jmp far ptr 标号（段间转移/远转移）</h3><p>是不是所有的jmp机械码都没有段数据呢？当然不是！小标题就说到了：far ptr，这个指令用标号的段地址和偏移地址修改CS和IP<br>如：<br><img src="/2019/11/10/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80-%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0/9.2.5.png" alt><br>解释：“OB 01 BD 0B”是目的地之在指令中的存储顺序：<br>高地址：“BD 0B”是段地址 0BBDH ；<br>低地址：“0B 01”是偏移地址 010BH ；</p>
<h3 id="9-2-6-转移地址在寄存器的jmp指令-这就相当于总结了，上面废话有点多"><a href="#9-2-6-转移地址在寄存器的jmp指令-这就相当于总结了，上面废话有点多" class="headerlink" title="9.2.6 转移地址在寄存器的jmp指令(这就相当于总结了，上面废话有点多)"></a>9.2.6 转移地址在寄存器的jmp指令(这就相当于总结了，上面废话有点多)</h3><ul>
<li>若只是一个字，则只是偏移地址（直接EB ??完事）</li>
<li>若是两个字，那么一个是段，一个是偏移地址。</li>
</ul>
<h2 id="9-3-jcxz指令"><a href="#9-3-jcxz指令" class="headerlink" title="9.3 jcxz指令"></a>9.3 jcxz指令</h2><p>该指令为有条件转移指令，所有的有条件转移指令都是<strong>短指令</strong>，即上面9.2.6说的1个字，只有位移（偏移地址），对ip的修改范围是：-128~127.</p>
<blockquote>
<p>指令格式：jcxz 标号<br>如果(cx)=0，则转移到标号这</p>
</blockquote>
<h2 id="9-4-loop指令"><a href="#9-4-loop指令" class="headerlink" title="9.4 loop指令"></a>9.4 loop指令</h2><p>也是短转移指令，pass</p>
<h2 id="9-5-编译器对转移位移超界的检测"><a href="#9-5-编译器对转移位移超界的检测" class="headerlink" title="9.5 编译器对转移位移超界的检测"></a>9.5 编译器对转移位移超界的检测</h2><p>编译的时候就会出错！因为，这超界，编译器可识别不了。这不存在的玩意儿。</p>
<h1 id="第十章-CALL和RET指令"><a href="#第十章-CALL和RET指令" class="headerlink" title="第十章 CALL和RET指令"></a>第十章 CALL和RET指令</h1><h2 id="10-1-ret和retf"><a href="#10-1-ret和retf" class="headerlink" title="10.1 ret和retf"></a>10.1 ret和retf</h2><p>它们都是用栈中的指令，而ret是改变ip，而retf是改变cs:ip，实现远转移。<br>而正是因为它们是取栈中的指令，所以要和push 和pop结合起来，而ret或者retf执行完后，相当于执行了指令pop<br>如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mov ax stack	;在前面声明的stack数据段，共16B</span><br><span class="line">mov ss ax		;栈段地址</span><br><span class="line">mov sp 16		;将值（Base）设置为16，往上加。（栈的特性）</span><br><span class="line">push cx</span><br><span class="line">push ip</span><br><span class="line">retf</span><br></pre></td></tr></table></figure>
<p>这里就相当于执行了刚放进去的机器码。</p>
<h2 id="10-2-call指令"><a href="#10-2-call指令" class="headerlink" title="10.2 call指令"></a>10.2 call指令</h2><ul>
<li>将打那个钱的IP或CS:IP压入栈中</li>
<li>转移</li>
</ul>
<p>注意：call指令不能执行短转移，其实现方法与<a href="#jmp">jmp指令</a>相同</p>
<h3 id="10-2-1-依据位移进行转移的call指令"><a href="#10-2-1-依据位移进行转移的call指令" class="headerlink" title="10.2.1 依据位移进行转移的call指令"></a>10.2.1 依据位移进行转移的call指令</h3><blockquote>
<p>call 标号(将当期那的ip压入栈后，转到标号处执行指令)</p>
</blockquote>
<p>指令执行时会带有以下操作：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1. (sp)=(sp)-2	;压栈</span><br><span class="line"> ((ss)*16+(sp))=(IP)</span><br><span class="line">2. (IP)=(IP)+16位位移</span><br></pre></td></tr></table></figure>
<p>这个位移之前也说过了，不多讲。<br>看到上面的代码我们也能联想到jmp的执行了，相当于：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">push IP</span><br><span class="line">jmp near ptr 标号</span><br></pre></td></tr></table></figure>
<p>举个例子！</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">内存地址 机器码 汇编指令 </span><br><span class="line">1000:0 b8 00 00 mov ax,0 </span><br><span class="line">1000:3 e8 01 00 call s </span><br><span class="line">1000:6 40 		inc ax </span><br><span class="line">1000:7 58 		s:pop ax</span><br></pre></td></tr></table></figure>
<p>也许你会想到：我没有push哪来的pop!?</p>
<ol>
<li>在call之时已经有了push ip，此时的ip=提取call s之后指向下一个执行机器码（inc ax）的ip指针，也就是ip=6。</li>
<li>而当call转移到s，ip就变为call之后的ip。</li>
<li>此时再pop ax，也就是ax=6。</li>
<li>因为执行完s，没有<span id="ret"></span>回调指令pop ip。。。所以不会执行inc ax</li>
</ol>
<h3 id="10-2-2-转移地址在指令中的call指令"><a href="#10-2-2-转移地址在指令中的call指令" class="headerlink" title="10.2.2 转移地址在指令中的call指令"></a>10.2.2 转移地址在指令中的call指令</h3><p>这个也就是段间转移了，是相对于上头说的段内转移</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">call far ptr 标号</span><br></pre></td></tr></table></figure>
<p>此时会执行cs和ip双压栈</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1. (sp)=(sp)-2	;压栈</span><br><span class="line"> ((ss)*16+(sp))=(CS)</span><br><span class="line">(sp)=(sp)-2	;压栈</span><br><span class="line"> ((ss)*16+(sp))=(IP)</span><br><span class="line">2. (CS)=标号所在的段地址</span><br><span class="line">(IP)=标号在段中的偏移地址</span><br><span class="line"></span><br><span class="line">即：</span><br><span class="line">push CS</span><br><span class="line">push IP</span><br><span class="line">jmp far ptr 标号</span><br></pre></td></tr></table></figure>
<p>举个例子：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1000:0 b8 00 00 		mov ax,0</span><br><span class="line">1000:3 9a 09 00 00 10 	call far ptr s</span><br><span class="line">1000:8 40 				inc ax</span><br><span class="line">1000:9 58 			s:	pop ax</span><br><span class="line">						add ax,ax</span><br><span class="line">						pop bx</span><br><span class="line">						add ax,bx</span><br></pre></td></tr></table></figure>
<p>ax是多少呢？</p>
<ol>
<li>call指令执行之后，stack中有cs和ip两个数据，CS在底部,IP在顶部。所以第一次pop ax，ax=ip=8</li>
<li>执行add后ax=16即10H</li>
<li>再执行pop，bx=1000H</li>
<li>add指令执行后ax=ax+bx=1010H</li>
</ol>
<h3 id="10-2-3-转移指令在寄存器中的call指令"><a href="#10-2-3-转移指令在寄存器中的call指令" class="headerlink" title="10.2.3 转移指令在寄存器中的call指令"></a>10.2.3 转移指令在寄存器中的call指令</h3><pre><code>call 16位reg</code></pre><p>功能：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">push IP</span><br><span class="line">jmp 16位reg	;IP=(reg)</span><br></pre></td></tr></table></figure>
<p>这个跟10.2.1是不是很像？段内转移。例子：call ax（当ax=6,则转到cs:6处执行）</p>
<h3 id="10-2-4-转移指令在内存中的call指令"><a href="#10-2-4-转移指令在内存中的call指令" class="headerlink" title="10.2.4 转移指令在内存中的call指令"></a>10.2.4 转移指令在内存中的call指令</h3><pre><code>call word ptr 内存单元地址</code></pre><p>功能：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">push IP</span><br><span class="line">jmp word ptr 内存单元地址</span><br></pre></td></tr></table></figure>
<p>其实跟10.2.3没啥两样。</p>
<p>但是还有一种双字型：<br>    call dword ptr 内存单元地址<br>功能：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">push CS</span><br><span class="line">push IP</span><br><span class="line">jmp dword ptr 内存单元地址</span><br></pre></td></tr></table></figure>
<p>举个例子就明白了</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mov sp,10h</span><br><span class="line">mov ax,0123h</span><br><span class="line">mov ds:[0],ax</span><br><span class="line">mov word ptr ds:[2]，0</span><br><span class="line">call dword ptr ds:[0]</span><br></pre></td></tr></table></figure>
<p>执行后：(CS)=0, (IP)=0123H, (sp)=0CH.</p>
<h2 id="10-3-call与ret的配合使用（敲黑板！）"><a href="#10-3-call与ret的配合使用（敲黑板！）" class="headerlink" title="10.3 call与ret的配合使用（敲黑板！）"></a>10.3 call与ret的配合使用（敲黑板！）</h2><ul>
<li>call之时压ip到栈中!</li>
<li>call完之后，执行转移后的指令</li>
<li>通过ret取出栈中的地址，执行转移操作！即<strong><a href="#ret">回调</a></strong>作用！</li>
<li>回调完成就可以执行call之后的代码了！<br>分析例子：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">assume cs:code</span><br><span class="line">code segment</span><br><span class="line">  start: mov ax,1</span><br><span class="line">         mov cx,3</span><br><span class="line">         call s</span><br><span class="line">         mov bx,ax	;(b)=?</span><br><span class="line">         mov ax,4c00h</span><br><span class="line">         int 21h</span><br><span class="line">      s: add ax,ax</span><br><span class="line">         loop s</span><br><span class="line">         ret</span><br><span class="line">code ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure>
<blockquote>
<p> 我们来看一下CPU执行这个程序的主要过程。<br>  (1)CPU将call s指令的机器码读入，IP指向了call s后的指令mov bx,ax.然后CPU执行call s指令，将当前的IP值(指令mov bx,ax的偏移地址)压栈，并将IP的值改变为标号s处的偏移地址:<br>  (2) CPU从标号s处开始执行指令，loop循环完毕后，(ax)=8;<br>  (3) CPU将ret指令的机器码读入，IP指向了ret指令后的内存单元，然后CPU执行ret指令，从栈中弹出一个值(即call s先前压入的mov bx,ax指令的偏移地址)送入IP中。则CS:IP指向指令mov bx,ax;<br>  (4) CPU从mov bx,ax开始执行指令，直至完成。</p>
</blockquote>
</li>
</ul>
<h2 id="10-4-mul乘法指令"><a href="#10-4-mul乘法指令" class="headerlink" title="10.4 mul乘法指令"></a>10.4 mul乘法指令</h2><p>之前说了div除法指令，现在说乘法指令。</p>
<h3 id="10-4-1-乘法规则"><a href="#10-4-1-乘法规则" class="headerlink" title="10.4.1 乘法规则"></a>10.4.1 乘法规则</h3><p>这里跟div的除数和被除数不一样的是，乘法的两个数，要么都是8位要么都是16位！</p>
<ol>
<li>乘法的两个数</li>
</ol>
<ul>
<li>如果是8位，一个放在<strong>AL</strong>中，一个放在8位的reg或内存字节单元中。</li>
<li>如果是16位，一个放在<strong>AX</strong>中，一个放在16位的reg或内存字节单元中。</li>
</ul>
<ol start="2">
<li>乘法的结果</li>
</ol>
<ul>
<li>如果是8位乘法，结果放在<strong>AX</strong>中</li>
<li>如果是16位乘法，<strong>高位放DX</strong>，<strong>低位放AX</strong></li>
</ul>
<h3 id="10-4-2-指令格式："><a href="#10-4-2-指令格式：" class="headerlink" title="10.4.2 指令格式："></a>10.4.2 指令格式：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mul reg</span><br><span class="line">mul 内存单元</span><br></pre></td></tr></table></figure>
<p>格式说明：<br>因为有一个放在了al(以8位为例)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mov al 1</span><br><span class="line">mov byte ptr ds:[0] 2</span><br><span class="line">mul ds:[0]</span><br></pre></td></tr></table></figure>
<p>这个就是用2*1了~<br>结果是ax=2（当然，我赋值的是十进制嘛）</p>
<h3 id="10-4-3-用mul寻址"><a href="#10-4-3-用mul寻址" class="headerlink" title="10.4.3 用mul寻址"></a>10.4.3 用mul寻址</h3><ol>
<li>mul byte ptr ds:[0]<br>含义：ax=al<em>(ds</em>16+0)</li>
<li>mul word ptr [bx+si+8]<br>含义：dx=</li>
</ol>
<h2 id="10-5-模块化程序设计"><a href="#10-5-模块化程序设计" class="headerlink" title="10.5  模块化程序设计"></a>10.5  模块化程序设计</h2><h3 id="10-5-1-参数和结果的传递问题"><a href="#10-5-1-参数和结果的传递问题" class="headerlink" title="10.5.1 参数和结果的传递问题"></a>10.5.1 参数和结果的传递问题</h3><p>也就是说，传进来的参数是啥，返回值是个啥。</p>
<ol>
<li>传入的参数：<br>这个有很多，有用栈传递的，也有直接用内存单元或者寄存器。</li>
<li>返回值：<br>这个可以存在寄存器中返回跟传入参数的方法很像</li>
</ol>
<p>而模块化设计，其实就是相当于c语言中的函数，把一个段中的代码当做一个函数执行。</p>
<h3 id="10-5-2-寄存器冲突问题"><a href="#10-5-2-寄存器冲突问题" class="headerlink" title="10.5.2 寄存器冲突问题"></a>10.5.2 寄存器冲突问题</h3><p>冲突问题是什么呢？例如如果上面的模块使用的loop，即使用了寄存器cx，而call的模块也适用了loop，即也使用了cx，那么两者就将共用cx，肯定会出错！<br>解决办法有：</p>
<ol>
<li>让别的调用者调用其他寄存器（这个很难实现，你也不知道他会用到什么寄存器）</li>
<li>不要使用会冲突的寄存器（这个不可能实现，只是说说理想罢了）</li>
<li>用栈，压进去，保存，call完在出栈！（这个OK哦）</li>
</ol>
<h2 id="10-6-课后"><a href="#10-6-课后" class="headerlink" title="10.6 课后"></a>10.6 课后</h2><h3 id="下面的程序执行后，ax和bx中的数值为多少？"><a href="#下面的程序执行后，ax和bx中的数值为多少？" class="headerlink" title="下面的程序执行后，ax和bx中的数值为多少？"></a>下面的程序执行后，ax和bx中的数值为多少？</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">assume cs:codesg</span><br><span class="line">stack segment</span><br><span class="line">    dw 8 dup(0)</span><br><span class="line">stack ends</span><br><span class="line">codesg segment</span><br><span class="line">start:</span><br><span class="line">    mov ax,stack</span><br><span class="line">    mov ss,ax</span><br><span class="line">    mov sp,10h</span><br><span class="line">    mov word ptr ss:[0],offset s ;(ss:[0])=1ah</span><br><span class="line">    mov ss:[2],cs                ;(ss:[2])=cs</span><br><span class="line">    call dword ptr ss:[0]        ;cs入栈,ip=19h入栈,转到cs:1ah处执行指令</span><br><span class="line">                                 ;(ss:[4])=cs,(ss:[6])=ip</span><br><span class="line">    nop</span><br><span class="line">s:  mov ax,offset s              ;ax=1ah</span><br><span class="line">    sub ax,ss:[0ch]              ;ax=1ah-(ss:[0ch])=1ah-19h=1</span><br><span class="line">    mov bx,cs                    ;bx=cs＝0c5bh</span><br><span class="line">    sub bx,ss:[0eh]              ;bx=cs-cs=0</span><br><span class="line">    mov ax,4c00h</span><br><span class="line">    int 21h</span><br><span class="line">codesg ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure>
<h3 id="实验10-1-编写子程序-之-显示字符串"><a href="#实验10-1-编写子程序-之-显示字符串" class="headerlink" title="实验10-1 编写子程序 之 显示字符串"></a>实验10-1 编写子程序 之 显示字符串</h3><p>在这次实验中，我们将要编写3个子程序，通过它们来认识几个常见的问题和掌握解决这些问题的方法.同前面的所有实验一样，这个实验是必须独立完成的，在后面的课程中，将要用到这个实验中编写的3个子程序。</p>
<h4 id="显示字符串"><a href="#显示字符串" class="headerlink" title="显示字符串"></a>显示字符串</h4><h5 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h5><p>显示字符串是现实工作中经常要用到的功能，应该编写一个通用的子程序来实现这个功<br>能.我们应该提供灵活的调用接口，使调用者可以决定显示的位置(行、列)、内容和颜色。</p>
<h5 id="子程序描述"><a href="#子程序描述" class="headerlink" title="子程序描述"></a>子程序描述</h5><p>名称:show str<br>功能:在指定的位置，用指定的颜色，显示一个用0结束的字符串。<br>参数:(dh)=行号(取值范围。-24), (dl)=列号(取值范围0-79),<br>      (cl)=颜色，ds:si指向字符串的首地址<br>返回:无<br>应用举例:在屏幕的8行3列，用绿色显示data段中的字符串。</p>
<h4 id="提示"><a href="#提示" class="headerlink" title="提示"></a>提示</h4><ol>
<li>子程序的入口参数是屏幕上的行号和列号，注意在子程序内部要将它们转化为显存中的地址，首先要分析一下屏幕上的行列位置和显存地址的对应关系:</li>
<li>注意保存子程序中用到的相关寄存器:</li>
<li>这个子程序的内部处理和显存的结构密切相关.但是向外提供了与显存结构无关的接口。通过调用这个子程序，进行字符串的显示时可以不必了解显存的结构，为编程提供了方便。在实验中，注意体会这种设计思想。</li>
<li>其实这玩意，就是抢占了本来应该在屏幕中输出的系统信息。那么设置行列号的，就是占的信息的位置。<details>
<summary><mark><font color="darkred">点击查看参考代码</font></mark></summary>
<pre><code>  
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">assume cs:code,ds:data</span><br><span class="line"></span><br><span class="line">data segment</span><br><span class="line">	db &apos;Welcome to masm!&apos;,0</span><br><span class="line">data ends</span><br><span class="line"></span><br><span class="line">code segment</span><br><span class="line">start:	</span><br><span class="line">	mov dh,8	;行号</span><br><span class="line">	mov dl,3	;列号</span><br><span class="line">	mov cl,07h	;白色字	</span><br><span class="line">	mov ax,data</span><br><span class="line">	mov ds,ax</span><br><span class="line">	mov si,0	;循环加入字</span><br><span class="line">	call show_str</span><br><span class="line"></span><br><span class="line">	mov ax,4c00h</span><br><span class="line">	int 21h</span><br><span class="line">show_str:</span><br><span class="line">	push cx	;保存用到的寄存器</span><br><span class="line">	push si</span><br><span class="line">	push es</span><br><span class="line">	push di</span><br><span class="line">	push bx</span><br><span class="line"></span><br><span class="line">	mov ax,0b800h</span><br><span class="line">	mov es,ax</span><br><span class="line"></span><br><span class="line">	mov al,0a0h	;一行的总列数160字节</span><br><span class="line">	dec dh		;行号减1，因为是从0开始的</span><br><span class="line">	mul dh		;计算行开始偏移地址</span><br><span class="line">	mov bx,ax</span><br><span class="line"></span><br><span class="line">	mov al,2</span><br><span class="line">	mul dl		;计算列</span><br><span class="line">	sub ax,2	;列也是从0开始，而且一个字符占两个字节</span><br><span class="line">	add bx,ax	;求出开始位置	</span><br><span class="line">	</span><br><span class="line">	mov di,0</span><br><span class="line">	mov al,cl</span><br><span class="line">	mov ch,0	;高8位为0</span><br><span class="line">s:	</span><br><span class="line">	mov cl,ds:[si]	;判断是否到了字符结束</span><br><span class="line">	jcxz ok</span><br><span class="line">	mov es:[bx+di],cl</span><br><span class="line">	mov es:[bx+di+1],al</span><br><span class="line"></span><br><span class="line">	inc si</span><br><span class="line">	add di,2</span><br><span class="line">	jmp short s</span><br><span class="line">ok:</span><br><span class="line">	pop bx</span><br><span class="line">	pop di</span><br><span class="line">	pop es</span><br><span class="line">	pop si</span><br><span class="line">	pop cx</span><br><span class="line">	ret</span><br><span class="line"></span><br><span class="line">code ends</span><br><span class="line"></span><br><span class="line">end start</span><br></pre></td></tr></table></figure>
</code></pre>
</details>

</li>
</ol>
<h3 id="解决除法溢出问题"><a href="#解决除法溢出问题" class="headerlink" title="解决除法溢出问题"></a>解决除法溢出问题</h3><h4 id="问题："><a href="#问题：" class="headerlink" title="问题："></a>问题：</h4><p>其实就是如果商超过了应该存储商的寄存器的大小，应该怎么办。emmm可以用大一点的，用dword</p>
<h1 id="第十一章-标志寄存器"><a href="#第十一章-标志寄存器" class="headerlink" title="第十一章 标志寄存器"></a>第十一章 标志寄存器</h1><p>这是一种特殊的寄存器，一共16位：</p>
<ol>
<li>用来存储相关指令的执行结果</li>
<li>用来为CPU执行相关指令提供行为依据</li>
<li>用来控制CPU的相关工作方式<br>其分布如下：</li>
</ol>
<table>
<thead>
<tr>
<th>15</th>
<th>14</th>
<th>13</th>
<th>12</th>
<th>11</th>
<th>10</th>
<th>9</th>
<th>8</th>
<th>7</th>
<th>6</th>
<th>5</th>
<th>4</th>
<th>3</th>
<th>2</th>
<th>1</th>
<th>0</th>
</tr>
</thead>
<tbody><tr>
<td>*</td>
<td>*</td>
<td>*</td>
<td>*</td>
<td>OF</td>
<td>DF</td>
<td>IF</td>
<td>TF</td>
<td>SF</td>
<td>ZF</td>
<td>*</td>
<td>AF</td>
<td>*</td>
<td>PF</td>
<td>*</td>
<td>CF</td>
</tr>
</tbody></table>
<p>其中*表示都没用：1 3 5 12 13 14 15在8086CPU中都没有使用。<br>注意：对标志位有影响的指令有：add,sub,mul,div,inc,or,and等，而没有影响的有：mov,push,pop等，它们大多数为传送指令。</p>
<h2 id="11-1-标志表"><a href="#11-1-标志表" class="headerlink" title="11.1 标志表"></a>11.1 标志表</h2><table>
<thead>
<tr>
<th>名称</th>
<th>代号</th>
<th>作用</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>零标志</td>
<td>ZF</td>
<td>判断结果是否为零</td>
<td>若为0则ZF=1，否则ZF=0</td>
</tr>
<tr>
<td>奇偶标志</td>
<td>PF</td>
<td>判断结果中1的个数是奇是偶</td>
<td>若1的个数为奇数则PF=0，否则为1</td>
</tr>
<tr>
<td>符号标志</td>
<td>SF</td>
<td>判断结果是正是负</td>
<td>若为正数则SF=0，否则为1</td>
</tr>
<tr>
<td>进位标志位</td>
<td>CF</td>
<td>在进行<strong>无符号</strong>运算时记录是否有向最高位<strong>进位</strong>或者<strong>借位</strong></td>
<td>那是假想的最高位</td>
</tr>
<tr>
<td>溢出标志</td>
<td>OF</td>
<td>判断是否超过容器所能装的最大数</td>
<td>如al=98+99=197，197&gt;127溢出，实际结果：-59</td>
</tr>
<tr>
<td>方向标志</td>
<td>DF</td>
<td>控制每次操作后si、di的增减</td>
<td>df=0 每次si,di增加；df=1 每次si,di减少。经常用作字符串的传送</td>
</tr>
</tbody></table>
<h2 id="11-2-与标志有关的指令"><a href="#11-2-与标志有关的指令" class="headerlink" title="11.2 与标志有关的指令"></a>11.2 与标志有关的指令</h2><h3 id="11-2-1-与CF相关的：adc-sdd指令"><a href="#11-2-1-与CF相关的：adc-sdd指令" class="headerlink" title="11.2.1 与CF相关的：adc,sdd指令"></a>11.2.1 与CF相关的：adc,sdd指令</h3><ol>
<li>adc：带进位加法。如：adc al,8h == al+8h+CF </li>
<li>sdd：带借位减法。如：sdd al,8h == al-8h-CF</li>
</ol>
<h3 id="11-2-2-与CF和ZF有关的：cmp指令（比较指令）"><a href="#11-2-2-与CF和ZF有关的：cmp指令（比较指令）" class="headerlink" title="11.2.2 与CF和ZF有关的：cmp指令（比较指令）"></a>11.2.2 与CF和ZF有关的：cmp指令（比较指令）</h3><p>指令格式：cmp <em>s1</em>,<em>s2</em><br>举个例子：cmp ax,bx<br>比对结果如下：</p>
<table>
<thead>
<tr>
<th>情况</th>
<th>结果分析</th>
<th>结果</th>
</tr>
</thead>
<tbody><tr>
<td><strong>(ax)=(bx)</strong></td>
<td>则(ax)-(bx)=0</td>
<td><strong>zf=1</strong>;</td>
</tr>
<tr>
<td><strong>(ax)≠(bx)</strong></td>
<td>则(ax)-(bx)≠0</td>
<td><strong>zf=0</strong>;</td>
</tr>
<tr>
<td><strong>(ax)&lt;(bx)</strong></td>
<td>则(ax卜(bx)将产生借位</td>
<td><strong>cf=1</strong>;</td>
</tr>
<tr>
<td><strong>(ax)≥(bx)</strong></td>
<td>则(ax)-(bx)不必借位</td>
<td><strong>cf=0</strong>;</td>
</tr>
<tr>
<td><strong>(ax)&gt;(bx)</strong></td>
<td>则(ax)-(bx)既<em>不必借位<em>，</em>结果又不为0</em></td>
<td><strong>cf=0并且zf=0</strong>;</td>
</tr>
<tr>
<td><strong>(ax)≤(bx)</strong></td>
<td>则(ax)-(bx)既<em>可能借位<em>，</em>结果可能为0</em></td>
<td><strong>cf=1或zf=1</strong>.</td>
</tr>
</tbody></table>
<h3 id="11-2-3-与CMP有关的比较结果条件转移指令"><a href="#11-2-3-与CMP有关的比较结果条件转移指令" class="headerlink" title="11.2.3 与CMP有关的比较结果条件转移指令"></a>11.2.3 与CMP有关的比较结果条件转移指令</h3><table>
<thead>
<tr>
<th>指令</th>
<th>含义</th>
<th>简记</th>
<th>符号</th>
<th>监测的相关标志位</th>
</tr>
</thead>
<tbody><tr>
<td>je</td>
<td>等于则转移</td>
<td>equal</td>
<td>=</td>
<td>zf=1</td>
</tr>
<tr>
<td>jne</td>
<td>不等于则转移</td>
<td>not equal</td>
<td>≠</td>
<td>zf=0</td>
</tr>
<tr>
<td>jb</td>
<td>低于则转移</td>
<td>below</td>
<td>＜</td>
<td>cf=1</td>
</tr>
<tr>
<td>jnb</td>
<td>不低于则转移</td>
<td>not below</td>
<td>≥</td>
<td>cf=0</td>
</tr>
<tr>
<td>ja</td>
<td>高于则转移</td>
<td>above</td>
<td>＞</td>
<td>cf=0且zf=0</td>
</tr>
<tr>
<td>jna</td>
<td>不高于则转移</td>
<td>not above</td>
<td>≤</td>
<td>cf=1或zf=1</td>
</tr>
</tbody></table>
<p>注意，这个一般是与cmp配合使用，如同call和ret一样，但是没有说一定要配合使用。</p>
<h3 id="11-2-4-与DF有关指令"><a href="#11-2-4-与DF有关指令" class="headerlink" title="11.2.4 与DF有关指令"></a>11.2.4 与DF有关指令</h3><table>
<thead>
<tr>
<th>指令</th>
<th>功能</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td>movsb</td>
<td>mov es:[di],byte ptr ds:[si]</td>
<td>从ds中取字符放到es指定的位置中，单位为字节，会令<strong>di和si同时±1</strong></td>
</tr>
<tr>
<td>movsw</td>
<td>mov es:[di],word ptr ds:[si]</td>
<td>从ds中取字符放到es指定的位置中，单位为字，会令di<strong>和si同时±2</strong></td>
</tr>
<tr>
<td>cld</td>
<td>设置df=0，正向</td>
<td>令di，si向增方向</td>
</tr>
<tr>
<td>std</td>
<td>设置df=1，逆向</td>
<td>令di，si向减方向</td>
</tr>
<tr>
<td>rep</td>
<td>重复指令，根据CX当中的值，与LOOP相似</td>
<td>配合movsb使用</td>
</tr>
</tbody></table>
<p>例子：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">我们来看下面的两个程序。</span><br><span class="line">(1)编程，用串传送指令，将data段中的第一个字符串复制到它后面的空间中。</span><br><span class="line">data segment</span><br><span class="line">db &apos;Welcome to masm!.</span><br><span class="line">db 16 dup (0)</span><br><span class="line">data ends</span><br><span class="line">我们分析一下，使用串传送指令进行数据的传送，需要给它提供一些必要的信息</span><br><span class="line">它们是:</span><br><span class="line">1. 传送的原始位置:ds:si:</span><br><span class="line">2. 传送的目的位置:es:di;</span><br><span class="line">3. 传送的长度:CX;</span><br><span class="line">4. 传送的方向:df.</span><br><span class="line">在这个问题中，这些信息如下。</span><br><span class="line">1. 传送的原始位置:data:O;</span><br><span class="line">2. 传送的目的位置:data:0010;</span><br><span class="line">3. 传送的长度:16;</span><br><span class="line">4. 传送的方向:因为正向传送(每次串传送指令执行后，Si和di递增此较方便，所以设置df=o</span><br><span class="line">好了，明确了这些信息之后，我们来编写程序:</span><br><span class="line">mov ax,data</span><br><span class="line">mov ds,ax</span><br><span class="line">mov si,0	;ds:si指向data: 0</span><br><span class="line">mov es,ax</span><br><span class="line">mov di,16	;es.di于行向data:0010</span><br><span class="line">mov cx,16	;(cx)-16, rep循环1‘次</span><br><span class="line">cld			;设置df=0，正向传送</span><br><span class="line">rep movsb</span><br></pre></td></tr></table></figure>

<h2 id="11-3-标志位有关的问题"><a href="#11-3-标志位有关的问题" class="headerlink" title="11.3 标志位有关的问题"></a>11.3 标志位有关的问题</h2><h3 id="11-3-1-单纯就符号标志位就可以判断结果的正负吗？（即判断相减的两个数的大小）"><a href="#11-3-1-单纯就符号标志位就可以判断结果的正负吗？（即判断相减的两个数的大小）" class="headerlink" title="11.3.1 单纯就符号标志位就可以判断结果的正负吗？（即判断相减的两个数的大小）"></a>11.3.1 单纯就符号标志位就可以判断结果的正负吗？（即判断相减的两个数的大小）</h3><p>当然不是！</p>
<blockquote>
<p>当1-2=-1&lt;0，则SF为1，表示负数，则前一个数比后一个数大<br>当34-(-96)=82H时，82H是-126的补码，所以SF=1，但是前一个数比后一个数大？当然不。</p>
</blockquote>
<p>为什么呢？<strong>因为发生了溢出</strong>。</p>
<ul>
<li>也就是说，保存结果的寄存器不足以表示那么大的数。</li>
<li>而34-(-96)=130明显超过127（假设保存结果的是ah）。 </li>
<li>那么结果就会表示为-126<em>（130-127=3，-128+3-1=-126）</em></li>
<li>而此时，SF=1，同时，<strong>OF=1</strong>。</li>
<li>所以<strong>要看结果的正负，要结合SF和OF的值</strong>.</li>
</ul>
<p>总结：</p>
<table>
<thead>
<tr>
<th>标志</th>
<th>结果</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>SF=1,OF=0</td>
<td>负</td>
<td>略</td>
</tr>
<tr>
<td>SF=1,OF=1</td>
<td>正</td>
<td>因为溢出导致实际结果为负，那么逻辑上必定为正</td>
</tr>
<tr>
<td>SF=0,OF=1</td>
<td>负</td>
<td>因为溢出导致实际结果为正，那么逻辑上必定为负</td>
</tr>
<tr>
<td>SF=0,OF=0</td>
<td>正</td>
<td>略</td>
</tr>
</tbody></table>
<h2 id="11-4-pushf和popf"><a href="#11-4-pushf和popf" class="headerlink" title="11.4 pushf和popf"></a>11.4 pushf和popf</h2><p>因为标志寄存器共16位，所以pushf就直接将16位当做寄存器放入栈中，popf是出栈。<br>注意，它们不需要加对象参数，<strong>入栈和出栈的对象都是标志寄存器</strong>！</p>
<h1 id="第十二章-内中断"><a href="#第十二章-内中断" class="headerlink" title="第十二章 内中断"></a>第十二章 内中断</h1><p>也就是CPU不再往下执行下去。而CPU内部的四种中断信息是：</p>
<ol>
<li>除法错误，如div指令产生的除法溢出（中断类型码：0）</li>
<li>单步执行（中断类型码：1）</li>
<li>执行into指令（中断类型码：4）</li>
<li>执行int指令（指令格式：int n，其中n是中断类型码，是字节型立即数）</li>
</ol>
<h2 id="12-1-中断一条龙（中断程序，中断向量表，中断过程）"><a href="#12-1-中断一条龙（中断程序，中断向量表，中断过程）" class="headerlink" title="12.1 中断一条龙（中断程序，中断向量表，中断过程）"></a>12.1 中断一条龙（中断程序，中断向量表，中断过程）</h2><p>中断过程：</p>
<ol>
<li>取得中断类型码（即中断向量表中的中断程序位置）</li>
<li>标志位入栈（因为执行中断过程要改变标志寄存器的值）</li>
<li>设置寄存器的<strong>TF</strong>和<strong>IF</strong>的值为0</li>
<li>CS内容入栈</li>
<li>IP内容入栈（结束中断程序回调的时候用，和call差不多）</li>
<li>从内存地址为中断类型码*4和中断类型码*4+2的两个字单元中读取中断处理程序的入口地址设置IP和CS。（用来取得<strong>中断程序在内存中的位置</strong>）</li>
</ol>
<p>其实就是：</p>
<ol>
<li>get N</li>
<li>pushf</li>
<li>TF=0, IF=0</li>
<li>push CS</li>
<li>push IP</li>
<li>(IP)=(N*4), (CS)=(N/4+2)</li>
<li>执行程序！</li>
</ol>
<h2 id="12-2-中断处理程序，安装，中断向量等"><a href="#12-2-中断处理程序，安装，中断向量等" class="headerlink" title="12.2 中断处理程序，安装，中断向量等"></a>12.2 中断处理程序，安装，中断向量等</h2><p>这个只是稍微述说，额，因为我不太能用到这个，作为了解而已。<br>中断处理程序就如同除法溢出程序一样（输出‘…overflow’），如何处理后续的事物做中断处理，然后返回系统程序。<br>而如果想要自己编一个中断处理程序，首先</p>
<ol>
<li>把中断码想好，把程序要放的地方想好，<em>*放入中断向量表</em></li>
<li>编程序，安装（写到相应位置）</li>
<li>测试</li>
</ol>
<p>这里当然要用到之前学的几乎所有内容（包括ret,movsb等）</p>
<h2 id="12-3-单步中断和TF-DF标志"><a href="#12-3-单步中断和TF-DF标志" class="headerlink" title="12.3 单步中断和TF,DF标志"></a>12.3 单步中断和TF,DF标志</h2><p>说到这里，你看标题就知道，TF肯定与单步中断有关，具体有什么关系呢？<br>首先说说<strong>单步中断</strong>，也就是不停止（退出）运行的程序，却能返回其实时的寄存器信息（也就是还在运行，只不过暂时停止了）。<br>而TF就是实现单步中断的重要标志，当<strong>TF=1</strong>时将引发单步中断，所以要想中断就先置TF=1。<br>这就是为什么中断执行（刚开始）就要把<strong>TF置0，就是为了防止步步中断</strong>！</p>
<h2 id="12-4-int指令"><a href="#12-4-int指令" class="headerlink" title="12.4 int指令"></a>12.4 int指令</h2><p>int指令引发的内中断很重要。虽然其过程与12.1所说的别无二致。<br>接下来就深入理解理解int、iret和栈：</p>
<h3 id="12-4-1-int、iret和栈"><a href="#12-4-1-int、iret和栈" class="headerlink" title="12.4.1 int、iret和栈"></a>12.4.1 int、iret和栈</h3><h1 id="第十三章-汇编语言重点知识总结"><a href="#第十三章-汇编语言重点知识总结" class="headerlink" title="第十三章 汇编语言重点知识总结"></a>第十三章 汇编语言重点知识总结</h1><h2 id="13-1寄存器与存储器"><a href="#13-1寄存器与存储器" class="headerlink" title="13.1寄存器与存储器"></a>13.1寄存器与存储器</h2><ol>
<li>寄存器功能</li>
</ol>
<ul>
<li>寄存器的一般用途和专用用途</li>
<li>CS:IP 控制程序执行流程</li>
<li>SS:SP 提供堆栈栈顶单元地址</li>
<li>DS:BX(SI,DI) 提供数据段内单元地址</li>
<li>SS:BP 提供堆栈内单元地址</li>
<li>ES:BX(SI,DI) 提供附加段内单元地址</li>
<li>AX,CX,BX 和CX 寄存器多用于运算和暂存中间计算结果,但又专用于某些指令(查阅指令<br>表)。</li>
<li>PSW 程序状态字寄存器只能通过专用指令（LAHF, SAHF)和堆栈(PUSHF,POPF)进行存取。</li>
</ul>
<ol start="2">
<li>存储器分段管理</li>
</ol>
<ul>
<li>解决了16 位寄存器构成20 位地址的问题</li>
<li>便于程序重定位</li>
<li>20 位物理地址=段地址* 16 + 偏移地址</li>
<li>程序分段组织: 一般由代码段,堆栈段,数据段和附加段组成,不设置堆栈段时则使用系统<br>内部的堆栈。</li>
</ul>
<ol start="3">
<li>堆栈</li>
</ol>
<ul>
<li>堆栈是一种先进后出的数据结构, 数据的存取在栈顶进行, 数据入栈使堆栈向地址减小<br>的方向扩展。</li>
<li>堆栈常用于保存子程序调用和中断响应时的断点以及暂存数据或中间计算结果。</li>
<li>堆栈总是以字为单位存取</li>
</ul>
<h2 id="13-2-指令系统与寻址方式"><a href="#13-2-指令系统与寻址方式" class="headerlink" title="13.2 指令系统与寻址方式"></a>13.2 指令系统与寻址方式</h2><ol>
<li>指令系统</li>
</ol>
<ul>
<li>计算机提供给用户使用的机器指令集称为指令系统,大多数指令为双操作数指令。执行指令<br>后,一般源操作数不变,目的操作数被计算结果替代。</li>
<li>机器指令由CPU 执行,完成某种运算或操作,8086/8088 指令系统中的指令分为6 类: 数据传<br>送,算术运算,逻辑运算,串操作,控制转移和处理机控制。</li>
</ul>
<ol start="2">
<li>寻址方式</li>
</ol>
<ul>
<li>寻址方式确定执行指令时获得操作数地址的方法</li>
<li>分为与数据有关的寻址方式(7 种)和与转移地址有关的寻址方式(4)种。</li>
<li>与数据有关的寻址方式的一般用途:</li>
</ul>
<blockquote>
<p>(1) 立即数寻址方式–将常量赋给寄存器或存储单元<br>(2) 直接寻址方式–存取单个变量<br>(3) 寄存器寻址方式–访问寄存器的速度快于访问存储单元的速度<br>(4) 寄存器间接寻址方式–访问数组元素<br>(5) 变址寻址方式<br>(6) 基址变址寻址方式<br>(7) 相对基址变址寻址方式<br>(5),(6),(7)都便于处理数组元素</p>
</blockquote>
<p>. 与数据有关的寻址方式中,提供地址的寄存器只能是BX,SI,DI 或BP<br>. 与转移地址有关的寻址方式的一般用途:</p>
<blockquote>
<p>(1) 段内直接寻址–段内直接转移或子程序调用<br>(2) 段内间接寻址–段内间接转移或子程序调用<br>(3) 段间直接寻址–段间直接转移或子程序调用<br>(4) 段间间接寻址–段间间接转移或子程序调用</p>
</blockquote>
<h2 id="13-3-汇编程序和汇编语言"><a href="#13-3-汇编程序和汇编语言" class="headerlink" title="13.3 汇编程序和汇编语言"></a>13.3 汇编程序和汇编语言</h2><ol>
<li>汇编程序</li>
</ol>
<ul>
<li>汇编程序是将汇编语言源程序翻译成二进制代码程序的语言处理程序,翻译的过程称为汇<br>编。</li>
</ul>
<ol start="2">
<li>汇编语言</li>
</ol>
<ul>
<li>汇编语言是用指令助记符,各种标识变量,地址,过程等的标识符书写程序的语言, 汇编语言<br>指令与机器指令一一对应。</li>
<li>伪指令,宏指令不是由CPU 执行的指令,而是由汇编程序在汇编期间处理的指令。</li>
<li>伪指令指示汇编程序如何完成数据定义,存储空间分配,组织段等工作。</li>
<li>宏指令可简化程序并减少程序书写量。</li>
<li>条件汇编伪指令的功能是确定是否汇编某段源程序,而不是实现程序分支,对未汇编的程序<br>将不产生相应的目标代码。</li>
<li>结构作为一种数据结构可将一组类型不同但有逻辑关联的数据组织在一起,便于整体处理<br>数据。</li>
<li>记录可用于提高存储单元的利用率,将若干不足一个字节或字且有逻辑关联的信息压缩存<br>放在一个字节或字中。</li>
<li>指令中的表达式在汇编期间计算,并且只能对常量或地址进行计算。</li>
</ul>
<h2 id="13-4-程序设计基础"><a href="#13-4-程序设计基础" class="headerlink" title="13.4 程序设计基础"></a>13.4 程序设计基础</h2><ol>
<li>分支程序设计</li>
</ol>
<ul>
<li>程序分支由条件转移指令或无条件转移指令实现</li>
<li>存放若干目的转移地址或跳转指令的跳转表常用于实现多路分支</li>
<li>条件转移指令只能实现偏移量为-128 至+127 字节范围的转移</li>
<li>无条件转移指令根据寻址方式可实现短转移(偏移量为-128 至+127 字节),段内转移,段间<br>转移。</li>
</ul>
<ol start="2">
<li>循环程序设计</li>
</ol>
<ul>
<li>可由循环控制指令或条件转移指令组织循环结构</li>
<li>内层循环结构必须完全包含在外层循环结构内,并不能发生从循环结构外向循环结构内的<br>转移。</li>
</ul>
<ol start="3">
<li>子程序设计</li>
</ol>
<ul>
<li>子程序中应保护寄存器内容,并正确使用堆栈, 成对执行PUSH 和POP 指令，保证执行RET<br>指令时堆栈栈顶为返回地址。</li>
<li>主程序可通过寄存器,参数表,或堆栈传递参数给子程序</li>
</ul>
<ol start="4">
<li>EXE 文件和COM 文件</li>
</ol>
<ul>
<li>二者都是可执行文件</li>
<li>COM 文件源程序的特点是: 第一条可执行指令的起始存放地址必须是100H,不能分段,不用<br>定义堆栈,所有过程为NEAR 类型,直接用INT 20H 指令返回DOS。</li>
</ul>
<ol start="5">
<li>DOS 功能调用与BIOS 中断调用</li>
</ol>
<ul>
<li>二者都是完成DOS 系统提供给用户的输入/输出等常用功能,通过执行软中断指令完成一<br>次软中断服务。</li>
<li>DOS 功能调用的中断服务程序是操作系统的一部分,存于RAM 中; 而BIOS 中断调用的中<br>断服务程序存放在ROM 中。</li>
</ul>
<h2 id="13-5-输入-输出与中断系统"><a href="#13-5-输入-输出与中断系统" class="headerlink" title="13.5 输入/输出与中断系统"></a>13.5 输入/输出与中断系统</h2><ol>
<li>输入/输出的方式</li>
</ol>
<ul>
<li>程序直接I/O 方式: 用IN 和OUT 指令直接在端口级上进行I/O 操作,数据传送方式分为无<br>条件传送方式和查询传送方式。</li>
<li>中断传送方式: 由CPU 响应中断请求完成中断服务。</li>
<li>DMA 传送方式: 直接在存储器与外设之间传送数据。</li>
</ul>
<ol start="2">
<li>有关中断的概念</li>
</ol>
<ul>
<li>中断、中断源、中断请求、中断服务、中断向量、中断向量表、中断响应过程、中断指令、<br>开中断、关中断、内部中断、外部中断、可屏蔽中断、非屏蔽中断。</li>
</ul>
<ol start="3">
<li>键盘I/O、显示器I/O 操作</li>
</ol>
<ul>
<li>键盘的输入操作用BIOS 的16H 中断调用控制,也可直接访问60H 端口(数据端口), 61H 端<br>口(状态端口)检测键盘的按键操作。</li>
<li>对于特殊键（如Shift , Ctrl , Alt , NumLock , ScrollLock 等键）的按动情况，可以直接从来<br>40:17H 单元取得有关信息。</li>
<li>显示器的图形显示可以用BIOS 的10H 中断调用实现,另一种速度更快的方法是直接读写<br>视频缓冲区。</li>
</ul>
<ol start="4">
<li>打印机I/O 操作由INT 17H 中断调用实现， 串行通讯口操作由INT 14H 中断调用实现。<br>CLD Clear the direction flag (set to forward direction)<br>将方向标志置0，使si 和di 增量，串处理从低地址向高地址处理</li>
</ol>
<h2 id="13-6-8088-汇编速查手册"><a href="#13-6-8088-汇编速查手册" class="headerlink" title="13.6 8088 汇编速查手册"></a>13.6 8088 汇编速查手册</h2><h3 id="13-6-1-数据传输指令"><a href="#13-6-1-数据传输指令" class="headerlink" title="13.6.1 数据传输指令"></a>13.6.1 数据传输指令</h3><p>它们在存贮器和寄存器、寄存器和输入输出端口之间传送数据.</p>
<ol>
<li>通用数据传送指令.</li>
</ol>
<table>
<thead>
<tr>
<th>指令</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>MOV</td>
<td>传送字或字节.</td>
</tr>
<tr>
<td>MOVSX</td>
<td>先符号扩展,再传送.</td>
</tr>
<tr>
<td>MOVZX</td>
<td>先零扩展,再传送.</td>
</tr>
<tr>
<td>PUSH</td>
<td>把字压入堆栈.</td>
</tr>
<tr>
<td>POP</td>
<td>把字弹出堆栈.</td>
</tr>
<tr>
<td>PUSHA</td>
<td>把AX,CX,DX,BX,SP,BP,SI,DI 依次压入堆栈.</td>
</tr>
<tr>
<td>POPA</td>
<td>把DI,SI,BP,SP,BX,DX,CX,AX 依次弹出堆栈.</td>
</tr>
<tr>
<td>PUSHAD</td>
<td>把EAX,ECX,EDX, EBX,ESP,EBP,ESI,EDI 依次压入堆栈.</td>
</tr>
<tr>
<td>POPAD</td>
<td>把EDI,ESI,EBP,ESP,EBX,EDX, ECX,EAX 依次弹出堆栈.</td>
</tr>
<tr>
<td>BSWAP</td>
<td>交换32 位寄存器里字节的顺序</td>
</tr>
<tr>
<td>XCHG</td>
<td>交换字或字节.( 至少有一个操作数为寄存器,段寄存器不可作为操作数)</td>
</tr>
<tr>
<td>CMPXCHG</td>
<td>比较并交换操作数.( 第二个操作数必须为累加器AL/AX/EAX )</td>
</tr>
<tr>
<td>XADD</td>
<td>先交换再累加.( 结果在第一个操作数里)</td>
</tr>
<tr>
<td>XLAT</td>
<td>字节查表转换.── BX 指向一张256 字节的表的起点, AL 为表的索引值(0-255,即0-FFH); 返回AL 为查表结果. ( [BX+AL]-&gt;AL )</td>
</tr>
</tbody></table>
<ol start="2">
<li>输入输出端口传送指令.</li>
</ol>
<table>
<thead>
<tr>
<th>指令</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>IN</td>
<td>I/O 端口输入. ( 语法: IN 累加器, {端口号│DX} )</td>
</tr>
<tr>
<td>OUT</td>
<td>I/O 端口输出. ( 语法: OUT {端口号│DX},累加器)</td>
</tr>
<tr>
<td>输入输出端口由立即方式指定时, 其范围是0-255; 由寄存器DX 指定时,其范</td>
<td></td>
</tr>
<tr>
<td>围是0-65535.</td>
<td></td>
</tr>
</tbody></table>
<ol start="3">
<li>目的地址传送指令.</li>
</ol>
<table>
<thead>
<tr>
<th>指令</th>
<th>描述</th>
<th>例子</th>
</tr>
</thead>
<tbody><tr>
<td>LEA</td>
<td>装入有效地址.</td>
<td>例: LEA DX,string ;把偏移地址存到DX.</td>
</tr>
<tr>
<td>LDS</td>
<td>传送目标指针,把指针内容装入DS.</td>
<td>例: LDS SI,string ;把段地址:偏移地址存到DS:SI.</td>
</tr>
<tr>
<td>LES</td>
<td>传送目标指针,把指针内容装入ES.</td>
<td>例: LES DI,string ;把段地址:偏移地址存到ES:DI.</td>
</tr>
<tr>
<td>LFS</td>
<td>传送目标指针,把指针内容装入FS.</td>
<td>例: LFS DI,string ;把段地址:偏移地址存到FS:DI.</td>
</tr>
<tr>
<td>LGS</td>
<td>传送目标指针,把指针内容装入GS.</td>
<td>例: LGS DI,string ;把段地址:偏移地址存到GS:DI.</td>
</tr>
<tr>
<td>LSS</td>
<td>传送目标指针,把指针内容装入SS.</td>
<td>例: LSS DI,string ;把段地址:偏移地址存到SS:DI.</td>
</tr>
</tbody></table>
<ol start="4">
<li>标志传送指令. </li>
</ol>
<table>
<thead>
<tr>
<th>指令</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>LAHF</td>
<td>标志寄存器传送,把标志装入AH.</td>
</tr>
<tr>
<td>SAHF</td>
<td>标志寄存器传送,把AH 内容装入标志寄存器.</td>
</tr>
<tr>
<td>PUSHF</td>
<td>标志入栈.</td>
</tr>
<tr>
<td>POPF</td>
<td>标志出栈.</td>
</tr>
<tr>
<td>PUSHD</td>
<td>32 位标志入栈.</td>
</tr>
<tr>
<td>POPD</td>
<td>32 位标志出栈.</td>
</tr>
</tbody></table>
<h3 id="13-6-2-算术运算指令"><a href="#13-6-2-算术运算指令" class="headerlink" title="13.6.2 算术运算指令"></a>13.6.2 算术运算指令</h3><table>
<thead>
<tr>
<th>指令</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>ADD</td>
<td>加法.</td>
</tr>
<tr>
<td>ADC</td>
<td>带进位加法.</td>
</tr>
<tr>
<td>INC</td>
<td>加1.</td>
</tr>
<tr>
<td>AAA</td>
<td>加法的ASCII 码调整.</td>
</tr>
<tr>
<td>DAA</td>
<td>加法的十进制调整.</td>
</tr>
<tr>
<td>SUB</td>
<td>减法.</td>
</tr>
<tr>
<td>SBB</td>
<td>带借位减法.</td>
</tr>
<tr>
<td>DEC</td>
<td>减1.</td>
</tr>
<tr>
<td>NEC</td>
<td>求反(以0 减之).</td>
</tr>
<tr>
<td>CMP</td>
<td>比较.(两操作数作减法,仅修改标志位,不回送结果).</td>
</tr>
<tr>
<td>AAS</td>
<td>减法的ASCII 码调整.</td>
</tr>
<tr>
<td>DAS</td>
<td>减法的十进制调整.</td>
</tr>
<tr>
<td>MUL</td>
<td>无符号乘法.</td>
</tr>
<tr>
<td>IMUL</td>
<td>整数乘法.以上两条,结果回送AH 和AL(字节运算),或DX 和AX(字运算),</td>
</tr>
<tr>
<td>AAM</td>
<td>乘法的ASCII 码调整.</td>
</tr>
<tr>
<td>DIV</td>
<td>无符号除法.</td>
</tr>
<tr>
<td>IDIV</td>
<td>整数除法.以上两条,结果回送:商回送AL,余数回送AH, (字节运算);或商回送AX,余数回送DX, (字运算).</td>
</tr>
<tr>
<td>AAD</td>
<td>除法的ASCII 码调整.</td>
</tr>
<tr>
<td>CBW</td>
<td>字节转换为字. (把AL 中字节的符号扩展到AH 中去)</td>
</tr>
<tr>
<td>CWD</td>
<td>字转换为双字. (把AX 中的字的符号扩展到DX 中去)</td>
</tr>
<tr>
<td>CWDE</td>
<td>字转换为双字. (把AX 中的字符号扩展到EAX 中去)</td>
</tr>
<tr>
<td>CDQ</td>
<td>双字扩展. (把EAX 中的字的符号扩展到EDX 中去)</td>
</tr>
</tbody></table>
<h3 id="13-6-3-逻辑运算指令"><a href="#13-6-3-逻辑运算指令" class="headerlink" title="13.6.3 逻辑运算指令"></a>13.6.3 逻辑运算指令</h3><table>
<thead>
<tr>
<th>指令</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>AND</td>
<td>与运算.</td>
</tr>
<tr>
<td>OR</td>
<td>或运算.</td>
</tr>
<tr>
<td>XOR</td>
<td>异或运算.</td>
</tr>
<tr>
<td>NOT</td>
<td>取反.</td>
</tr>
<tr>
<td>TEST</td>
<td>测试.(两操作数作与运算,仅修改标志位,不回送结果).</td>
</tr>
<tr>
<td>SHL</td>
<td>逻辑左移.</td>
</tr>
<tr>
<td>SAL</td>
<td>算术左移.(=SHL)</td>
</tr>
<tr>
<td>SHR</td>
<td>逻辑右移.</td>
</tr>
<tr>
<td>SAR</td>
<td>算术右移.(=SHR)</td>
</tr>
<tr>
<td>ROL</td>
<td>循环左移.</td>
</tr>
<tr>
<td>ROR</td>
<td>循环右移.</td>
</tr>
<tr>
<td>RCL</td>
<td>通过进位的循环左移.</td>
</tr>
<tr>
<td>RCR</td>
<td>通过进位的循环右移.</td>
</tr>
</tbody></table>
<p>以上八种移位指令,其移位次数可达255 次.<br>移位一次时, 可直接用操作码. 如SHL AX,1.<br>移位&gt;1 次时, 则由寄存器CL 给出移位次数.<br>如MOV CL,04<br>SHL AX,CL</p>
<h3 id="13-6-4-串指令"><a href="#13-6-4-串指令" class="headerlink" title="13.6.4 串指令"></a>13.6.4 串指令</h3><table>
<thead>
<tr>
<th>指令</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>DS:SI</td>
<td>源串段寄存器:源串变址.</td>
</tr>
<tr>
<td>ES:DI</td>
<td>目标串段寄存器:目标串变址.</td>
</tr>
<tr>
<td>CX</td>
<td>重复次数计数器.</td>
</tr>
<tr>
<td>AL/AX 扫描值.</td>
<td></td>
</tr>
<tr>
<td>D</td>
<td>标志0 表示重复操作中SI 和DI 应自动增量; 1 表示应自动减量.</td>
</tr>
<tr>
<td>Z</td>
<td>标志用来控制扫描或比较操作的结束.</td>
</tr>
<tr>
<td>MOVS</td>
<td>串传送.( MOVSB 传送字符. MOVSW 传送字. MOVSD 传送双字. )</td>
</tr>
<tr>
<td>CMPS</td>
<td>串比较.( CMPSB 比较字符. CMPSW 比较字. )</td>
</tr>
<tr>
<td>SCAS</td>
<td>串扫描.把AL 或AX 的内容与目标串作比较,比较结果反映在标志位.</td>
</tr>
<tr>
<td>LODS</td>
<td>装入串.把源串中的元素(字或字节)逐一装入AL 或AX 中.( LODSB 传送字符. LODSW 传送字. LODSD 传送双字. )</td>
</tr>
<tr>
<td>STOS</td>
<td>保存串. 是LODS 的逆过程.</td>
</tr>
<tr>
<td>REP</td>
<td>当CX/ECX&lt;&gt;0 时重复.</td>
</tr>
<tr>
<td>REPE/REPZ</td>
<td>当ZF=1 或比较结果相等,且CX/ECX&lt;&gt;0 时重复.</td>
</tr>
<tr>
<td>REPNE/REPNZ</td>
<td>当ZF=0 或比较结果不相等,且CX/ECX&lt;&gt;0 时重复.</td>
</tr>
<tr>
<td>REPC</td>
<td>当CF=1 且CX/ECX&lt; &gt;0 时重复.</td>
</tr>
<tr>
<td>REPNC</td>
<td>当CF=0 且CX/ECX&lt;&gt;0 时重复.</td>
</tr>
</tbody></table>
<h2 id="13-6-5-程序转移指令"><a href="#13-6-5-程序转移指令" class="headerlink" title="13.6.5 程序转移指令"></a>13.6.5 程序转移指令</h2><ol>
<li><p>无条件转移指令(长转移)</p>
</li>
<li><table>
<thead>
<tr>
<th>指令</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>JMP</td>
<td>无条件转移指令</td>
</tr>
<tr>
<td>CALL</td>
<td>过程调用</td>
</tr>
<tr>
<td>RET/RETF</td>
<td>过程返回.</td>
</tr>
</tbody></table>
</li>
<li><p>条件转移指令(短转移,-128 到+127 的距离内)<br>( 当且仅当(SF XOR OF)=1 时,OP1&lt;OP2 )</p>
</li>
</ol>
<table>
<thead>
<tr>
<th>指令</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>JA/JNBE</td>
<td>不小于或不等于时转移.</td>
</tr>
<tr>
<td>JAE/JNB</td>
<td>大于或等于转移.</td>
</tr>
<tr>
<td>JB/JNAE</td>
<td>小于转移.</td>
</tr>
<tr>
<td>JBE/JNA</td>
<td>小于或等于转移.<br>以上四条,测试无符号整数运算的结果(标志C 和Z).</td>
</tr>
<tr>
<td>JG/JNLE</td>
<td>大于转移.</td>
</tr>
<tr>
<td>JGE/JNL</td>
<td>大于或等于转移.</td>
</tr>
<tr>
<td>JL/JNGE</td>
<td>小于转移.</td>
</tr>
<tr>
<td>JLE/JNG</td>
<td>小于或等于转移.<br>以上四条,测试带符号整数运算的结果(标志S,O 和Z).</td>
</tr>
<tr>
<td>JE/JZ</td>
<td>等于转移.</td>
</tr>
<tr>
<td>JNE/JNZ</td>
<td>不等于时转移.</td>
</tr>
<tr>
<td>JC</td>
<td>有进位时转移.</td>
</tr>
<tr>
<td>JNC</td>
<td>无进位时转移.</td>
</tr>
<tr>
<td>JNO</td>
<td>不溢出时转移.</td>
</tr>
<tr>
<td>JNP/JPO</td>
<td>奇偶性为奇数时转移.</td>
</tr>
<tr>
<td>JNS</td>
<td>符号位为”0” 时转移.</td>
</tr>
<tr>
<td>JO</td>
<td>溢出转移.</td>
</tr>
<tr>
<td>JP/JPE</td>
<td>奇偶性为偶数时转移.</td>
</tr>
<tr>
<td>JS</td>
<td>符号位为”1” 时转移.</td>
</tr>
</tbody></table>
<ol start="3">
<li>循环控制指令(短转移)</li>
</ol>
<table>
<thead>
<tr>
<th>指令</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>LOOP</td>
<td>CX 不为零时循环.</td>
</tr>
<tr>
<td>LOOPE/LOOPZ</td>
<td>CX 不为零且标志Z=1 时循环.</td>
</tr>
<tr>
<td>LOOPNE/LOOPNZ</td>
<td>CX 不为零且标志Z=0 时循环.</td>
</tr>
<tr>
<td>JCXZ</td>
<td>CX 为零时转移.</td>
</tr>
<tr>
<td>JECXZ</td>
<td>ECX 为零时转移.</td>
</tr>
</tbody></table>
<ol start="4">
<li>中断指令</li>
</ol>
<table>
<thead>
<tr>
<th>指令</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>INT</td>
<td>中断指令</td>
</tr>
<tr>
<td>INTO</td>
<td>溢出中断</td>
</tr>
<tr>
<td>IRET</td>
<td>中断返回</td>
</tr>
</tbody></table>
<ol start="5">
<li>处理器控制指令</li>
</ol>
<table>
<thead>
<tr>
<th>指令</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>HLT</td>
<td>处理器暂停, 直到出现中断或复位信号才继续.</td>
</tr>
<tr>
<td>WAIT</td>
<td>当芯片引线TEST 为高电平时使CPU 进入等待状态.</td>
</tr>
<tr>
<td>ESC</td>
<td>转换到外处理器.</td>
</tr>
<tr>
<td>LOCK</td>
<td>封锁总线.</td>
</tr>
<tr>
<td>NOP</td>
<td>空操作.</td>
</tr>
<tr>
<td>STC</td>
<td>置进位标志位.</td>
</tr>
<tr>
<td>CLC</td>
<td>清进位标志位.</td>
</tr>
<tr>
<td>CMC</td>
<td>进位标志取反.</td>
</tr>
<tr>
<td>STD</td>
<td>置方向标志位.</td>
</tr>
<tr>
<td>CLD</td>
<td>清方向标志位.</td>
</tr>
<tr>
<td>STI</td>
<td>置中断允许位.</td>
</tr>
<tr>
<td>CLI</td>
<td>清中断允许位.</td>
</tr>
</tbody></table>
<h3 id="13-6-6-伪指令"><a href="#13-6-6-伪指令" class="headerlink" title="13.6.6 伪指令"></a>13.6.6 伪指令</h3><table>
<thead>
<tr>
<th>指令</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>DW</td>
<td>定义字(2 字节).</td>
</tr>
<tr>
<td>PROC</td>
<td>定义过程.</td>
</tr>
<tr>
<td>ENDP</td>
<td>过程结束.</td>
</tr>
<tr>
<td>SEGMENT</td>
<td>定义段.</td>
</tr>
<tr>
<td>ASSUME</td>
<td>建立段寄存器寻址.</td>
</tr>
<tr>
<td>ENDS</td>
<td>段结束.</td>
</tr>
<tr>
<td>END</td>
<td>程序结束.</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>理论</category>
        <category>代码编程</category>
      </categories>
      <tags>
        <tag>汇编</tag>
        <tag>二进制</tag>
      </tags>
  </entry>
  <entry>
    <title>网络流量分析（nogotofail））</title>
    <url>/2019/11/10/%E7%BD%91%E7%BB%9C%E6%B5%81%E9%87%8F%E5%88%86%E6%9E%90-nogotofail/</url>
    <content><![CDATA[<h4 id="应用范围"><a href="#应用范围" class="headerlink" title="应用范围"></a>应用范围</h4><p>它包括对常见的SSL证书验证问题(HTTPS和TLS/SSL)的测试<br>库bug、SSL和STARTTLS剥离问题、明文问题等等。</p>
<a id="more"></a>

<h1 id="应用到的库："><a href="#应用到的库：" class="headerlink" title="应用到的库："></a>应用到的库：</h1><h2 id="psutil模块"><a href="#psutil模块" class="headerlink" title="psutil模块"></a>psutil模块</h2><p>psutil是一个<a href="http://pythonhosted.org/psutil/" target="_blank" rel="noopener">跨平台库</a>能够轻松实现获取系统运行的进程和系统利用率（包括CPU、内存、磁盘、网络等）信息。它主要用来做系统监控，性能分析，进程管理。它实现了同等命令行工具提供的功能，如ps、top、lsof、netstat、ifconfig、who、df、kill、free、nice、ionice、iostat、iotop、uptime、pidof、tty、taskset、pmap等。目前支持32位和64位的Linux、Windows、OS X、FreeBSD和Sun Solaris等操作系统.</p>
<h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><figure class="highlight plain"><figcaption><span>install psutil```</span></figcaption><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">### 基本使用</span><br><span class="line">#### 获取CPU时间</span><br></pre></td></tr></table></figure>
<blockquote>
<blockquote>
<blockquote>
<p>psutil.cpu_times()<br>scputimes(user=650613.02, nice=22.14, system=154916.5, idle=16702285.26, iowait=68894.55, irq=3.38, softirq=7075.65, steal=0.0, guest=0.0)</p>
</blockquote>
</blockquote>
</blockquote>
<p>```</p>
<blockquote>
<ol>
<li>psutil.process_iter()<br>遍历所有进程</li>
<li>psutil.version_info[] </li>
<li>psutil.net_connections<br>寻找连接(用户)的个数，在<a href="https://baike.baidu.com/item/mavericks/4902413?fr=aladdin" target="_blank" rel="noopener">OSX</a>中需要root权限</li>
<li>psutil.NoSuchProcess, psutil.AccessDenied</li>
</ol>
</blockquote>
<p><a href="https://www.cnblogs.com/saneri/p/7528283.html" target="_blank" rel="noopener">参考文章</a></p>
<p><a href="https://www.cnblogs.com/lfs2640666960/p/9330735.html" target="_blank" rel="noopener">https://www.cnblogs.com/lfs2640666960/p/9330735.html</a> 介绍的不错</p>
<ol start="5">
<li>bash: 未预期的符号 `newline’ 附近有语法错误:将&lt;&gt;换成’’</li>
</ol>
<h1 id="关于elk"><a href="#关于elk" class="headerlink" title="关于elk"></a>关于elk</h1><ol>
<li>安装<br>yum install -y elasticsearch<br>安装在/usr/share/elasticsearch当中，启动在bin当中的elasticsearch。用./Bin…来启动</li>
</ol>
<ul>
<li>测试运行：curl ‘<a href="http://localhost:9200/?pretty&#39;" target="_blank" rel="noopener">http://localhost:9200/?pretty&#39;</a></li>
<li>会得到<img src="/2019/11/10/%E7%BD%91%E7%BB%9C%E6%B5%81%E9%87%8F%E5%88%86%E6%9E%90-nogotofail/elasticsuccess.jpg" alt></li>
<li>Elasticsearch 的实例。 而一个 集群 是一组拥有相同 cluster.name 的节点， 他们能一起工作并共享数据，还提供容错与可伸缩性。(当然，一个单独的节点也可以组成一个集群) 你可以在 elasticsearch.yml 配置文件中 修改 cluster.name ，该文件会在节点启动时加载 (译者注：这个重启服务后才会生效)。 </li>
<li>而elasticsearch中的.yml在/etc/elasticsearch当中</li>
<li>设置：logstash，netflow，配置</li>
<li>可以用端口9200，web客户端，甚至curl进行交互<br>  curl -X<VERB> ‘<PROTOCOL>://<HOST>:<PORT>/<PATH>?<QUERY_STRING>‘ -d ‘<BODY>‘   <a href="https://www.elastic.co/guide/cn/elasticsearch/guide/current/_talking_to_elasticsearch.html" target="_blank" rel="noopener">使用参考</a></BODY></QUERY_STRING></PATH></PORT></HOST></PROTOCOL></VERB></li>
<li></li>
<li>会遇到问题：Exception in thread “main” org.elasticsearch.bootstrap.BootstrapException: java.nio.file.NoSuchFileException: /usr/share/elasticsearch/config<br>Likely root cause: java.nio.file.NoSuchFileException: /usr/share/elasticsearch/config …<br><a href="https://www.cnblogs.com/yswenli/p/6397351.html" target="_blank" rel="noopener">解决方法</a><br>其实就是： cp -r /etc/elasticsearch /usr/share/elasticsearch/config<br>➜  ~ groupadd elsearch<br>➜  ~ useradd elsearch -g elsearch -p elsearch<br>➜  ~ cd /usr/share<br>➜   chown -R elsearch:elsearch elasticsearch<br>➜  su elsearch<br>这是因为elasticsearch需要读写配置文件，我们需要给予config文件夹权限，上面新建了elsearch用户，elsearch用户不具备读写权限，因此还是会报错，解决方法是切换到管理员账户，赋予权限即可：<br>sudo -i<br>chmod -R 775 config<br><a href="https://www.linuxidc.com/Linux/2018-11/155518.htm" target="_blank" rel="noopener">这篇讲的很全</a></li>
</ul>
<p>安装sense<br>其实这个是Kibana的一个应用<br>安装：yum install -y kibana<br>测试运行也是一样的路径<br>    <a href="http://localhost:5601/app/sense" target="_blank" rel="noopener">http://localhost:5601/app/sense</a><br>这个是emmm，测试？</p>
<p>关于javaAPI交互<br>节点客户端（Node client）<br>    节点客户端作为一个非数据节点加入到本地集群中。换句话说，它本身不保存任何数据，但是它知道数据在集群中的哪个节点中，并且可以把请求转发到正确的节点。<br>传输客户端（Transport client）<br>    轻量级的传输客户端可以将请求发送到远程集群。它本身不加入集群，但是它可以将请求转发到集群中的一个节点上。<br>两个 Java 客户端都是通过 9300 端口并使用 Elasticsearch 的原生 传输 协议和集群交互。集群中的节点通过端口 9300 彼此通信。如果这个端口没有打开，节点将无法形成一个集群。</p>
<h2 id="安装elasticsearch-head遇到的问题"><a href="#安装elasticsearch-head遇到的问题" class="headerlink" title="安装elasticsearch-head遇到的问题"></a>安装elasticsearch-head遇到的问题</h2><ol>
<li>warning: notsup SKIPPING OPTIONAL DEPENDENCY: Unsupported platform for <a href="mailto:fsevents@1.2.4" target="_blank" rel="noopener">fsevents@1.2.4</a>: wanted {“os”<br>这个证明已经安装成功了<br><img src="/2019/11/10/%E7%BD%91%E7%BB%9C%E6%B5%81%E9%87%8F%E5%88%86%E6%9E%90-nogotofail/nmp2.png" alt></li>
<li>npm WARN <a href="mailto:elasticsearch-head@0.0.0" target="_blank" rel="noopener">elasticsearch-head@0.0.0</a> license should be a valid SPDX license expression<br>这个说你的license不对口，得去找找spdx licence是个啥玩意：<br>既然知道spdx是个啥，就不难解决问题了；让我打开正确的姿势：打开elasticsearch-head目录下的package.json文件，找到license位置，修改为上面这个网站上存在Identifier，就可以了。如图所示，把原来的Apache内容修改为Apache-2.0。具体修改后的内容参考官网上的Identifier数值（防止后续更新，授之于渔了）。<br><img src="/2019/11/10/%E7%BD%91%E7%BB%9C%E6%B5%81%E9%87%8F%E5%88%86%E6%9E%90-nogotofail/npm.png" alt></li>
<li>成功！<br><img src="/2019/11/10/%E7%BD%91%E7%BB%9C%E6%B5%81%E9%87%8F%E5%88%86%E6%9E%90-nogotofail/headok.jpg" alt></li>
<li>妈的，又不成功：This account is currently not available（用户当前不可用）<br>安装完elasticsearch之后系统会自动创建一个elasticsearch用户，在启动elasticsearch的时候需要切换该用户启动，但是在我切换到elasticsearch用户的时候显示This account is currently not available。</li>
</ol>
<p>查资料发现是因为该用户的shell不可用，查看/etc/passwd文件发现此用户的shell是/sbin/nologin需修改成/bin/bash</p>
<ol start="5">
<li>elasticsearch-head中cluster health: not connected<br>修改elasticsearch安装目录中 config/elasticsearch.yml<br>http.cors.enabled: true<br>http.cors.allow-origin: “*”<br>修改elasticsearch-head下Gruntfile.js<br>connect: {<br>server: {<br>options: {<br>hostname: ‘0.0.0.0’,<br>port: 9100,<br>base: ‘.’,<br>keepalive: true<br>}<br>}<br>}<br><a href="https://blog.csdn.net/qq_30505673/article/details/85051785" target="_blank" rel="noopener">原文链接</a></li>
</ol>
]]></content>
      <categories>
        <category>理论</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>网络流量</tag>
      </tags>
  </entry>
  <entry>
    <title>算法实验</title>
    <url>/2019/11/10/%E7%AE%97%E6%B3%95%E5%AE%9E%E9%AA%8C/</url>
    <content><![CDATA[<h4 id="简介：包括线性时间算法，最长递增子序列，以斐波那契堆实现迪杰斯特拉算法"><a href="#简介：包括线性时间算法，最长递增子序列，以斐波那契堆实现迪杰斯特拉算法" class="headerlink" title="简介：包括线性时间算法，最长递增子序列，以斐波那契堆实现迪杰斯特拉算法"></a>简介：包括线性时间算法，最长递增子序列，以斐波那契堆实现迪杰斯特拉算法</h4><a id="more"></a>
<h2 id="1-线性时间选择（序数问题）"><a href="#1-线性时间选择（序数问题）" class="headerlink" title="1. 线性时间选择（序数问题）"></a>1. 线性时间选择（序数问题）</h2><ul>
<li>问题描述：已知n个数，找出排序后第k小的数。要求平均时间复杂度为O(n)。</li>
<li>解决思路：使用快速排序的思想解决查找问题，用随机数（舍伍德算法）解决基准问题，用分治策略搭建整体的算法结构。</li>
<li>步骤分析：<br>(1)    使用舍伍德算法选择基准r（第r个数）<br>(2)    用快速排序算法进行下面的操作：将大于基准的数值放于基准后，将小于基准的数值放于基准前，刷新数组的排序。<br>(3)    若想要查找的第k个数值的k比基准r大，则取数组的右边再重复进行以上操作，若小于，则选择左边的，若等于，则输出。</li>
<li>示例：<br><img src="/2019/11/10/%E7%AE%97%E6%B3%95%E5%AE%9E%E9%AA%8C/example1.png" alt><blockquote>
<p>示例分析：输入10个数，分别为5 2 7 8 9 0 1 3 4 6，第5小的元素为4，验证成功。</p>
</blockquote>
</li>
</ul>
<h2 id="2-最长递增子序列问题"><a href="#2-最长递增子序列问题" class="headerlink" title="2. 最长递增子序列问题"></a>2. 最长递增子序列问题</h2><ul>
<li>问题描述：寻找最长递增的序列。</li>
<li>解决思路：利用矩阵记录之前的结果，用动态规划法完成寻找</li>
<li>算法步骤：<br>(1)    设置变量有：存储当前最长序列的值的数组tempmax，存储最长序列长度maxlen存储最长序列的最大值下标maxindex<br>(2)    从下标为1的值开始遍历<br>(3)    若i下标下的值比前一个值大，则更新tempmax[i]=tempmax[i-1]+1，即增加长度1，若此时的tempmaxp[i]比maxlen大，则更新maxlen，且更新maxindex=1</li>
<li>示例：<br><img src="/2019/11/10/%E7%AE%97%E6%B3%95%E5%AE%9E%E9%AA%8C/example2.png" alt><br>示例分析：<blockquote>
<p>输入10个数分别为1 3 2 4 5 3 7 8 9 6，其最长递增子序列为3 7 8 9，长度为4，验证成功。</p>
</blockquote>
</li>
</ul>
<h2 id="3-斐波那契堆实现最短路径算法（迪杰斯特拉）"><a href="#3-斐波那契堆实现最短路径算法（迪杰斯特拉）" class="headerlink" title="3. 斐波那契堆实现最短路径算法（迪杰斯特拉）"></a>3. 斐波那契堆实现最短路径算法（迪杰斯特拉）</h2><ul>
<li>问题描述：用斐波那契堆取最小路径辅助迪杰斯特拉算法实现最小路径算法</li>
<li>解决思路：1. 使用贪心算法实现迪杰斯特拉最短路径算法，使用斐波那契堆建立最小堆，方便取最小‘结点’以完成接下来的操作</li>
<li>算法思想：</li>
</ul>
<ol>
<li><p>迪杰斯特拉伪代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">DIJKSTRA(G, w, s)</span><br><span class="line">INITIALIZE - SINGLE - SOURCE(G, s)</span><br><span class="line">S ← Ø</span><br><span class="line">Q ← V[G]   //第3行，INSERT操作，O（1）构造堆</span><br><span class="line">while Q ≠ Ø</span><br><span class="line">	do u ← EXTRACT - MIN(Q)   //第5行，从堆中取出最小点</span><br><span class="line">      S ← S ∪&#123; u &#125;</span><br><span class="line">      for each vertex v ∈ Adj[u]</span><br><span class="line">          do RELAX(u, v, w)  //第8行，RELAX操作，对堆进行降级工作</span><br></pre></td></tr></table></figure></li>
<li><p>其中在第5行的EXTRACT-MIN操作用斐波那契堆实现，斐波那契堆结构如下:</p>
<blockquote>
<ul>
<li>斐波那契堆是由一组最小堆有序树构成的。每个节点的度数为其子节点的数目。树的度数为其根节点的度数。</li>
<li>斐波那契堆中的树都是有根的但是无序。每个节点x包含指向父节点的指针p[x]和指向任意一个子结点的child[x]。x的所有子节点都用双向循环链表链接起来，叫做x的子链表。子链表中的每一个节点y都有指向它的左兄弟的left[y]和右兄弟的right[y]。如果节点y是x仅有的子节点，则left[y]=right[y]=y。</li>
<li>斐波那契堆中所有树的根节点也用一个双向循环链表链接起来。使用一个指针指向斐波那契堆中最小元素。</li>
</ul>
</blockquote>
</li>
<li><p>用稀疏矩阵表示图，定义为weight</p>
</li>
<li><p>具体实现示例分析：<br><img src="/2019/11/10/%E7%AE%97%E6%B3%95%E5%AE%9E%E9%AA%8C/example3-1.png" alt></p>
<blockquote>
<p>其矩阵如：<br> {0,4,NoEdge,2,NoEdge},<br> {4,0,4,1,NoEdge},<br> {NoEdge,4,0,1,3},<br> {2,1,1,0,7},<br>{NoEdge,NoEdge,3,7,0}<br>最终应该得到结果：<br>a-&gt;a=0<br>a-&gt;d-&gt;b=3<br>a-&gt;d-&gt;c=3<br>a-&gt;d=2<br>a-&gt;d-&gt;c-&gt;e=6</p>
</blockquote>
<p> <img src="/2019/11/10/%E7%AE%97%E6%B3%95%E5%AE%9E%E9%AA%8C/example3-2.png" alt="a"><br>测试成功！</p>
</li>
</ol>
]]></content>
      <categories>
        <category>代码编程</category>
      </categories>
      <tags>
        <tag>课程</tag>
        <tag>算法</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2019/11/10/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p>
<a id="more"></a>

<h2 id="HEXO常用："><a href="#HEXO常用：" class="headerlink" title="HEXO常用："></a>HEXO常用：</h2><h3 id="新建文章"><a href="#新建文章" class="headerlink" title="新建文章"></a>新建文章</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p>
<h3 id="启动本地镜像服务"><a href="#启动本地镜像服务" class="headerlink" title="启动本地镜像服务"></a>启动本地镜像服务</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p>
<h3 id="生成静态文件"><a href="#生成静态文件" class="headerlink" title="生成静态文件"></a>生成静态文件</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p>
<h3 id="上传文件（同步）"><a href="#上传文件（同步）" class="headerlink" title="上传文件（同步）"></a>上传文件（同步）</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br><span class="line">$ hexo d 也可</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p>
<h2 id="常要注意的玩意："><a href="#常要注意的玩意：" class="headerlink" title="常要注意的玩意："></a>常要注意的玩意：</h2><h3 id="hexo图片问题"><a href="#hexo图片问题" class="headerlink" title="hexo图片问题"></a><a href="https://www.jianshu.com/p/3db6a61d3782" target="_blank" rel="noopener">hexo图片问题</a></h3><h3 id="hexo阅读更多"><a href="#hexo阅读更多" class="headerlink" title="hexo阅读更多"></a>hexo阅读更多</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install hexo-generator-index2 --save</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># index2 generator是否包含官方的hexo-generator-index，默认true（包含）</span><br><span class="line">index2_include_index: true</span><br><span class="line">index2_generator:</span><br><span class="line">    per_page: 8</span><br><span class="line">    order_by: -date # 按发布时间排序</span><br><span class="line">    exclude:</span><br><span class="line">        - tag hide # 不包含标签为hide的文章</span><br><span class="line">        - category hide # 不包含分类为hide的文章</span><br></pre></td></tr></table></figure>
<p>然后</p>
<h2 id="博客设置问题："><a href="#博客设置问题：" class="headerlink" title="博客设置问题："></a>博客设置问题：</h2><h3 id="头像-amp-图标："><a href="#头像-amp-图标：" class="headerlink" title="头像&amp;图标："></a>头像&amp;图标：</h3><p>在主题目录下配置文件中.<br>头像：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">author:</span><br><span class="line">  name: DuK</span><br><span class="line">  work: Study,0-1</span><br><span class="line">  location: China</span><br><span class="line">  avatar_url: /images/avatar.png</span><br></pre></td></tr></table></figure>
<p>而其图标：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">favicon: /images/favicon.ico</span><br></pre></td></tr></table></figure>
<p>网站：<a href="http://www.faviconico.org/" target="_blank" rel="noopener">图标制作</a></p>
<h3 id="侧边栏目（标签，归档）"><a href="#侧边栏目（标签，归档）" class="headerlink" title="侧边栏目（标签，归档）"></a>侧边栏目（标签，归档）</h3><p>得先进行</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo new page tags</span><br></pre></td></tr></table></figure>
<p>然后才会有，这里tags还要加上：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: tags</span><br><span class="line">date: 2019-11-10 11:36:27</span><br><span class="line">layout: tags</span><br><span class="line">---</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>配置</tag>
        <tag>博客</tag>
        <tag>指令</tag>
      </tags>
  </entry>
</search>
