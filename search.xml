<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>工具OllyDbg的使用</title>
    <url>/2019/11/10/%E5%B7%A5%E5%85%B7OllyDbg%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>汇编语言(入门学习)</title>
    <url>/2019/11/10/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80-%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<h4 id="简介：本篇旨在对汇编的基础知识进行汇总，汇总的都是要点（简明扼要），目前还在更新中。"><a href="#简介：本篇旨在对汇编的基础知识进行汇总，汇总的都是要点（简明扼要），目前还在更新中。" class="headerlink" title="简介：本篇旨在对汇编的基础知识进行汇总，汇总的都是要点（简明扼要），目前还在更新中。"></a>简介：本篇旨在对汇编的基础知识进行汇总，汇总的都是要点（简明扼要），目前还在更新中。</h4><a id="more"></a>
<h1 id="第一章-基础知识"><a href="#第一章-基础知识" class="headerlink" title="第一章 基础知识"></a>第一章 基础知识</h1><h2 id="1-1-存储单元"><a href="#1-1-存储单元" class="headerlink" title="1.1 存储单元"></a>1.1 存储单元</h2><p>一个存储单元存储的信息量以<strong>bit</strong>为单位（最小）。而转换关系中8 bit=1 bytes(B)。而一个字=两个字节<br>在微型计算机存储器的存储单元中，一个单元可以存<strong>1 B</strong>（即8个进制位）。而一个存储器有128个单元，则可以存储128 B。</p>
<h2 id="1-2-CPU对存储器的读写"><a href="#1-2-CPU对存储器的读写" class="headerlink" title="1.2 CPU对存储器的读写"></a>1.2 CPU对存储器的读写</h2><p>要读写，则应该与三类信息进行交互：</p>
<blockquote>
<ol>
<li>地址信息</li>
<li>控制信息</li>
<li>数据信息</li>
</ol>
</blockquote>
<p>而逻辑上又分为3类总线，分别传输信息：</p>
<blockquote>
<ol>
<li>地址总线（指出内存中的信息放在那里(自下而上读01)）</li>
<li>控制总线（若要传输的数据多于一次性传输的宽度，则分开来多传几次）</li>
<li>数据总线</li>
</ol>
</blockquote>
<h3 id="影响性能的因素："><a href="#影响性能的因素：" class="headerlink" title="影响性能的因素："></a>影响性能的因素：</h3><h4 id="宽度（线的条数）：它决定了部件的能力（速度，控制能力等）。8086为16条，8088为8条"><a href="#宽度（线的条数）：它决定了部件的能力（速度，控制能力等）。8086为16条，8088为8条" class="headerlink" title="宽度（线的条数）：它决定了部件的能力（速度，控制能力等）。8086为16条，8088为8条"></a>宽度（线的条数）：它决定了部件的能力（速度，控制能力等）。8086为16条，8088为8条</h4><blockquote>
<p>若CPU的寻址能力为8KB，则总线宽度：8*1024/1 = 2**13 (注意单位是B,13则为总线宽度)</p>
</blockquote>
<h1 id="第二章-寄存器"><a href="#第二章-寄存器" class="headerlink" title="第二章 寄存器"></a>第二章 寄存器</h1><h2 id="2-1-通用寄存器"><a href="#2-1-通用寄存器" class="headerlink" title="2.1 通用寄存器"></a>2.1 通用寄存器</h2><p>有<strong>AX BX CX DX</strong>四种，它们分为高位和低位以兼容以前的程序，如（AX = AH(高) + AL(低)）<br><em>要注意的是：若只用AL进行运算，若超出其范围，超出的数据不会到AH当中！</em></p>
<h2 id="2-2-CPU给出物理地址的方法"><a href="#2-2-CPU给出物理地址的方法" class="headerlink" title="2.2 CPU给出物理地址的方法"></a>2.2 CPU给出物理地址的方法</h2><blockquote>
<p>段地址(<strong>SA</strong>)：只是为了内存的管理，并不是真分段。16位地址分段，一段64KB<br>偏移地址(<strong>EA</strong>)：16位地址最多64KB<br>公式：物理地址=段地址*16+偏移地址</p>
</blockquote>
<h2 id="2-2-段寄存器"><a href="#2-2-段寄存器" class="headerlink" title="2.2 段寄存器"></a>2.2 段寄存器</h2><p>有<strong>CS DS SS ES</strong>四种。CS常存储段地址。它们提供了一下功能：</p>
<ol>
<li>CS：CPU要<strong>执行指令</strong>的地址。相当于命令指针</li>
<li>DS：读取内存的地址（返回数据）。相当于数据指针</li>
<li>SS：存储内存中的栈的顶。相当于栈顶指针<h3 id="CS和IP"><a href="#CS和IP" class="headerlink" title="CS和IP"></a>CS和IP</h3>IP是存储基于CS的偏移量。修改的流程：<blockquote>
<p>一般流程：读取指令 -&gt; 修改 IP+=<em>命令长度</em> -&gt; 执行指令(可能会涉及修改CS:IP) -&gt; 读取指令…<br><em>8086PC启动时在FFFF0H单元中读取指令执行</em></p>
</blockquote>
</li>
</ol>
<h2 id="2-3-疑问"><a href="#2-3-疑问" class="headerlink" title="2.3 疑问"></a>2.3 疑问</h2><h3 id="1-为什么偏移地址只能在64Kb内？"><a href="#1-为什么偏移地址只能在64Kb内？" class="headerlink" title="1. 为什么偏移地址只能在64Kb内？"></a>1. 为什么偏移地址只能在64Kb内？</h3><p>一个16位的CPU，只能有1111 1111 1111 1111，代表了4个16进制数，所以能表示2**16 bit的数据，恰好，就是64Kb。</p>
<h3 id="2-暂留"><a href="#2-暂留" class="headerlink" title="2.暂留"></a>2.暂留</h3><h1 id="第三章-寄存器（内存访问）"><a href="#第三章-寄存器（内存访问）" class="headerlink" title="第三章 寄存器（内存访问）"></a>第三章 寄存器（内存访问）</h1><h2 id="3-1-内存中字的存储"><a href="#3-1-内存中字的存储" class="headerlink" title="3.1 内存中字的存储"></a>3.1 内存中字的存储</h2><blockquote>
<p>字单元的概念：即存放一个字型数据的内存单元，由<strong>两个地址连续</strong>的内存单元（一个8位）组成。高放高位，低放低位。</p>
</blockquote>
<p>这里解释一下： 若有单元[0]-&gt;2e [1]-&gt;33，那么我们读[0]的字型数据为：332eH（高放高位）</p>
<h2 id="3-2-DS和-address"><a href="#3-2-DS和-address" class="headerlink" title="3.2 DS和[address]"></a>3.2 DS和[address]</h2><blockquote>
<p>“[…]”表示一个内存单元，表示在段地址下的偏移量。如10000H = 1000:0 = [0]</p>
</blockquote>
<p>注意，ds是自动加上的，如果使用[]的话，而且他（段寄存器）是不能直接用mov命令改变的，必须通过其他的寄存器中转才能改变。</p>
<h2 id="3-3-字的传送（mov指令）"><a href="#3-3-字的传送（mov指令）" class="headerlink" title="3.3 字的传送（mov指令）"></a>3.3 字的传送（mov指令）</h2><p>在传送字之后， DS和[address]也会跟着变，如1000:0，若传入一个fffeH，则address会从0-&gt;2，此时，[0]存有feH，[1]存有ffH,[2]为空。</p>
<h2 id="3-4-mov、add、sub指令"><a href="#3-4-mov、add、sub指令" class="headerlink" title="3.4 mov、add、sub指令"></a>3.4 mov、add、sub指令</h2><p>主要是说说置零问题，与机械码长度问题，稍微提一下，以后会细讲。<br>举例子：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sub bx, bx</span><br><span class="line">mov bx, 0</span><br></pre></td></tr></table></figure>
<p>两个都是可以将bx寄存器置零的指令，但是sub的机械码长度为2，而mov为3，用sub更好。<br>另外说说jmp指令，他是转移指令，具有一个操作对象的指令，而上面的具有两个。</p>
<h2 id="3-5-栈"><a href="#3-5-栈" class="headerlink" title="3.5 栈"></a>3.5 栈</h2><p>他是一个FILO结构（先入后出），而且是从大变小（地址）。</p>
<h3 id="1-push和pop"><a href="#1-push和pop" class="headerlink" title="1.push和pop"></a>1.push和pop</h3><blockquote>
<p>执行push ax命令，会把ax中的数据传入ss:sp指向的地址空间。此时<strong>sp-=2</strong><br>执行pop ax命令，会把ss:sp指向的地址空间中的数据传给ax。此时<strong>sp+=2</strong></p>
</blockquote>
<p>执行之后的指针变化：</p>
<ul>
<li>push先令sp-=2，然后将ax中的数据放进去。称为出栈。</li>
<li>pop是先取出数据放到ax中，再sp+=2。称为入栈。</li>
</ul>
<p><img src="/2019/11/10/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80-%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0/3.5.png" alt></p>
<h3 id="2-数据传输"><a href="#2-数据传输" class="headerlink" title="2.数据传输"></a>2.数据传输</h3><p>如8086cpu的入栈和出栈都是以<strong>字</strong>为单位进行的。</p>
<h3 id="3-栈指针"><a href="#3-栈指针" class="headerlink" title="3.栈指针"></a>3.栈指针</h3><p>上面已经用到了：段寄存器:寄存器存储(ss:sp)<br>sp是指偏移地址，ss:sp始终指向栈顶。</p>
<h2 id="3-6-栈顶越界问题"><a href="#3-6-栈顶越界问题" class="headerlink" title="3.6 栈顶越界问题"></a>3.6 栈顶越界问题</h2><p>栈溢出问题都是大问题，如果栈顶越界了，那么执行push和pop会受影响吗？当然不会！直接刚，写！写！写！出！出！出！管你呢。<br>所以就会有可能读了其他程序的数据，或者<strong>修改了（覆盖）</strong>其他程序的数据（直接崩溃的说）<br>执行情况（取自《汇编语言第二版》王爽著）<br><img src="/2019/11/10/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80-%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0/3.6.jpg" alt></p>
<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><h3 id="1-程序与数据有区别吗？"><a href="#1-程序与数据有区别吗？" class="headerlink" title="1.程序与数据有区别吗？"></a>1.程序与数据有区别吗？</h3><p>可以说有，也可以说没有。由于指令都是0和1组成的，只是用不同功能的段地址读出来的不一样，如,CS和DS都指向10000H，那么，CS会将里头的数据转化为机械码，执行指令，而DS就直接读数据，作为单纯的数据使用。</p>
<h3 id="2-空栈如（10000H-1000FH）此时ss-1000H，那么sp是多少？"><a href="#2-空栈如（10000H-1000FH）此时ss-1000H，那么sp是多少？" class="headerlink" title="2.空栈如（10000H~1000FH）此时ss=1000H，那么sp是多少？"></a>2.空栈如（10000H~1000FH）此时ss=1000H，那么sp是多少？</h3><p>因为是自下而上（自大到小），所以sp=0010H。<br>换一种方式看，若存储了一个数据，则一个存到000EH，一个存到000FH，此时的栈指针在栈顶，当然指向000EH了，此时是已经让sp-=2了，那么回溯一下，不就有sp=0010H了。</p>
<ul>
<li>好了，问题来了，如果将（10000H~1FFFFH）作为空间呢？<br>答案：sp=0000H，因为，不能变成10000H(笑)</li>
</ul>
<h3 id="3-栈会溢出，那么，为什么不设置栈大小"><a href="#3-栈会溢出，那么，为什么不设置栈大小" class="headerlink" title="3.栈会溢出，那么，为什么不设置栈大小"></a>3.栈会溢出，那么，为什么不设置栈大小</h3><p>emmm，可惜8086cpu就是没有，所以变成自己注意。</p>
<h3 id="4-只有mov可以完成传输数据吗？"><a href="#4-只有mov可以完成传输数据吗？" class="headerlink" title="4.只有mov可以完成传输数据吗？"></a>4.只有mov可以完成传输数据吗？</h3><p>push也可以哦，只要把sp定位为ds:[address]那就好了哦。直接写进去。</p>
]]></content>
      <categories>
        <category>理论</category>
        <category>代码编程</category>
      </categories>
      <tags>
        <tag>汇编</tag>
        <tag>二进制</tag>
      </tags>
  </entry>
  <entry>
    <title>网络流量分析（nogotofail））</title>
    <url>/2019/11/10/%E7%BD%91%E7%BB%9C%E6%B5%81%E9%87%8F%E5%88%86%E6%9E%90-nogotofail/</url>
    <content><![CDATA[<h1 id="应用范围"><a href="#应用范围" class="headerlink" title="应用范围"></a>应用范围</h1><p>它包括对常见的SSL证书验证问题(HTTPS和TLS/SSL)的测试<br>库bug、SSL和STARTTLS剥离问题、明文问题等等。</p>
]]></content>
      <categories>
        <category>理论</category>
      </categories>
      <tags>
        <tag>网络流量</tag>
      </tags>
  </entry>
  <entry>
    <title>算法实验</title>
    <url>/2019/11/10/%E7%AE%97%E6%B3%95%E5%AE%9E%E9%AA%8C/</url>
    <content><![CDATA[<h4 id="简介：包括线性时间算法，最长递增子序列，以斐波那契堆实现迪杰斯特拉算法"><a href="#简介：包括线性时间算法，最长递增子序列，以斐波那契堆实现迪杰斯特拉算法" class="headerlink" title="简介：包括线性时间算法，最长递增子序列，以斐波那契堆实现迪杰斯特拉算法"></a>简介：包括线性时间算法，最长递增子序列，以斐波那契堆实现迪杰斯特拉算法</h4><a id="more"></a>
<h2 id="1-线性时间选择（序数问题）"><a href="#1-线性时间选择（序数问题）" class="headerlink" title="1. 线性时间选择（序数问题）"></a>1. 线性时间选择（序数问题）</h2><ul>
<li>问题描述：已知n个数，找出排序后第k小的数。要求平均时间复杂度为O(n)。</li>
<li>解决思路：使用快速排序的思想解决查找问题，用随机数（舍伍德算法）解决基准问题，用分治策略搭建整体的算法结构。</li>
<li>步骤分析：<br>(1)    使用舍伍德算法选择基准r（第r个数）<br>(2)    用快速排序算法进行下面的操作：将大于基准的数值放于基准后，将小于基准的数值放于基准前，刷新数组的排序。<br>(3)    若想要查找的第k个数值的k比基准r大，则取数组的右边再重复进行以上操作，若小于，则选择左边的，若等于，则输出。</li>
<li>示例：<br><img src="/2019/11/10/%E7%AE%97%E6%B3%95%E5%AE%9E%E9%AA%8C/example1.png" alt><blockquote>
<p>示例分析：输入10个数，分别为5 2 7 8 9 0 1 3 4 6，第5小的元素为4，验证成功。</p>
</blockquote>
</li>
</ul>
<h2 id="2-最长递增子序列问题"><a href="#2-最长递增子序列问题" class="headerlink" title="2. 最长递增子序列问题"></a>2. 最长递增子序列问题</h2><ul>
<li>问题描述：寻找最长递增的序列。</li>
<li>解决思路：利用矩阵记录之前的结果，用动态规划法完成寻找</li>
<li>算法步骤：<br>(1)    设置变量有：存储当前最长序列的值的数组tempmax，存储最长序列长度maxlen存储最长序列的最大值下标maxindex<br>(2)    从下标为1的值开始遍历<br>(3)    若i下标下的值比前一个值大，则更新tempmax[i]=tempmax[i-1]+1，即增加长度1，若此时的tempmaxp[i]比maxlen大，则更新maxlen，且更新maxindex=1</li>
<li>示例：<br><img src="/2019/11/10/%E7%AE%97%E6%B3%95%E5%AE%9E%E9%AA%8C/example2.png" alt><br>示例分析：<blockquote>
<p>输入10个数分别为1 3 2 4 5 3 7 8 9 6，其最长递增子序列为3 7 8 9，长度为4，验证成功。</p>
</blockquote>
</li>
</ul>
<h2 id="3-斐波那契堆实现最短路径算法（迪杰斯特拉）"><a href="#3-斐波那契堆实现最短路径算法（迪杰斯特拉）" class="headerlink" title="3. 斐波那契堆实现最短路径算法（迪杰斯特拉）"></a>3. 斐波那契堆实现最短路径算法（迪杰斯特拉）</h2><ul>
<li>问题描述：用斐波那契堆取最小路径辅助迪杰斯特拉算法实现最小路径算法</li>
<li>解决思路：1. 使用贪心算法实现迪杰斯特拉最短路径算法，使用斐波那契堆建立最小堆，方便取最小‘结点’以完成接下来的操作</li>
<li>算法思想：</li>
</ul>
<ol>
<li><p>迪杰斯特拉伪代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">DIJKSTRA(G, w, s)</span><br><span class="line">INITIALIZE - SINGLE - SOURCE(G, s)</span><br><span class="line">S ← Ø</span><br><span class="line">Q ← V[G]   //第3行，INSERT操作，O（1）构造堆</span><br><span class="line">while Q ≠ Ø</span><br><span class="line">	do u ← EXTRACT - MIN(Q)   //第5行，从堆中取出最小点</span><br><span class="line">      S ← S ∪&#123; u &#125;</span><br><span class="line">      for each vertex v ∈ Adj[u]</span><br><span class="line">          do RELAX(u, v, w)  //第8行，RELAX操作，对堆进行降级工作</span><br></pre></td></tr></table></figure></li>
<li><p>其中在第5行的EXTRACT-MIN操作用斐波那契堆实现，斐波那契堆结构如下:</p>
<blockquote>
<ul>
<li>斐波那契堆是由一组最小堆有序树构成的。每个节点的度数为其子节点的数目。树的度数为其根节点的度数。</li>
<li>斐波那契堆中的树都是有根的但是无序。每个节点x包含指向父节点的指针p[x]和指向任意一个子结点的child[x]。x的所有子节点都用双向循环链表链接起来，叫做x的子链表。子链表中的每一个节点y都有指向它的左兄弟的left[y]和右兄弟的right[y]。如果节点y是x仅有的子节点，则left[y]=right[y]=y。</li>
<li>斐波那契堆中所有树的根节点也用一个双向循环链表链接起来。使用一个指针指向斐波那契堆中最小元素。</li>
</ul>
</blockquote>
</li>
<li><p>用稀疏矩阵表示图，定义为weight</p>
</li>
<li><p>具体实现示例分析：<br><img src="/2019/11/10/%E7%AE%97%E6%B3%95%E5%AE%9E%E9%AA%8C/example3-1.png" alt></p>
<blockquote>
<p>其矩阵如：<br> {0,4,NoEdge,2,NoEdge},<br> {4,0,4,1,NoEdge},<br> {NoEdge,4,0,1,3},<br> {2,1,1,0,7},<br>{NoEdge,NoEdge,3,7,0}<br>最终应该得到结果：<br>a-&gt;a=0<br>a-&gt;d-&gt;b=3<br>a-&gt;d-&gt;c=3<br>a-&gt;d=2<br>a-&gt;d-&gt;c-&gt;e=6</p>
</blockquote>
<p> <img src="/2019/11/10/%E7%AE%97%E6%B3%95%E5%AE%9E%E9%AA%8C/example3-2.png" alt="a"><br>测试成功！</p>
</li>
</ol>
]]></content>
      <categories>
        <category>代码编程</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2019/11/10/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p>
<a id="more"></a>

<h2 id="HEXO常用："><a href="#HEXO常用：" class="headerlink" title="HEXO常用："></a>HEXO常用：</h2><h3 id="新建文章"><a href="#新建文章" class="headerlink" title="新建文章"></a>新建文章</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p>
<h3 id="启动本地镜像服务"><a href="#启动本地镜像服务" class="headerlink" title="启动本地镜像服务"></a>启动本地镜像服务</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p>
<h3 id="生成静态文件"><a href="#生成静态文件" class="headerlink" title="生成静态文件"></a>生成静态文件</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p>
<h3 id="上传文件（同步）"><a href="#上传文件（同步）" class="headerlink" title="上传文件（同步）"></a>上传文件（同步）</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br><span class="line">$ hexo d 也可</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p>
<h2 id="常要注意的玩意："><a href="#常要注意的玩意：" class="headerlink" title="常要注意的玩意："></a>常要注意的玩意：</h2><h3 id="hexo图片问题"><a href="#hexo图片问题" class="headerlink" title="hexo图片问题"></a><a href="https://www.jianshu.com/p/3db6a61d3782" target="_blank" rel="noopener">hexo图片问题</a></h3><h3 id="hexo阅读更多"><a href="#hexo阅读更多" class="headerlink" title="hexo阅读更多"></a>hexo阅读更多</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install hexo-generator-index2 --save</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># index2 generator是否包含官方的hexo-generator-index，默认true（包含）</span><br><span class="line">index2_include_index: true</span><br><span class="line">index2_generator:</span><br><span class="line">    per_page: 8</span><br><span class="line">    order_by: -date # 按发布时间排序</span><br><span class="line">    exclude:</span><br><span class="line">        - tag hide # 不包含标签为hide的文章</span><br><span class="line">        - category hide # 不包含分类为hide的文章</span><br></pre></td></tr></table></figure>
<p>然后</p>
<h2 id="博客设置问题："><a href="#博客设置问题：" class="headerlink" title="博客设置问题："></a>博客设置问题：</h2><h3 id="头像-amp-图标："><a href="#头像-amp-图标：" class="headerlink" title="头像&amp;图标："></a>头像&amp;图标：</h3><p>在主题目录下配置文件中.<br>头像：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">author:</span><br><span class="line">  name: DuK</span><br><span class="line">  work: Study,0-1</span><br><span class="line">  location: China</span><br><span class="line">  avatar_url: /images/avatar.png</span><br></pre></td></tr></table></figure>
<p>而其图标：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">favicon: /images/favicon.ico</span><br></pre></td></tr></table></figure>
<p>网站：<a href="http://www.faviconico.org/" target="_blank" rel="noopener">图标制作</a></p>
<h3 id="侧边栏目（标签，归档）"><a href="#侧边栏目（标签，归档）" class="headerlink" title="侧边栏目（标签，归档）"></a>侧边栏目（标签，归档）</h3><p>得先进行</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo new page tags</span><br></pre></td></tr></table></figure>
<p>然后才会有，这里tags还要加上：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: tags</span><br><span class="line">date: 2019-11-10 11:36:27</span><br><span class="line">layout: tags</span><br><span class="line">---</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>配置</tag>
        <tag>博客</tag>
        <tag>指令</tag>
      </tags>
  </entry>
</search>
