<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>工具OllyDbg的使用</title>
    <url>/2019/11/10/%E5%B7%A5%E5%85%B7OllyDbg%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>汇编语言(入门学习)</title>
    <url>/2019/11/10/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80-%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<h4 id="简介：本篇旨在对汇编的基础知识进行汇总，汇总的都是要点（简明扼要），目前还在更新中。"><a href="#简介：本篇旨在对汇编的基础知识进行汇总，汇总的都是要点（简明扼要），目前还在更新中。" class="headerlink" title="简介：本篇旨在对汇编的基础知识进行汇总，汇总的都是要点（简明扼要），目前还在更新中。"></a>简介：本篇旨在对汇编的基础知识进行汇总，汇总的都是要点（简明扼要），目前还在更新中。</h4><a id="more"></a>
<h1 id="第一章-基础知识"><a href="#第一章-基础知识" class="headerlink" title="第一章 基础知识"></a>第一章 基础知识</h1><h2 id="1-1-存储单元"><a href="#1-1-存储单元" class="headerlink" title="1.1 存储单元"></a>1.1 存储单元</h2><p>一个存储单元存储的信息量以<strong>bit</strong>为单位（最小）。而转换关系中8 bit=1 bytes(B)。而一个字=两个字节<br>在微型计算机存储器的存储单元中，一个单元可以存<strong>1 B</strong>（即8个进制位）。而一个存储器有128个单元，则可以存储128 B。</p>
<h2 id="1-2-CPU对存储器的读写"><a href="#1-2-CPU对存储器的读写" class="headerlink" title="1.2 CPU对存储器的读写"></a>1.2 CPU对存储器的读写</h2><p>要读写，则应该与三类信息进行交互：</p>
<blockquote>
<ol>
<li>地址信息</li>
<li>控制信息</li>
<li>数据信息</li>
</ol>
</blockquote>
<p>而逻辑上又分为3类总线，分别传输信息：</p>
<blockquote>
<ol>
<li>地址总线（指出内存中的信息放在那里(自下而上读01)）</li>
<li>控制总线（若要传输的数据多于一次性传输的宽度，则分开来多传几次）</li>
<li>数据总线</li>
</ol>
</blockquote>
<h3 id="1-2-1-影响性能的因素："><a href="#1-2-1-影响性能的因素：" class="headerlink" title="1.2.1 影响性能的因素："></a>1.2.1 影响性能的因素：</h3><h4 id="宽度（线的条数）：它决定了部件的能力（速度，控制能力等）。8086为16条，8088为8条"><a href="#宽度（线的条数）：它决定了部件的能力（速度，控制能力等）。8086为16条，8088为8条" class="headerlink" title="宽度（线的条数）：它决定了部件的能力（速度，控制能力等）。8086为16条，8088为8条"></a>宽度（线的条数）：它决定了部件的能力（速度，控制能力等）。8086为16条，8088为8条</h4><blockquote>
<p>若CPU的寻址能力为8KB，则总线宽度：8*1024/1 = 2**13 (注意单位是B,13则为总线宽度)</p>
</blockquote>
<h1 id="第二章-寄存器"><a href="#第二章-寄存器" class="headerlink" title="第二章 寄存器"></a>第二章 寄存器</h1><h2 id="2-1-通用寄存器"><a href="#2-1-通用寄存器" class="headerlink" title="2.1 通用寄存器"></a>2.1 通用寄存器</h2><p>有<strong>AX BX CX DX</strong>四种，它们分为高位和低位以兼容以前的程序，如（AX = AH(高) + AL(低)）<br><em>要注意的是：若只用AL进行运算，若超出其范围，超出的数据不会到AH当中！</em></p>
<h2 id="2-2-CPU给出物理地址的方法"><a href="#2-2-CPU给出物理地址的方法" class="headerlink" title="2.2 CPU给出物理地址的方法"></a>2.2 CPU给出物理地址的方法</h2><blockquote>
<p>段地址(<strong>SA</strong>)：只是为了内存的管理，并不是真分段。16位地址分段，一段64KB<br>偏移地址(<strong>EA</strong>)：16位地址最多64KB<br>公式：物理地址=段地址*16+偏移地址</p>
</blockquote>
<h2 id="2-3-段寄存器"><a href="#2-3-段寄存器" class="headerlink" title="2.3 段寄存器"></a>2.3 段寄存器</h2><p>有<strong>CS DS SS ES</strong>四种。CS常存储段地址。它们提供了一下功能：</p>
<ol>
<li>CS：CPU要<strong>执行指令</strong>的地址。相当于命令指针</li>
<li>DS：读取内存的地址（返回数据）。相当于数据指针</li>
<li>SS：存储内存中的栈的顶。相当于栈顶指针</li>
</ol>
<h3 id="2-3-1-CS和IP"><a href="#2-3-1-CS和IP" class="headerlink" title="2.3.1 CS和IP"></a>2.3.1 CS和IP</h3><p>IP是存储基于CS的偏移量。修改的流程：</p>
<blockquote>
<p>一般流程：读取指令 -&gt; 修改 IP+=<em>命令长度</em> -&gt; 执行指令(可能会涉及修改CS:IP) -&gt; 读取指令…<br><em>8086PC启动时在FFFF0H单元中读取指令执行</em></p>
</blockquote>
<h2 id="2-4-疑问"><a href="#2-4-疑问" class="headerlink" title="2.4 疑问"></a>2.4 疑问</h2><h3 id="1-为什么偏移地址只能在64Kb内？"><a href="#1-为什么偏移地址只能在64Kb内？" class="headerlink" title="1. 为什么偏移地址只能在64Kb内？"></a>1. 为什么偏移地址只能在64Kb内？</h3><p>一个16位的CPU，只能有1111 1111 1111 1111，代表了4个16进制数，所以能表示2**16 bit的数据，恰好，就是64Kb。</p>
<h3 id="2-暂留"><a href="#2-暂留" class="headerlink" title="2.暂留"></a>2.暂留</h3><h1 id="第三章-寄存器（内存访问）"><a href="#第三章-寄存器（内存访问）" class="headerlink" title="第三章 寄存器（内存访问）"></a>第三章 寄存器（内存访问）</h1><h2 id="3-1-内存中字的存储"><a href="#3-1-内存中字的存储" class="headerlink" title="3.1 内存中字的存储"></a>3.1 内存中字的存储</h2><blockquote>
<p>字单元的概念：即存放一个字型数据的内存单元，由<strong>两个地址连续</strong>的内存单元（一个8位）组成。高放高位，低放低位。</p>
</blockquote>
<p>这里解释一下： 若有单元[0]-&gt;2e，[1]-&gt;33，那么我们读[0]的字型数据为：332eH（高放高位）</p>
<h2 id="3-2-DS和-address"><a href="#3-2-DS和-address" class="headerlink" title="3.2 DS和[address]"></a>3.2 DS和[address]</h2><blockquote>
<p>“[…]”表示一个内存单元，表示在段地址下的偏移量。如10000H = 1000:0 = [0]</p>
</blockquote>
<ul>
<li><p>在masm汇编编辑器中，如果单纯写mov ax,[0]，那么他会把[0]当做0来解释，即指令变成：mov ax,0<br>而若用bx作为中转，那是可以的！如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mov bx,0</span><br><span class="line">mov ax,[bx]</span><br></pre></td></tr></table></figure>
<p>这个是可以把[bx]当成段地址，返回ds:bx下的数据的！<br>而如果偏要用[idata]的话，那么就必须加上<strong>ds:</strong>前缀，如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mov ax,ds:[0]</span><br></pre></td></tr></table></figure>
</li>
<li><p>而对于Debug编译器的话，ds是自动加上的，用</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mov ax,[0]</span><br></pre></td></tr></table></figure>
<p>即可，如果使用[]的话，而且他（段寄存器）是不能直接用mov命令改变的，必须通过其他的寄存器中转才能改变。</p>
</li>
</ul>
<h2 id="3-3-字的传送（mov指令）"><a href="#3-3-字的传送（mov指令）" class="headerlink" title="3.3 字的传送（mov指令）"></a>3.3 字的传送（mov指令）</h2><p>在传送字之后， DS和[address]也会跟着变，如1000:0，若传入一个fffeH，则address会从0-&gt;2，此时，[0]存有feH，[1]存有ffH,[2]为空。</p>
<h2 id="3-4-mov、add、sub指令"><a href="#3-4-mov、add、sub指令" class="headerlink" title="3.4 mov、add、sub指令"></a>3.4 mov、add、sub指令</h2><p>主要是说说置零问题，与机械码长度问题，稍微提一下，以后会细讲。<br>举例子：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sub bx, bx</span><br><span class="line">mov bx, 0</span><br></pre></td></tr></table></figure>
<p>两个都是可以将bx寄存器置零的指令，但是sub的机械码长度为2，而mov为3，用sub更好。<br>另外说说jmp指令，他是转移指令，具有一个操作对象的指令，而上面的具有两个。</p>
<h2 id="3-5-栈"><a href="#3-5-栈" class="headerlink" title="3.5 栈"></a>3.5 栈</h2><p>他是一个FILO结构（先入后出），而且是从大变小（地址）。</p>
<h3 id="3-5-1-push和pop"><a href="#3-5-1-push和pop" class="headerlink" title="3.5.1 push和pop"></a>3.5.1 push和pop</h3><blockquote>
<p>执行push ax命令，会把ax中的数据传入ss:sp指向的地址空间。此时<strong>sp-=2</strong><br>执行pop ax命令，会把ss:sp指向的地址空间中的数据传给ax。此时<strong>sp+=2</strong></p>
</blockquote>
<p>执行之后的指针变化：</p>
<ul>
<li>push先令sp-=2，然后将ax中的数据放进去。称为出栈。</li>
<li>pop是先取出数据放到ax中，再sp+=2。称为入栈。</li>
</ul>
<p><img src="/2019/11/10/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80-%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0/3.5.png" alt></p>
<h3 id="3-5-2-数据传输"><a href="#3-5-2-数据传输" class="headerlink" title="3.5.2 数据传输"></a>3.5.2 数据传输</h3><p>如8086cpu的入栈和出栈都是以<strong>字</strong>为单位进行的。</p>
<h3 id="3-5-3-栈指针"><a href="#3-5-3-栈指针" class="headerlink" title="3.5.3 栈指针"></a>3.5.3 栈指针</h3><p>上面已经用到了：段寄存器:寄存器存储(ss:sp)<br>sp是指偏移地址，ss:sp始终指向栈顶。</p>
<h2 id="3-6-栈顶越界问题"><a href="#3-6-栈顶越界问题" class="headerlink" title="3.6 栈顶越界问题"></a>3.6 栈顶越界问题</h2><p>栈溢出问题都是大问题，如果栈顶越界了，那么执行push和pop会受影响吗？当然不会！直接刚，写！写！写！出！出！出！管你呢。<br>所以就会有可能读了其他程序的数据，或者<strong>修改了（覆盖）</strong>其他程序的数据（直接崩溃的说）<br>执行情况（取自《汇编语言第二版》王爽著）<br><img src="/2019/11/10/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80-%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0/3.6.jpg" alt></p>
<h2 id="3-7-问题"><a href="#3-7-问题" class="headerlink" title="3.7 问题"></a>3.7 问题</h2><h3 id="1-程序与数据有区别吗？"><a href="#1-程序与数据有区别吗？" class="headerlink" title="1.程序与数据有区别吗？"></a>1.程序与数据有区别吗？</h3><p>可以说有，也可以说没有。由于指令都是0和1组成的，只是用不同功能的段地址读出来的不一样，如,CS和DS都指向10000H，那么，CS会将里头的数据转化为机械码，执行指令，而DS就直接读数据，作为单纯的数据使用。</p>
<h3 id="2-空栈如（10000H-1000FH）此时ss-1000H，那么sp是多少？"><a href="#2-空栈如（10000H-1000FH）此时ss-1000H，那么sp是多少？" class="headerlink" title="2.空栈如（10000H~1000FH）此时ss=1000H，那么sp是多少？"></a>2.空栈如（10000H~1000FH）此时ss=1000H，那么sp是多少？</h3><p>因为是自下而上（自大到小），所以sp=0010H。<br>换一种方式看，若存储了一个数据，则一个存到000EH，一个存到000FH，此时的栈指针在栈顶，当然指向000EH了，此时是已经让sp-=2了，那么回溯一下，不就有sp=0010H了。</p>
<ul>
<li>好了，问题来了，如果将（10000H~1FFFFH）作为空间呢？<br>答案：sp=0000H，因为，不能变成10000H(笑)</li>
</ul>
<h3 id="3-栈会溢出，那么，为什么不设置栈大小"><a href="#3-栈会溢出，那么，为什么不设置栈大小" class="headerlink" title="3.栈会溢出，那么，为什么不设置栈大小"></a>3.栈会溢出，那么，为什么不设置栈大小</h3><p>emmm，可惜8086cpu就是没有，所以变成自己注意。</p>
<h3 id="4-只有mov可以完成传输数据吗？"><a href="#4-只有mov可以完成传输数据吗？" class="headerlink" title="4.只有mov可以完成传输数据吗？"></a>4.只有mov可以完成传输数据吗？</h3><p>push也可以哦，只要把sp定位为ds:[address]那就好了哦。直接写进去。</p>
<h1 id="第四章-第一个程序"><a href="#第四章-第一个程序" class="headerlink" title="第四章 第一个程序"></a>第四章 第一个程序</h1><h2 id="4-1-一个源程序从写出到执行的过程"><a href="#4-1-一个源程序从写出到执行的过程" class="headerlink" title="4.1 一个源程序从写出到执行的过程"></a>4.1 一个源程序从写出到执行的过程</h2><p>如图：<br><img src="/2019/11/10/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80-%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0/4.1.png" alt><br>执行过程包括：写程序-&gt;编译连接成可执行文件-&gt;执行。</p>
<blockquote>
<p>可执行文件文件中包括以下两部分：</p>
</blockquote>
<ol>
<li>程序和数据</li>
<li>相关的描述：程序多大，占用多少运行空间</li>
</ol>
<h2 id="4-2-源程序"><a href="#4-2-源程序" class="headerlink" title="4.2 源程序"></a>4.2 源程序</h2><h3 id="4-2-1-伪指令"><a href="#4-2-1-伪指令" class="headerlink" title="4.2.1 伪指令"></a>4.2.1 伪指令</h3><p>也就是只能被编译器识别的指令，如<strong>assume</strong>、<strong>segment</strong>、<strong>end</strong>等，<strong><em>这是没有机械码的</em></strong>。<br>一般的伪指令使用如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">assume cs:code  #声明（假设）cs:段名（标号）</span><br><span class="line">code segment	#段名 segment</span><br><span class="line">_指令_</span><br><span class="line">code ends		#对应segment，表示一个段结束</span><br><span class="line">end				#对应assume，表示程序结束</span><br></pre></td></tr></table></figure>

<h3 id="4-2-2-程序返回"><a href="#4-2-2-程序返回" class="headerlink" title="4.2.2 程序返回"></a>4.2.2 程序返回</h3><p>现在考虑，如何让上一个程序把CPU控制权交给写一个程序，这时候就要使用<strong>程序返回</strong><br>其代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mov ax, 4c00H</span><br><span class="line">int 21H</span><br></pre></td></tr></table></figure>
<h2 id="4-3-程序生成流程"><a href="#4-3-程序生成流程" class="headerlink" title="4.3 程序生成流程"></a>4.3 程序生成流程</h2><p><strong>编程 -&gt; <em>1.asm</em> -&gt; 编译 -&gt; <em>1.obj</em> -&gt; 连接 -&gt; <em>1.exe</em> -&gt; 加载 -&gt; <em>内存中的程序</em> -&gt; 运行</strong><br>注：加载就是将程序加载到内存，执行就是在内存中执行程序的指令</p>
<h2 id="4-4-怎么装载程序？"><a href="#4-4-怎么装载程序？" class="headerlink" title="4.4 怎么装载程序？"></a>4.4 怎么装载程序？</h2><p>操作系统是一个模块组成庞大的系统。任何通用的系统都要提供一个称为shell的程序，用户使用这个程序来操作计算机系统进行工作。</p>
<p>如DOS中有一个程序command.com，这个程序称为：命令解释器，也就是DOS中的SHELL<br>（其实跟我们的cmd.exe差不多）</p>
<p>先运行shell，然后在加载1.exe可执行程序的时候，cmd会自动把cpu的控制权交给1.exe，执行完成再返回cmd。</p>
<h2 id="4-4-展示EXE的加载过程"><a href="#4-4-展示EXE的加载过程" class="headerlink" title="4.4 展示EXE的加载过程"></a>4.4 展示EXE的加载过程</h2><p><img src="/2019/11/10/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80-%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0/4.4.png" alt></p>
<h1 id="第五章-BX-和loop指令"><a href="#第五章-BX-和loop指令" class="headerlink" title="第五章 [BX]和loop指令"></a>第五章 [BX]和loop指令</h1><h2 id="5-1-BX"><a href="#5-1-BX" class="headerlink" title="5.1 [BX]"></a>5.1 [BX]</h2><p>这个之前就讲过：其实就是把BX中的值作为ds的偏移地址EA，然后可以用这个来访问特定地址下的数据。<br>如ds:1000H，bx=0001H，那么[BX]就是指ds*16+bx下的值。</p>
<h2 id="5-2-loop"><a href="#5-2-loop" class="headerlink" title="5.2 loop"></a>5.2 loop</h2><p>直接上程序：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">assume cs:eloop</span><br><span class="line">eloop segment</span><br><span class="line">	mov ax,128</span><br><span class="line">	mov cx,36</span><br><span class="line">  s:add ax,ax</span><br><span class="line">	loop s</span><br><span class="line">eloop ends</span><br><span class="line">end</span><br></pre></td></tr></table></figure>
<p>解释：</p>
<ol>
<li>loop是按照cx当中的值进行对有标号的s下的命令进行循环的。当cx不等于0，则执行循环，这个程序实际上是实现128*36的程序。</li>
<li>s实际上是IP值，指向s标记的地址，所以loop s实际上是给IP赋值：IP=s，然后就可以通过cs:ip来执行指令了</li>
</ol>
<blockquote>
<p>注意：汇编程序中，数据不能以字母开头，所以要在前面加个0。比如：9138h可以写成9138h，而A000h就必须写成0A000h</p>
</blockquote>
<h2 id="5-3-loop和-bx-的联合运用"><a href="#5-3-loop和-bx-的联合运用" class="headerlink" title="5.3 loop和[bx]的联合运用"></a>5.3 loop和[bx]的联合运用</h2><p>例如来一个如同C++语言中的：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int dx = 0;</span><br><span class="line">int ds[12] = &#123;1, 2, ...&#125;;</span><br><span class="line">for(int i=0; i &lt; 12; i++)</span><br><span class="line">&#123;</span><br><span class="line">	dx += ds[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>那么汇编语言就有：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">assume cs:code</span><br><span class="line">code segment:</span><br><span class="line">	mov ax, 0ffffh	;因为ds寄存器不能直接赋值，所以用ax作为中间变量</span><br><span class="line">	mov ds,ax		</span><br><span class="line">	mov bx,0		;初始化ds:bx指向ffff:0</span><br><span class="line"></span><br><span class="line">	mov dx,0		;初始化**累加寄存器**dx，让值为0</span><br><span class="line"></span><br><span class="line">	mov cx,12		;初始化循环计数寄存器cx，令值为12，指循环12次</span><br><span class="line"></span><br><span class="line"> s: mov al,[bx]		;以下两步执行ax的赋值操作</span><br><span class="line">	mov ah,0		;</span><br><span class="line">	add dx,ax		;执行加法</span><br><span class="line">	inc bx			;ds:bx指向下一个单元，因为bx的值增加了1，相当于C++代码中的*i++*</span><br><span class="line">	loop s			;loop完成一次，则cx=cx-1，然后判断cx是否等于0，如果等于则退出循环</span><br><span class="line"></span><br><span class="line">	mov ax,4c00h</span><br><span class="line">	int 21h</span><br><span class="line"></span><br><span class="line">code ends</span><br><span class="line">end</span><br></pre></td></tr></table></figure>
<p>好了，现在来说说这段代码里面有什么需要注意的点：</p>
<ol>
<li>cx寄存器一般用作loop循环的判断条件，即<strong>循环的粗次数</strong>。</li>
<li>ax寄存器的初始化有两步，是，因为一个字符型数据是8位这样的话转化为16位就得让高8位的值赋为0。</li>
<li>dx寄存器是常用的累加寄存器。</li>
<li>inc指令是让后面的值加一的指令，相当于C++语言中的‘++’自增。</li>
<li>int指令：<blockquote>
<p>由int 指令引发的中断是一种重要的内中断。<br>格式： int n   //相当于引发一个n号中断的过程,最终功能和call指令相似，都是调用一段程序。</p>
<ul>
<li>取中断类型码n</li>
<li>标志寄存器入栈，并IF=0,TF=0      //TF=0使得避免中断程序执行过程中引发单步中断</li>
<li>CS,IP寄存器入栈</li>
<li>IP=(n*4) , CS=(n*4 + 2)<br><a href="https://blog.csdn.net/u010034085/article/details/97819727" target="_blank" rel="noopener">原文链接</a></li>
</ul>
</blockquote>
</li>
</ol>
<h2 id="5-4-段前缀与其使用"><a href="#5-4-段前缀与其使用" class="headerlink" title="5.4 段前缀与其使用"></a>5.4 段前缀与其使用</h2><blockquote>
<ul>
<li>能够显示地指令内存单元的段地址的，如：”ds:”、”cs:”、”ss:”、”es:”。这就是段前缀。</li>
<li>默认的[x]是指：(dx*16)+x，而如果要用其他的段寄存器，则需要加上它的段前缀。 </li>
</ul>
</blockquote>
<h1 id="第六章-包含多个段的程序"><a href="#第六章-包含多个段的程序" class="headerlink" title="第六章 包含多个段的程序"></a>第六章 包含多个段的程序</h1><blockquote>
<p>由于软件是由数据和程序组成的，数据当然也是程序里面必不可少的部分，所以会将代码分为多段进行，如数据段、代码段等。</p>
</blockquote>
<h2 id="6-1-在代码段中使用数据"><a href="#6-1-在代码段中使用数据" class="headerlink" title="6.1 在代码段中使用数据"></a>6.1 在代码段中使用数据</h2><blockquote>
<p><strong>汇编程序若没有特殊的说明（或者注明在哪里开始），则默认从头开始！</strong><br>所以，一旦你的程序头部有数据，则将会把头部的数据翻译为<strong>机器码</strong>执行。(冤)</p>
</blockquote>
<p>那么解决方式是：在开始执行代码的地方加上 <strong>start:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">assume cs:code</span><br><span class="line">code segment</span><br><span class="line">  dw 0123h,0456h,0789h ;这里是数据部分 dw意思是定义字符型数据</span><br><span class="line">  start: mov bx,0   ;注意，从这开始，标识为start!</span><br><span class="line">         mov ax,0</span><br><span class="line"></span><br><span class="line">         mov cx,8</span><br><span class="line">	  s: add ax,cs:[bx]	;用cs作为段地址，取数据！</span><br><span class="line">         add bx,2</span><br><span class="line">         loop s</span><br><span class="line">         </span><br><span class="line">         mov ax,4c00h</span><br><span class="line">         int 2h</span><br><span class="line">code ends</span><br><span class="line">end start   ;注意end后面要加上end开始的名称！</span><br></pre></td></tr></table></figure>

<h2 id="6-2-将数据、代码、栈放入不同的段"><a href="#6-2-将数据、代码、栈放入不同的段" class="headerlink" title="6.2 将数据、代码、栈放入不同的段"></a>6.2 将数据、代码、栈放入不同的段</h2><p>上面说了，代码从哪里开始就在哪里加上<strong>start</strong>，结束就用<strong>end start</strong>（其他标识也行）<br>好，记住，那是代码，别把接下来说的混淆了。</p>
<p>不同的段可以放不同的东西，例如数据，代码等等。<br>只要记住将段名end了再定义其他段。也只有定义了，才能使用这个段</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">assume cs:b,ds:a,ss:c</span><br><span class="line">a segment</span><br><span class="line">    dw 0123h, 0456h, 0789h, 0abch, 0de fh, Ofedh, 0cbah, 0987h</span><br><span class="line">a ends</span><br><span class="line"></span><br><span class="line">c segment</span><br><span class="line">    dw 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0</span><br><span class="line">c ends</span><br><span class="line"></span><br><span class="line">b segment</span><br><span class="line">d:  mov ax,c  ;使用段c中的数据</span><br><span class="line">    mov ss,ax</span><br><span class="line">    mov sp, 20h  ;希望用c段当作栈空间，设置ss:sp指向c:20</span><br><span class="line"></span><br><span class="line">    mov ax,a	;使用段a</span><br><span class="line">    mov ds,ax  ;希望用ds:bx访问a段中的数据，ds指向a段</span><br><span class="line">    mov bx,0  ;ds:bx指向a段中的第一一个单元</span><br><span class="line">    mov Cx,8</span><br><span class="line"></span><br><span class="line">s:  push [bx]</span><br><span class="line">    add bx,2</span><br><span class="line">    1oop s   ;以上将a段中的0~15单元中的8个字型数据依次入栈</span><br><span class="line"></span><br><span class="line">    mov bx,0</span><br><span class="line">    mov cx, B</span><br><span class="line">s0:	pop [bx]</span><br><span class="line">    add bx,2</span><br><span class="line">    1oop s0  ;以上依次出栈8个字型数据到a段的0~15单元中</span><br><span class="line"></span><br><span class="line">    mov ax, 4c00hint 21h</span><br><span class="line">b ends</span><br><span class="line"></span><br><span class="line">end d  ;d处是要执行的第一- 条指令，即程序的入口</span><br></pre></td></tr></table></figure>
<h1 id="第七章-更灵活的定位内存地址的方法"><a href="#第七章-更灵活的定位内存地址的方法" class="headerlink" title="第七章 更灵活的定位内存地址的方法"></a>第七章 更灵活的定位内存地址的方法</h1><p>之前的[0]和[bx]均可以起到定位的作用，现在有更灵活的定位方式：</p>
<h2 id="7-1-and和or指令"><a href="#7-1-and和or指令" class="headerlink" title="7.1 and和or指令"></a>7.1 and和or指令</h2><blockquote>
<p>and是有零变零，而or是有一变一<br>也可以想象成and是乘法，or是加法</p>
</blockquote>
<h2 id="7-2-以字符型给出数据"><a href="#7-2-以字符型给出数据" class="headerlink" title="7.2 以字符型给出数据"></a>7.2 以字符型给出数据</h2><p>凡是以’…’形式给出数据的，都被译为是字符型数据，这样，编译器会将里面的数据变成ASCII码值。具体实例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">db &apos;unIX&apos;</span><br><span class="line">mov al,&apos;a&apos;</span><br></pre></td></tr></table></figure>
<p>这里被译为</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">db 75H,6EH,49H,58H</span><br><span class="line">mov al,61H</span><br></pre></td></tr></table></figure>
<p>而大小写转换的方法有两种：</p>
<ol>
<li>基于比较的，在ASCII码中，大写字母+20H=小写字母</li>
<li>基于二进制数的，在ASCII表达字符时，若第五位为0，则为大写字母；若第五位为1则为小写字母（这里可以用or或者and来进行转换）</li>
</ol>
<h2 id="7-3-以-bx-idata-的方式寻址"><a href="#7-3-以-bx-idata-的方式寻址" class="headerlink" title="7.3 以[bx+idata]的方式寻址"></a>7.3 以[bx+idata]的方式寻址</h2><p>现在以例题进行解析，将第一组字符串变成大写，第二组变成小写</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">assume cs:codesg,ds:datasg</span><br><span class="line">datasg segment</span><br><span class="line">  db &apos;BaSiC&apos;</span><br><span class="line">  db &apos;MinIX&apos;</span><br><span class="line">datasg ends</span><br><span class="line">codesg segment</span><br><span class="line">start:			;代码段</span><br><span class="line">codesg ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure>
<ul>
<li>原来的思想：取[bx]中的字符，再对其进行and 11011111b操作，再放回去，然后将bx自增，再重新···，而变成小写就or 00100000b。（这里要执行两次循环啊，一个变大写，一个变小写）</li>
<li>然而我们可以使用以下思想，更加便捷，就是[bx+idata]：思想和前面的一样，但是，不用执行两次循环，只要一次就够了：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">  mov ax,datasg</span><br><span class="line">  mov ds, ax</span><br><span class="line">  mov bx,0</span><br><span class="line">  </span><br><span class="line">  mov cx,5</span><br><span class="line">s:mov al,[bx]      ;定位第一个字符串的第bx个字符</span><br><span class="line">  and al,11011111b ;执行完变大工作</span><br><span class="line">  mov [bx],al      ;放回去</span><br><span class="line">  mov al[5+bx]     ;定位第二个字符串的第bx个字符（因为一个字符串只有5个字符）</span><br><span class="line">  or al,00100000b  ;执行变小工作</span><br><span class="line">  mov [5+bx],al    ;放回去</span><br><span class="line">  inc bx           ;自增</span><br><span class="line">  loop s</span><br></pre></td></tr></table></figure>
这个其实，学过高级语言都知道这方法，只不过，没想到汇编也能做吧，汇编语言也不是那么死板的。</li>
</ul>
<h2 id="7-4-si与di寄存器和多重循环"><a href="#7-4-si与di寄存器和多重循环" class="headerlink" title="7.4 si与di寄存器和多重循环"></a>7.4 si与di寄存器和多重循环</h2><p>这个只要知道是16位寄存器，功能和bx差不多，可以用作[bx+si+idata]和[bx+di+idata]就可以了。其中，idata是常量，其他的为变量。这个结构可以执行二重循环，相当于处理二维数组。<br>需要注意的是二重循环的实现：</p>
<blockquote>
<ul>
<li>问题一：cx寄存器是用作循环的判定条件的，那么二重循环对于没有两个cx的我们来说，如何是好？<br>将之前的cx用其他寄存器保存起来啊！</li>
<li>问题二：二重循环可以那样做，那么多重循环呢！？你只有有限个寄存器。<br>利用内存空间！开辟一段dw 0，让后指向它，放进去就完事了。</li>
<li>问题三：那这个方法的前提是我得知道有多少个循环，很麻烦啊，换个简单的。</li>
<li><em>在需要暂存数据的时候我们都应该使用栈*</em></li>
<li><em>在需要暂存数据的时候我们都应该使用栈*</em></li>
<li><em>在需要暂存数据的时候我们都应该使用栈*</em><br>按顺序push，然后逆向按顺序pop</li>
</ul>
</blockquote>
<h1 id="第八章-数据处理的两个基本问题"><a href="#第八章-数据处理的两个基本问题" class="headerlink" title="第八章 数据处理的两个基本问题"></a>第八章 数据处理的两个基本问题</h1><p>这两个问题是：</p>
<ol>
<li><strong>处理的数据在什么地方</strong></li>
<li><strong>要处理的数据有多长</strong></li>
</ol>
<h2 id="8-1-bx、si、di和bp"><a href="#8-1-bx、si、di和bp" class="headerlink" title="8.1 bx、si、di和bp"></a>8.1 bx、si、di和bp</h2><p>这几个都用过，主要说说bp:这个只要在[…]里使用了它，没有段地址声明，那么默认是<strong>ss</strong></p>
<h2 id="8-2-机器指令处理的数据在什么地方"><a href="#8-2-机器指令处理的数据在什么地方" class="headerlink" title="8.2 机器指令处理的数据在什么地方"></a>8.2 机器指令处理的数据在什么地方</h2><p><strong>在指令执行前</strong>，所要处理的数据可以在三个地方：</p>
<ol>
<li>CPU内部</li>
<li>内存</li>
<li>端口<br>下面举例子：<br><img src="/2019/11/10/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80-%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0/8.1.png" alt><br>上图还表明了汇编语言中数据位置的表达</li>
<li>立即数（idata）：如上图的最后一个例子，是直接赋值的</li>
<li>寄存器：如上图的第二个例子，使用寄存器名。</li>
<li>段地址：如果是[bx]则默认段地址是ds，如果是[bp]则默认段地址为ss，当然可以显性给出。</li>
</ol>
<h2 id="8-3-指令处理的数据长度"><a href="#8-3-指令处理的数据长度" class="headerlink" title="8.3 指令处理的数据长度"></a>8.3 指令处理的数据长度</h2><p>这个得看具体例子。</p>
<ol>
<li>如果是ax,bx，那么这个就是字操作</li>
<li>如说是al,bl，那么就是字节操作</li>
<li>在没有寄存器名存在的情况下，用操作符X ptr指明内存单元的长度，X在汇编中可以为word或byte（且必须显式声明）。</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mov word ptr ds:[0],1	;字</span><br><span class="line">mov byte ptr ds:[0],1	;字节</span><br></pre></td></tr></table></figure>
<ol start="4">
<li>有些指令默认了访问的是字还是字节，如<strong>push</strong>默认进行<strong>字</strong>操作，而用[…]的是字单元操作(一个8位)。</li>
</ol>
<h2 id="8-4-div指令"><a href="#8-4-div指令" class="headerlink" title="8.4 div指令"></a>8.4 div指令</h2><p>div是除法指令，使用div做除法的时候应注意以下问题.</p>
<ol>
<li>除数:有8位和16位两种，在<strong>一个reg</strong>或<strong>内存单元</strong>中。</li>
<li>被除数:默认放在<strong>AX</strong>或<strong>DX和AX</strong>中<ol>
<li>如果除数为8位，<strong>被除数则为16位</strong>，<strong>默认在AX</strong>中存放；</li>
<li>如果除数为16位，<strong>被除数则为32位</strong>，在DX和AX中存放，<strong>DX存放高16位，AX存放低16位</strong>。</li>
</ol>
</li>
<li>结果:<ol>
<li>如果<strong>除数为8位</strong>，则AL存储除法操作的商，AH存储除法操作的余数:</li>
<li>如果<strong>除数为16位</strong>，则AX存储除法操作的商，DX存储除法操作的余数。</li>
</ol>
</li>
</ol>
<p>格式如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">div reg</span><br><span class="line">div 内存单元</span><br><span class="line">div byte ptr ds:[0]</span><br><span class="line">含义：(al)=(ax)/((ds)*16+0)的商</span><br><span class="line">	 (ah)=(ax)/((ds)*16+0)的余数</span><br></pre></td></tr></table></figure>
<h2 id="8-5-实例"><a href="#8-5-实例" class="headerlink" title="8.5 实例"></a>8.5 实例</h2><p>利用除法指令计算100001/100<br>分析：</p>
<ol>
<li>由于100001大于整数最大值（16位）65535，不能用ax寄存器存放，所以只能用dx和ax两个寄存器联合存放，共32位</li>
<li>而出书100小于255（8位），但是因为被除数是32位，所以除数应该用16位的来存放除数100<br>所以有程序：</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mov dx,1</span><br><span class="line">mov ax,86A1H	;(dx)*10000H+(ax)=100001   100001=186A1H</span><br><span class="line">mov bx,100</span><br><span class="line">div bx</span><br></pre></td></tr></table></figure>

<p>执行后，(ax)=03E8H(即10000)，(dx)=1(余数为1)。</p>
<h2 id="8-6-伪指令dd"><a href="#8-6-伪指令dd" class="headerlink" title="8.6 伪指令dd"></a>8.6 伪指令dd</h2><p>之前有学过用db和dw定义字节型数据和字型数据。dd是用来定义dword（double word，双字）型数据的。</p>
<ul>
<li>db 占1个字节</li>
<li>dw 占1个字（即两个字节）</li>
<li>db 占2个字（即四个字节）</li>
</ul>
<h2 id="8-7-dup"><a href="#8-7-dup" class="headerlink" title="8.7 dup"></a>8.7 dup</h2><p>dup是一个操作符，在汇编语言中与dw,db,dd一样，都是由编译器识别处理的符号，且与它们一同配合使用，用来进行数据重复。<br>如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">db 3 dup (0)</span><br><span class="line">定义了3个字节，它们的值都是0，相当于执行了 db 0,0,0。</span><br><span class="line"></span><br><span class="line">db 3 dup (1,2,3)</span><br><span class="line">定义了3\*3=9个字节，它们是0、1、2、0、1、2、0、1、2，相当于db 0,1,2,0,1,2,0,1,2。</span><br><span class="line">字符型也适用。</span><br><span class="line"></span><br><span class="line">总结：</span><br><span class="line">d？ 重复的次数 dup (重复的(字节/字/双字型)数据）</span><br></pre></td></tr></table></figure>

<h1 id="第九章-转移指令的原理"><a href="#第九章-转移指令的原理" class="headerlink" title="第九章 转移指令的原理"></a>第九章 转移指令的原理</h1><p><strong>可以修改IP 或同事修改CS和IP的指令统称为转移指令统称为转移指令</strong>。如jmp、jno等，即可以控制CPU指令内存中某处代码的指令。<br>具体分类有：</p>
<ol>
<li>无条件转移指令（jmp）</li>
<li>条件转移指令（jno）</li>
<li>循环指令（loop）</li>
<li>过程</li>
<li>中断</li>
</ol>
<p>还有其他的分类：</p>
<ol>
<li><p>只修改IP：段内转移（jmp ax）</p>
</li>
<li><p>同时修改CS和IP：段间转移（jmp 1000:0）</p>
</li>
<li><p>短转移</p>
</li>
<li><p>近转移</p>
</li>
</ol>
<h2 id="9-1-操作符offset"><a href="#9-1-操作符offset" class="headerlink" title="9.1 操作符offset"></a>9.1 操作符offset</h2><p>offset是编译器处理符号，功能：取得标号的额编译地址。<br>如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">start: mov ax, offset start	;相当于mov ax,0</span><br><span class="line">	s: mov ax, offset s		;相当于mov ax,3</span><br></pre></td></tr></table></figure>
<p>解析：第一条指令mov … 是三个字节，所以s段的offset为3</p>
<h2 id="9-2-jmp指令和依据译为进行转移的jmp指令"><a href="#9-2-jmp指令和依据译为进行转移的jmp指令" class="headerlink" title="9.2 jmp指令和依据译为进行转移的jmp指令"></a>9.2 jmp指令和依据译为进行转移的jmp指令</h2><h3 id="9-2-1-jmp-short-标号-转移到标号出执行指令"><a href="#9-2-1-jmp-short-标号-转移到标号出执行指令" class="headerlink" title="9.2.1 jmp short 标号(转移到标号出执行指令)"></a>9.2.1 jmp short 标号(转移到标号出执行指令)</h3><pre><code>1. short标号下，它属于段内短转移，对IP的修改范围为-128~127。</code></pre><h3 id="9-2-2-立即数在机器码中的表示"><a href="#9-2-2-立即数在机器码中的表示" class="headerlink" title="9.2.2 立即数在机器码中的表示"></a>9.2.2 立即数在机器码中的表示</h3><p>在一般的汇编指令当中，汇编指令的idata（立即数），不论他是表示一个数据还是内存单元的偏移地址，都会在相应的机器指令中出现，因为CPU执行的是机器指令，他必须处理这些数据或地址。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mov ax,0123h		B8 23 01</span><br><span class="line">mov ax,ds:[0123h]	A1 23 01</span><br><span class="line">push ds:[0123h]		FF 36 23 01</span><br></pre></td></tr></table></figure>
<h3 id="9-2-3-jmp转移的机制（是怎么实现转移的）"><a href="#9-2-3-jmp转移的机制（是怎么实现转移的）" class="headerlink" title="9.2.3 jmp转移的机制（是怎么实现转移的）"></a>9.2.3 jmp转移的机制（是怎么实现转移的）</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">start:	mov ax,0</span><br><span class="line">		mov bx,0</span><br><span class="line">		jmp short s</span><br><span class="line">		add ax,1</span><br><span class="line">	s:	inc ax</span><br></pre></td></tr></table></figure>

<ol>
<li>首先我们应该知道，jmp指令是2个字节，如代码中的jmp机械码是：<strong>EB 03</strong> 。这样的机械码，<strong>没有包含s段的地址</strong>！所以将jmp指令写入内存之后，IP=IP+2=0008h。</li>
<li>但是，执行完jmp后，IP=000Bh。因为执行JMP，就是执行IP=IP+(EB之后的偏移量)=IP+3=000Bh。</li>
<li>所以<strong>jmp执行的是给IP加偏移地址！</strong>。</li>
</ol>
<p>所以 jmp short 标号 的功能为：<strong>(ip)=(ip)+8位位移</strong></p>
<h3 id="9-2-4-继续上面的，8位位移是怎么得出来的？"><a href="#9-2-4-继续上面的，8位位移是怎么得出来的？" class="headerlink" title="9.2.4 继续上面的，8位位移是怎么得出来的？"></a>9.2.4 继续上面的，8位位移是怎么得出来的？</h3><p><img src="/2019/11/10/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80-%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0/9.2.4.png" alt></p>
<ol>
<li><strong>8位位移</strong>=<strong>标号处的地址</strong> - jmp指令<strong>后的第一个字节的地址</strong>.</li>
<li><strong>short</strong>指明此处的位移为<strong>8位位移</strong>;</li>
<li>8位位移的范围为-128-127，<strong>用补码表示</strong></li>
<li>8位位移由编译程序在编译时算出。</li>
</ol>
<blockquote>
<p>还有一种和”jmp short标号”功能相近的指令格式:<br><strong>jmp near ptr标号</strong><br>它实现的是段内近转移。功能为:<strong>(IP)=(LP)+16位位移</strong>。<br>(1) 16位位移=标号处的地址 - jmp指令后的第一个字节的地址:<br>(2) <strong>near ptr</strong>指明此处的位移为<strong>16位位移</strong>，进行的是<strong>段内近转移</strong>:<br>(3) 16位位移的范围为一32768~32767，用<strong>补码表示</strong>:<br>(4) 16位位移由编译程序在编译时算出。</p>
</blockquote>
<h3 id="9-2-5-jmp-far-ptr-标号（段间转移-远转移）"><a href="#9-2-5-jmp-far-ptr-标号（段间转移-远转移）" class="headerlink" title="9.2.5 jmp far ptr 标号（段间转移/远转移）"></a>9.2.5 jmp far ptr 标号（段间转移/远转移）</h3><p>是不是所有的jmp机械码都没有段数据呢？当然不是！小标题就说到了：far ptr，这个指令用标号的段地址和偏移地址修改CS和IP<br>如：<br><img src="/2019/11/10/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80-%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0/9.2.5.png" alt><br>解释：“OB 01 BD 0B”是目的地之在指令中的存储顺序：<br>高地址：“BD 0B”是段地址 0BBDH ；<br>低地址：“0B 01”是偏移地址 010BH ；</p>
<h3 id="9-2-6-转移地址在寄存器的jmp指令-这就相当于总结了，上面废话有点多"><a href="#9-2-6-转移地址在寄存器的jmp指令-这就相当于总结了，上面废话有点多" class="headerlink" title="9.2.6 转移地址在寄存器的jmp指令(这就相当于总结了，上面废话有点多)"></a>9.2.6 转移地址在寄存器的jmp指令(这就相当于总结了，上面废话有点多)</h3><ul>
<li>若只是一个字，则只是偏移地址（直接EB ??完事）</li>
<li>若是两个字，那么一个是段，一个是偏移地址。</li>
</ul>
<h2 id="9-3-jcxz指令"><a href="#9-3-jcxz指令" class="headerlink" title="9.3 jcxz指令"></a>9.3 jcxz指令</h2><p>该指令为有条件转移指令，所有的有条件转移指令都是<strong>短指令</strong>，即上面9.2.6说的1个字，只有位移（偏移地址），对ip的修改范围是：-128~127.</p>
<blockquote>
<p>指令格式：jcxz 标号<br>如果(cx)=0，则转移到标号这</p>
</blockquote>
<h2 id="9-4-loop指令"><a href="#9-4-loop指令" class="headerlink" title="9.4 loop指令"></a>9.4 loop指令</h2><p>也是短转移指令，pass</p>
<h2 id="9-5-编译器对转移位移超界的检测"><a href="#9-5-编译器对转移位移超界的检测" class="headerlink" title="9.5 编译器对转移位移超界的检测"></a>9.5 编译器对转移位移超界的检测</h2><p>编译的时候就会出错！因为，这超界，编译器可识别不了。这不存在的玩意儿。</p>
]]></content>
      <categories>
        <category>理论</category>
        <category>代码编程</category>
      </categories>
      <tags>
        <tag>汇编</tag>
        <tag>二进制</tag>
      </tags>
  </entry>
  <entry>
    <title>网络流量分析（nogotofail））</title>
    <url>/2019/11/10/%E7%BD%91%E7%BB%9C%E6%B5%81%E9%87%8F%E5%88%86%E6%9E%90-nogotofail/</url>
    <content><![CDATA[<h4 id="应用范围"><a href="#应用范围" class="headerlink" title="应用范围"></a>应用范围</h4><p>它包括对常见的SSL证书验证问题(HTTPS和TLS/SSL)的测试<br>库bug、SSL和STARTTLS剥离问题、明文问题等等。</p>
<a id="more"></a>

<h1 id="应用到的库："><a href="#应用到的库：" class="headerlink" title="应用到的库："></a>应用到的库：</h1><h2 id="psutil模块"><a href="#psutil模块" class="headerlink" title="psutil模块"></a>psutil模块</h2><p>psutil是一个<a href="http://pythonhosted.org/psutil/" target="_blank" rel="noopener">跨平台库</a>能够轻松实现获取系统运行的进程和系统利用率（包括CPU、内存、磁盘、网络等）信息。它主要用来做系统监控，性能分析，进程管理。它实现了同等命令行工具提供的功能，如ps、top、lsof、netstat、ifconfig、who、df、kill、free、nice、ionice、iostat、iotop、uptime、pidof、tty、taskset、pmap等。目前支持32位和64位的Linux、Windows、OS X、FreeBSD和Sun Solaris等操作系统.</p>
<h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><figure class="highlight plain"><figcaption><span>install psutil```</span></figcaption><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">### 基本使用</span><br><span class="line">#### 获取CPU时间</span><br></pre></td></tr></table></figure>
<blockquote>
<blockquote>
<blockquote>
<p>psutil.cpu_times()<br>scputimes(user=650613.02, nice=22.14, system=154916.5, idle=16702285.26, iowait=68894.55, irq=3.38, softirq=7075.65, steal=0.0, guest=0.0)</p>
</blockquote>
</blockquote>
</blockquote>
<pre><code>&gt; 1. psutil.process_iter()
遍历所有进程
2. psutil.version_info[] 
3. psutil.net_connections
寻找连接(用户)的个数，在[OSX](https://baike.baidu.com/item/mavericks/4902413?fr=aladdin)中需要root权限
4. psutil.NoSuchProcess, psutil.AccessDenied

[参考文章](https://www.cnblogs.com/saneri/p/7528283.html)

https://www.cnblogs.com/lfs2640666960/p/9330735.html 介绍的不错

5. bash: 未预期的符号 `newline&apos; 附近有语法错误:将&lt;&gt;换成&apos;&apos;

# 关于elk
1. 安装
yum install -y elasticsearch
安装在/usr/share/elasticsearch当中，启动在bin当中的elasticsearch。用./Bin...来启动
* 测试运行：curl &apos;http://localhost:9200/?pretty&apos;
* 会得到![](elasticsuccess.jpg)
* Elasticsearch 的实例。 而一个 集群 是一组拥有相同 cluster.name 的节点， 他们能一起工作并共享数据，还提供容错与可伸缩性。(当然，一个单独的节点也可以组成一个集群) 你可以在 elasticsearch.yml 配置文件中 修改 cluster.name ，该文件会在节点启动时加载 (译者注：这个重启服务后才会生效)。 
* 而elasticsearch中的.yml在/etc/elasticsearch当中
* 设置：logstash，netflow，配置
* 可以用端口9200，web客户端，甚至curl进行交互
    curl -X&lt;VERB&gt; &apos;&lt;PROTOCOL&gt;://&lt;HOST&gt;:&lt;PORT&gt;/&lt;PATH&gt;?&lt;QUERY_STRING&gt;&apos; -d &apos;&lt;BODY&gt;&apos;   [使用参考](https://www.elastic.co/guide/cn/elasticsearch/guide/current/_talking_to_elasticsearch.html)
* 
* 会遇到问题：Exception in thread &quot;main&quot; org.elasticsearch.bootstrap.BootstrapException: java.nio.file.NoSuchFileException: /usr/share/elasticsearch/config
Likely root cause: java.nio.file.NoSuchFileException: /usr/share/elasticsearch/config ...
[解决方法](https://www.cnblogs.com/yswenli/p/6397351.html)
其实就是： cp -r /etc/elasticsearch /usr/share/elasticsearch/config
➜  ~ groupadd elsearch
➜  ~ useradd elsearch -g elsearch -p elsearch
➜  ~ cd /usr/share  
➜   chown -R elsearch:elsearch elasticsearch 
➜  su elsearch
这是因为elasticsearch需要读写配置文件，我们需要给予config文件夹权限，上面新建了elsearch用户，elsearch用户不具备读写权限，因此还是会报错，解决方法是切换到管理员账户，赋予权限即可：
sudo -i
chmod -R 775 config
[这篇讲的很全](https://www.linuxidc.com/Linux/2018-11/155518.htm)



安装sense
其实这个是Kibana的一个应用
安装：yum install -y kibana
测试运行也是一样的路径
    http://localhost:5601/app/sense
这个是emmm，测试？



关于javaAPI交互
节点客户端（Node client）
    节点客户端作为一个非数据节点加入到本地集群中。换句话说，它本身不保存任何数据，但是它知道数据在集群中的哪个节点中，并且可以把请求转发到正确的节点。
传输客户端（Transport client）
    轻量级的传输客户端可以将请求发送到远程集群。它本身不加入集群，但是它可以将请求转发到集群中的一个节点上。
两个 Java 客户端都是通过 9300 端口并使用 Elasticsearch 的原生 传输 协议和集群交互。集群中的节点通过端口 9300 彼此通信。如果这个端口没有打开，节点将无法形成一个集群。
</code></pre>]]></content>
      <categories>
        <category>理论</category>
      </categories>
      <tags>
        <tag>网络流量</tag>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>算法实验</title>
    <url>/2019/11/10/%E7%AE%97%E6%B3%95%E5%AE%9E%E9%AA%8C/</url>
    <content><![CDATA[<h4 id="简介：包括线性时间算法，最长递增子序列，以斐波那契堆实现迪杰斯特拉算法"><a href="#简介：包括线性时间算法，最长递增子序列，以斐波那契堆实现迪杰斯特拉算法" class="headerlink" title="简介：包括线性时间算法，最长递增子序列，以斐波那契堆实现迪杰斯特拉算法"></a>简介：包括线性时间算法，最长递增子序列，以斐波那契堆实现迪杰斯特拉算法</h4><a id="more"></a>
<h2 id="1-线性时间选择（序数问题）"><a href="#1-线性时间选择（序数问题）" class="headerlink" title="1. 线性时间选择（序数问题）"></a>1. 线性时间选择（序数问题）</h2><ul>
<li>问题描述：已知n个数，找出排序后第k小的数。要求平均时间复杂度为O(n)。</li>
<li>解决思路：使用快速排序的思想解决查找问题，用随机数（舍伍德算法）解决基准问题，用分治策略搭建整体的算法结构。</li>
<li>步骤分析：<br>(1)    使用舍伍德算法选择基准r（第r个数）<br>(2)    用快速排序算法进行下面的操作：将大于基准的数值放于基准后，将小于基准的数值放于基准前，刷新数组的排序。<br>(3)    若想要查找的第k个数值的k比基准r大，则取数组的右边再重复进行以上操作，若小于，则选择左边的，若等于，则输出。</li>
<li>示例：<br><img src="/2019/11/10/%E7%AE%97%E6%B3%95%E5%AE%9E%E9%AA%8C/example1.png" alt><blockquote>
<p>示例分析：输入10个数，分别为5 2 7 8 9 0 1 3 4 6，第5小的元素为4，验证成功。</p>
</blockquote>
</li>
</ul>
<h2 id="2-最长递增子序列问题"><a href="#2-最长递增子序列问题" class="headerlink" title="2. 最长递增子序列问题"></a>2. 最长递增子序列问题</h2><ul>
<li>问题描述：寻找最长递增的序列。</li>
<li>解决思路：利用矩阵记录之前的结果，用动态规划法完成寻找</li>
<li>算法步骤：<br>(1)    设置变量有：存储当前最长序列的值的数组tempmax，存储最长序列长度maxlen存储最长序列的最大值下标maxindex<br>(2)    从下标为1的值开始遍历<br>(3)    若i下标下的值比前一个值大，则更新tempmax[i]=tempmax[i-1]+1，即增加长度1，若此时的tempmaxp[i]比maxlen大，则更新maxlen，且更新maxindex=1</li>
<li>示例：<br><img src="/2019/11/10/%E7%AE%97%E6%B3%95%E5%AE%9E%E9%AA%8C/example2.png" alt><br>示例分析：<blockquote>
<p>输入10个数分别为1 3 2 4 5 3 7 8 9 6，其最长递增子序列为3 7 8 9，长度为4，验证成功。</p>
</blockquote>
</li>
</ul>
<h2 id="3-斐波那契堆实现最短路径算法（迪杰斯特拉）"><a href="#3-斐波那契堆实现最短路径算法（迪杰斯特拉）" class="headerlink" title="3. 斐波那契堆实现最短路径算法（迪杰斯特拉）"></a>3. 斐波那契堆实现最短路径算法（迪杰斯特拉）</h2><ul>
<li>问题描述：用斐波那契堆取最小路径辅助迪杰斯特拉算法实现最小路径算法</li>
<li>解决思路：1. 使用贪心算法实现迪杰斯特拉最短路径算法，使用斐波那契堆建立最小堆，方便取最小‘结点’以完成接下来的操作</li>
<li>算法思想：</li>
</ul>
<ol>
<li><p>迪杰斯特拉伪代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">DIJKSTRA(G, w, s)</span><br><span class="line">INITIALIZE - SINGLE - SOURCE(G, s)</span><br><span class="line">S ← Ø</span><br><span class="line">Q ← V[G]   //第3行，INSERT操作，O（1）构造堆</span><br><span class="line">while Q ≠ Ø</span><br><span class="line">	do u ← EXTRACT - MIN(Q)   //第5行，从堆中取出最小点</span><br><span class="line">      S ← S ∪&#123; u &#125;</span><br><span class="line">      for each vertex v ∈ Adj[u]</span><br><span class="line">          do RELAX(u, v, w)  //第8行，RELAX操作，对堆进行降级工作</span><br></pre></td></tr></table></figure></li>
<li><p>其中在第5行的EXTRACT-MIN操作用斐波那契堆实现，斐波那契堆结构如下:</p>
<blockquote>
<ul>
<li>斐波那契堆是由一组最小堆有序树构成的。每个节点的度数为其子节点的数目。树的度数为其根节点的度数。</li>
<li>斐波那契堆中的树都是有根的但是无序。每个节点x包含指向父节点的指针p[x]和指向任意一个子结点的child[x]。x的所有子节点都用双向循环链表链接起来，叫做x的子链表。子链表中的每一个节点y都有指向它的左兄弟的left[y]和右兄弟的right[y]。如果节点y是x仅有的子节点，则left[y]=right[y]=y。</li>
<li>斐波那契堆中所有树的根节点也用一个双向循环链表链接起来。使用一个指针指向斐波那契堆中最小元素。</li>
</ul>
</blockquote>
</li>
<li><p>用稀疏矩阵表示图，定义为weight</p>
</li>
<li><p>具体实现示例分析：<br><img src="/2019/11/10/%E7%AE%97%E6%B3%95%E5%AE%9E%E9%AA%8C/example3-1.png" alt></p>
<blockquote>
<p>其矩阵如：<br> {0,4,NoEdge,2,NoEdge},<br> {4,0,4,1,NoEdge},<br> {NoEdge,4,0,1,3},<br> {2,1,1,0,7},<br>{NoEdge,NoEdge,3,7,0}<br>最终应该得到结果：<br>a-&gt;a=0<br>a-&gt;d-&gt;b=3<br>a-&gt;d-&gt;c=3<br>a-&gt;d=2<br>a-&gt;d-&gt;c-&gt;e=6</p>
</blockquote>
<p> <img src="/2019/11/10/%E7%AE%97%E6%B3%95%E5%AE%9E%E9%AA%8C/example3-2.png" alt="a"><br>测试成功！</p>
</li>
</ol>
]]></content>
      <categories>
        <category>代码编程</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2019/11/10/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p>
<a id="more"></a>

<h2 id="HEXO常用："><a href="#HEXO常用：" class="headerlink" title="HEXO常用："></a>HEXO常用：</h2><h3 id="新建文章"><a href="#新建文章" class="headerlink" title="新建文章"></a>新建文章</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p>
<h3 id="启动本地镜像服务"><a href="#启动本地镜像服务" class="headerlink" title="启动本地镜像服务"></a>启动本地镜像服务</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p>
<h3 id="生成静态文件"><a href="#生成静态文件" class="headerlink" title="生成静态文件"></a>生成静态文件</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p>
<h3 id="上传文件（同步）"><a href="#上传文件（同步）" class="headerlink" title="上传文件（同步）"></a>上传文件（同步）</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br><span class="line">$ hexo d 也可</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p>
<h2 id="常要注意的玩意："><a href="#常要注意的玩意：" class="headerlink" title="常要注意的玩意："></a>常要注意的玩意：</h2><h3 id="hexo图片问题"><a href="#hexo图片问题" class="headerlink" title="hexo图片问题"></a><a href="https://www.jianshu.com/p/3db6a61d3782" target="_blank" rel="noopener">hexo图片问题</a></h3><h3 id="hexo阅读更多"><a href="#hexo阅读更多" class="headerlink" title="hexo阅读更多"></a>hexo阅读更多</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install hexo-generator-index2 --save</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># index2 generator是否包含官方的hexo-generator-index，默认true（包含）</span><br><span class="line">index2_include_index: true</span><br><span class="line">index2_generator:</span><br><span class="line">    per_page: 8</span><br><span class="line">    order_by: -date # 按发布时间排序</span><br><span class="line">    exclude:</span><br><span class="line">        - tag hide # 不包含标签为hide的文章</span><br><span class="line">        - category hide # 不包含分类为hide的文章</span><br></pre></td></tr></table></figure>
<p>然后</p>
<h2 id="博客设置问题："><a href="#博客设置问题：" class="headerlink" title="博客设置问题："></a>博客设置问题：</h2><h3 id="头像-amp-图标："><a href="#头像-amp-图标：" class="headerlink" title="头像&amp;图标："></a>头像&amp;图标：</h3><p>在主题目录下配置文件中.<br>头像：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">author:</span><br><span class="line">  name: DuK</span><br><span class="line">  work: Study,0-1</span><br><span class="line">  location: China</span><br><span class="line">  avatar_url: /images/avatar.png</span><br></pre></td></tr></table></figure>
<p>而其图标：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">favicon: /images/favicon.ico</span><br></pre></td></tr></table></figure>
<p>网站：<a href="http://www.faviconico.org/" target="_blank" rel="noopener">图标制作</a></p>
<h3 id="侧边栏目（标签，归档）"><a href="#侧边栏目（标签，归档）" class="headerlink" title="侧边栏目（标签，归档）"></a>侧边栏目（标签，归档）</h3><p>得先进行</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo new page tags</span><br></pre></td></tr></table></figure>
<p>然后才会有，这里tags还要加上：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: tags</span><br><span class="line">date: 2019-11-10 11:36:27</span><br><span class="line">layout: tags</span><br><span class="line">---</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>配置</tag>
        <tag>博客</tag>
        <tag>指令</tag>
      </tags>
  </entry>
</search>
