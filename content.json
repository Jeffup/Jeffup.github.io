{"meta":{"title":"DuK_Blogs","subtitle":"","description":"","author":"DuK","url":"https://jeffup.github.io","root":"/"},"pages":[{"title":"archives","date":"2019-11-10T03:36:47.000Z","updated":"2019-11-10T03:36:47.668Z","comments":true,"path":"archives/index.html","permalink":"https://jeffup.github.io/archives/index.html","excerpt":"","text":""},{"title":"about","date":"2019-11-10T03:36:04.000Z","updated":"2019-11-10T03:36:04.773Z","comments":true,"path":"about/index.html","permalink":"https://jeffup.github.io/about/index.html","excerpt":"","text":""},{"title":"tags","date":"2019-11-10T03:36:27.000Z","updated":"2019-11-10T05:41:08.515Z","comments":true,"path":"tags/index.html","permalink":"https://jeffup.github.io/tags/index.html","excerpt":"","text":""},{"title":"search","date":"2019-11-10T04:00:01.000Z","updated":"2019-11-10T04:00:01.331Z","comments":true,"path":"search/index.html","permalink":"https://jeffup.github.io/search/index.html","excerpt":"","text":""}],"posts":[{"title":"防火墙入门实验","slug":"防火墙入门实验","date":"2020-06-04T00:25:11.000Z","updated":"2020-06-04T00:26:14.157Z","comments":true,"path":"2020/06/04/防火墙入门实验/","link":"","permalink":"https://jeffup.github.io/2020/06/04/%E9%98%B2%E7%81%AB%E5%A2%99%E5%85%A5%E9%97%A8%E5%AE%9E%E9%AA%8C/","excerpt":"本文章介绍防火墙技术以及各种工具的使用。","text":"本文章介绍防火墙技术以及各种工具的使用。 第一章 iptable的使用一、实验原理1.1 IptablesIptables 是用来设置、维护和检查Linux内核的IP包过滤规则的。 可以定义不同的表，每个表都包含几个内部的链，也能包含用户定义的链。每个链都是一个规则列表，对对应的包进行匹配：每条规则指定应当如何处理与之相匹配的包。这被称作‘target’（目标），也可以跳向同一个表内的用户定义的链。 Iptables中的filter表一般就是用来配置过滤用的。 1.2 Iptables的优点Iptables的最大优点是它可以配置有状态的防火墙，这是ipfwadm和ipchains等以前的工具都无法提供的一种重要功能。有状态的防火墙能够指定并记住为发送或接收信息包所建立的连接的状态。防火墙可以从信息包的连接跟踪状态获得该信息。在决定新的信息包过滤时，防火墙所使用的这些状态信息可以增加其效率和速度。这里有四种有效状态，名称分别为ESTABLISHED、INVALID、NEW和RELATED。 状态ESTABLISHED指出该信息包属于已建立的连接，该连接一直用于发送和接收信息包并且完全有效。INVALID状态指出该信息包与任何已知的流或连接都不相关联，它可能包含错误的数据或头。状态NEW意味着该信息包已经或将启动新的连接，或者它与尚未用于发送和接收信息包的连接相关联。最后，RELATED表示该信息包正在启动新连接，以及它与已建立的连接相关联。 iptables的另一个重要优点是，它使用户可以完全控制防火墙配置和信息包过滤。用户可以定制自己的规则来满足特定需求，从而只允许用户想要的网络流量进入系统。 另外，iptables是免费的，这对于那些想要节省费用的人来说十分理想，它可以代替昂贵的防火墙解决方案。 1.3 链表结构四个表：iptables由四个表:filter,nat,mangle,raw，默认表是filter（没有指定表的时候就是filter表）。表的处理优先级：raw&gt;mangle&gt;nat&gt;filter。 filter：一般的过滤功能 nat:用于nat功能（端口映射，地址映射等） mangle:用于对特定数据包的修改 raw:有限级最高，设置raw时一般是为了不再让iptables做数据包的链接跟踪处理，提高性能。 五个链：这五个规则链也被称为五个钩子函数（hook functions），五个位置。 REROUTING (路由前)：内核空间中，从一个网络接口进来，到另一个网络接口去的 INPUT (数据包流入口)：数据包从内核流入用户空间的 FORWARD (转发管卡)：数据包从用户空间流出的 OUTPUT(数据包出口)：进入/离开本机的外网接口 POSTROUTING（路由后）：入/离开本机的内网接口 二、基本使用2.1 查看相关信息 查看版本信息：iptables -V 查看安装路径“：whereis iptables 查看帮助：iptables --help 2.2 查看表和每个表中的规则 查看filter表中的规则：iptables -t filter –L 查看Nat表中的规则：iptables -t nat -L 查看Mangle表中的规则：iptables -t mangle –L 查看Raw表中的规则：iptables -t raw –L 查看所有表：见第7点图。（文件ip_tables_names） 查看某条链的规则：iptables -t filter/nat/mangle/raw -L INPUT/OUTPUT/FORWARD/PREROUTING/POSTROUTING查看某条链的rule。如查看nat表PREROUTING链中的规则：iptables –t nat –L PREROUTING。 查看Iptables有哪些target：目录：/proc/net 2.3 删除表中的规则 删除每个非内建的链：iptables –t /raw/mangle/nat/filter –X。如：iptables -t raw -X，因为此时没有建链，所以没效果 清空链中的规则：iptables –t raw/mangle/nat/filter –F。其实就是把规则一个个删除。（注：-F删除，-L查看） 三、实验3.1 查看iptables服务Kali上的iptables不以服务形式管理。在Kali启动时iptables默认自动启动。 Kali系统保存iptables规则的方式也比较特殊。下面举一个例子： 输入策略：操作机可以ping目标机；目标机不能ping操作机。指令：iptables -A INPUT -p icmp --icmp-type 8 -j DROP保存到文件：iptables-save &gt; /etc/iptables.up.rules查看文件：cat /etc/iptables.up.rules 重启后添加的规则会丢失，这时我们可以在网络启动时应用我们保存的规则。则可以这样做： 打开文件：gedit /etc/network/interfaces添加：pre-up iptables-restore&lt;/etc/iptables.up.rules保存退出 3.2 查看和删除iptables规则现有规则如下：则执行iptables -F &amp;&amp; iptables -L 3.3 设置iptables的策略和规则 设置filter表中3个链的默认策略为拒绝。命令如下：iptables -P INPUT DROP &amp;&amp; iptables -P OUTPUT DROP &amp;&amp; iptables -P FORWARD DROP使用iptables -L查看是否设置成功。结果如图所示(把我的ssh都断了)：可以看到，都DROP了。 添加一个用户自定义的链DuK。命令如下：iptables -N DuK使用iptables -L查看结果如图所示： 向filter表的INPUT链的最后添加一条规则，对来自10.10.10.254这台主机的数据包丢弃。命令如下：iptables -A INPUT -s 10.10.10.254 -j DROP 向filter表的INPUT链中添加一条规则，拒绝来自其他主机的ping请求。命令如下：iptables -A INPUT -p icmp --icmp-type 8 -j DROP(之前做过，这里就不重复了) 四、实验（二）4.1 恢复环境删除规则：iptables -F设置接受数据包：iptables -P INPUT ACCEPT &amp;&amp; iptables -P OUTPUT ACCEPT &amp;&amp; iptables -P FORWARD ACCEPT 4.2 测试规则定义规则：iptables -t filter -A INPUT -s 10.10.10.254 -p icmp -j DROP 注：-t 表；-A 链；-s 源地址；-p 协议；-j 目标（动作） 4.3 准备环境and抓包分析现在不要IP为10.10.10.254这台主机了，转向系统为winxp、IP为10.10.10.130。在winxp主机上安装科来网络分析系统进行抓包分析。 推荐下载地址：点击我！，里面附带破解教程以及汉化教程。完成后的界面如下： 勾选“本地连接”，然后点击按钮让winxp对10.10.10.128进行ping 抓包分析 注：当然，wireshark、fiddler也OK 五 总结5.1 使用方法： iptables [-p table] 链管理 chain-t table : filter,nat,mangle,raw (默认为 filter) 链管理：-F : 清空规则链-N ：创建新的自定义规则链-X : drop 删除用户自定义的规则链-P : Policy 为指定链设置默认策略；iptables -t filter -P FORWARD DROP-E：重命令自定义链 规则管理：-A：蒋新规则添加到指定的链上-I：将新规则插入到指定的位置-D：删除链上的指定规则-R：替代指定链上的规则 查看：-L：列表，列出指定链上的指定的规则-n -v –line-numbers -x 等参数 匹配条件：基本匹配：-s 原地址IP-d 目的IP-p 协议{tcp|udp|icmp}-i 数据报文的流入接口-o 数据报文的流出接口 扩展匹配：-m match_name-dport PORT:目标端口，可以是单个端口-sport PORT:源端口-p udp|tcp|icmp–icmp-type0 : echo-reply8 : echo-request 目标(filter)：-j TARGET：jump至指定的TARGET ACCEPT 接受 DROP 丢弃 REJECT 拒绝访问 RETURN 返回调用链 5.2 什么时候用什么表和链？【出处】用什么链所以，根据上图，我们能够想象出某些常用场景中，报文的流向：到本机某进程的报文：PREROUTING –&gt; INPUT由本机转发的报文：PREROUTING –&gt; FORWARD –&gt; POSTROUTING由本机的某进程发出报文（通常为响应报文）：OUTPUT –&gt; POSTROUTING 用什么表其中，数据流图如下：因为各个表有着不同的链，故他们分别是这样的： 第二章 IPTABLES表格的应用一、环境设置 windows server 2008 IP:10.10.10.133(用户：administrator 密码：abc123+kali IP:10.10.10.128linux IP:10.10.10.254(网关）linux IP:10.10.10.129(服务器)设置windows开启telnet： 二、filter表实验【默认filter】2.1 kali使用telnet连接win注：输入exit退出 2.2 设置iptables的telnet策略 kali禁止telnet连接到winiptables -A OUTPUT -p tcp --dport 23 -j DROP 解析：首先禁止telnet就意味着我们禁止的是自己的，当然就得用OUTPUT，而不是INPUT，指定telnet的协议tcp，指定端口–dport为23，然后指定你要干嘛-j DROP（抛弃） 效果如下： kali禁止Ping策略（这个其实在之前写过的）iptables -A INPUT -p icmp -j DROP 注：这个是谁都不能ping，添上–icmp-type 8 就变成可以请求（即kali能ping，其他的不行） 三、mangle表实验首先，mangle表示用来干嘛的？用于对特定数据包的修改！ 通过第一章的总结，我们知道mangle里面都有哪些链，分别是：注：清空大师：iptables -F &amp;&amp; iptables -X 注意，mangle表仅有的-j 目标有： TTL MASK TOS 3.1 修改ping包的ttl对10.10.10.133进行Ping：我们可以看出返回的ttl值为128： TTL是 Time To Live的缩写，该字段指定IP包被路由器丢弃之前允许通过的最大网段数量。TTL是IPv4包头的一个8 bit字段。TTL是IP数据包在计算机网络中可以转发的最大跳数。TTL字段由IP数据包的发送者设置，在IP数据包从源到目的的整个转发路径上，每经过一个路由器，路由器都会修改这个TTL字段值，具体的做法是把该TTL的值减1，然后再将IP包转发出去。如果在IP包到达目的IP之前，TTL减少为0，路由器将会丢弃收到的TTL=0的IP包并向IP包的发送者发送 ICMP time exceeded消息。 现修改ttl值：iptables -t mangle -A PREROUTING -i eth0 -j TTL --ttl-set 66结果如下： 解析：这里的包肯定是传进来的，在INPUT之前就得修改包的内容（不然就只给自己看啊），所以得使用PREROUTING表。然后选定网卡（IP地址是10.10.10.128的网卡，如果有多张又不指定，就完了），至于目标-j，这个没有DROP（这是filter的）。。。还包括TTL，了解详细设置可以执行指令：iptables -j TTL -h|more 3.2 mangle表的简单MARK操作1MARK（特殊标记，用来做高级路由），分别使用以下命令：iptables -t mangle -A PREROUTING -p tcp --dport 22 -j MARK --set-mark 2iptables -t mangle -A PREROUTING -p tcp --dport 80 -j MARK --set-mark 3 命令解释：在对数据包路由之前，可以根据协议，端口等对数据包进行标记。这里我们列举ssh(端口为22)标记值为2；http(端口为80)标记值为3。。 MARK用来给包设置特殊的标记。iproute2能识别这些标记，并根据不同的标记（或没有标记） 决定不同的路由。用这些标记我们可以做带宽限制和基于请求的分类。将封包做标记，以便提供作为后续过滤的条件判断依据，进行完此处理动作后，将会继续比对其它规则。 3.3 mangle表的简单TOS操作要求找一条路径使延时最小，一些标准服务如SSH、FTP- control 就需要这个选项。 命令：iptables -t mangle -A PREROUTING -p tcp --dport 22 -j TOS --set-tos 0x10使用命令：iptables -t mangle -L 四、raw表实验4.1 对操作机进行压力测试，查看跟踪连接到包的大小首先IP为10.10.10.129开启tomcat功能：Kali执行命令：ab -c 1000 -n 5000 http://10.10.10.129:8080注：如果测试第一次失败了，可以多次尝试。 ab是apachebench命令的缩写。 ab的原理：ab命令会创建多个并发访问线程，模拟多个访问者同时对某一URL地址进行访问。它的测试目标是基于URL的，因此，它既可以用来测试tomcat的负载压力，也可以测试nginx、lighthttp、apache、IIS等其它Web服务器的压力。 ab命令对发出负载的计算机要求很低，它既不会占用很高CPU，也不会占用很多内存。但却会给目标服务器造成巨大的负载，其原理类似CC攻击。自己测试使用也需要注意，否则一次上太多的负载。可能造成目标服务器资源耗完，严重时甚至导致死机。 -c命令为：一次产生的请求个数。默认是一次一个。 4.2 使用命令为raw表添加两条规则：iptables -t raw -A PREROUTING -p tcp -m tcp --dport 8080 -j NOTRACKiptables -t raw -A OUTPUT -p tcp -m tcp --sport 8080 -j NOTRACK 使用“iptables -t raw -L”查看向raw表添加的规则。如图。 通过NOTRACK给不需要被连接跟踪的包打标记，也就是说，如果一个连接遇到了-j NOTRACK，conntrack就不会跟踪该连接Iptables–A是添加规则的命令sport, source port 源端口dport, destination port 目的端口 第三章 其他防火墙一、Agnitum Outpost FirewallAgnitum Outpost Firewall Pro是一个受到越来越多用户喜爱和关注的优秀防火墙，占用资源相对较小，设置灵活方便，稳定强悍，可以算得上个人防火墙中的佼佼者了。东西虽好，可是很多人在使用中只是让软件的默认设置在发挥作用，而防火墙的默认设定往往更侧重于兼容性方面的考虑，想让防火墙更好的发挥作用，就需要你根据自己的网络情况作出调整和配置。 具有一般防火墙常有的应用程序访问规则控制以及独特的私人信息保护(防止密码泄露)、内容管理(防止查看不合适的网页内容,允许按特定关键字以及特定网地进行过滤)、DNS 缓存保护、Web页交互元素控制(过滤您不需要的例如 GIF/ActvieX/Flash/图片等界面元素)、反间谍软件(带有类似杀毒软件实时监控,防止恶意软件的入侵)、特定应用程序行为控制等。独特的自我保护机制可以防止Outpost自身被恶意软件非法终止或运行所需的文件被篡改。 1.1 实验工具（Outpost Firewall pro）网络防火墙 (OutPost Firewall Pro)是一款功能之强大，可以秒杀很多防火墙软件，包括了广告和图片过滤、内容过滤、DNS缓存等功能。它能够预防来自Cookies、广告、电子邮件病毒、后门、窃密软件、解密高手、广告软件和其它Internet危险的威胁。 Agnitum Outpost Firewall是一款短小精悍的网络防火墙软件，2009年世界排名第二，它的功能是同类PC软件中最强的，甚至包括了广告和图片过滤、内容过滤、DNS缓存等功能。它能够预防来自Cookies、广告、电子邮件病毒、后门、窃密软件、解密高手、广告软件和其它 Internet 危险的威胁。该软件不需配置就可使用，这对于许多新手来说，变得很简单。尤为值得一提的是，这是市场上第一个支持插件的防火墙，这样它的功能可以很容易地进行扩展。该软件资源占用也很小。 推荐下载地址 64-bit：http://www.32r.com/soft/20996.html 32-bit：http://xiazai.zol.com.cn/detail/49/486751.shtml 二、普通过滤包（风云防火墙）2.1 包过滤是什么包过滤可以分为协议包过滤和端口包过滤。 协议包过滤是因为数据在传输过程中首先要封装然后到达目的地时再解封装，不同协议的数据包它所封装的内容是不同的。 协议包过滤就是根据不同协议的封装的包头内容不一样来实现对数据包的过滤。可以分为IP包过滤、TCP包过滤、UDP包过滤等多种数据包的过滤。 端口的包过滤和协议包过滤类似，只不过它是根据数据包的源端口和目的端口来进行的包过滤。 2.2 防火墙的定义所谓防火墙指的是一个有软件和硬件设备组合而成、在内部网和外部网之间、专用网与公共网之间的界面上构造的保护屏障。是一种获取安全性方法的形象说法，它是一种计算机硬件和软件的结合，使Internet与Intranet之间建立起一个安全网关（Security Gateway），从而保护内部网免受非法用户的侵入，防火墙主要由服务访问政策、验证工具、 包过滤和 应用网关4个部分组成， 防火墙就是一个位于计算机和它所连接的网络之间的软件或硬件(其中硬件防火墙用的很少只有国防部等地才用,因为它价格昂贵)。该计算机流入流出的所有网络通信均要经过此防火墙。 软件防火墙单独使用软件系统来完成防火墙功能，将软件部署在系统主机上，其安全性较硬件防火墙差，同时占用系统资源，在一定程度上影响系统性能。其一般用于单机系统或是极少数的个人计算机，很少用于计算机网络中。 2.3 防火墙的优点 防火墙能强化安全策略。 防火墙能有效地记录Internet上的活动。 防火墙限制暴露用户点。防火墙能够用来隔开网络中一个网段与另一个网段。这样，能够防止影响一个网段的问题通过整个网络传播。 防火墙是一个安全策略的检查站。所有进出的信息都必须通过防火墙，防火墙便成为安全问题的检查点，使可疑的访问被拒绝于门外。 2.4 风云防火墙小实验推荐下载地址：https://www.onlinedown.net/soft/57372.htm如图设置，当有人ping自己时，会拦截，并记录：","categories":[],"tags":[{"name":"攻防","slug":"攻防","permalink":"https://jeffup.github.io/tags/%E6%94%BB%E9%98%B2/"},{"name":"实验","slug":"实验","permalink":"https://jeffup.github.io/tags/%E5%AE%9E%E9%AA%8C/"}]},{"title":"入侵检测实验","slug":"入侵检测实验","date":"2020-05-26T14:45:35.000Z","updated":"2020-05-26T14:54:34.237Z","comments":true,"path":"2020/05/26/入侵检测实验/","link":"","permalink":"https://jeffup.github.io/2020/05/26/%E5%85%A5%E4%BE%B5%E6%A3%80%E6%B5%8B%E5%AE%9E%E9%AA%8C/","excerpt":"本文章介绍入侵检测技术以及各种工具的使用。","text":"本文章介绍入侵检测技术以及各种工具的使用。 第一章 入侵检测一、原理入侵检测系统，简称IDC，是一种基于硬件的防火墙，通过建控以知系统漏洞，黑客入侵手法并记录下来，通过分析数据包，安全的就通过。危险的就拦截，通过日志记录可轻松追查到入侵者的IP，用于取证。 入侵检测技术（IDS）可以被定义为对计算机和网络资源的恶意使用行为进行识别和相应处理的系统。包括系统外部的入侵和内部用户的非授权行为,是为保证计算机系统的安全而设计与配置的一种能够及时发现并报告系统中未授权或异常现象的技术，是一种用于检测计算机网络中违反安全策略行为的技术。 1.1 什么是入侵入侵，就是恶意攻击者（俗称黑客），不经授权的控制、使用我方资源（读写文件、执行命令、控制网络资源等） 1.2 入侵和内鬼入侵本身是手段，GetShell只是开始，目的是为了之后对资源的控制和数据的窃取。而内鬼本身拥有合法的权限，可以合法接触敏感资产，但是基于工作以外的目的对这些资源进行非法处置，包括拷贝副本、转移外泄、篡改数据牟利等 二、入侵的本质2.1 入侵检测的本质根据特征进行模式匹配；（黑特征法，例如WebShell关键字匹配） 根据业务历史行为（生成基线模型），对入侵行为做异常对比；（非白既黑），如果业务的历史行为不够收敛，就用加固的手段对其进行收敛，再挑出不合规的小众异常行为。 2.2 入侵检测与攻击向量针对一个明确的“目标”，它被访问的渠道可能是有限集，被攻击的必经路径也有限。一个可以成功入侵的 攻击方法 + 目标 合并起来，就称为一个“攻击向量” 因此，谈入侵检测模型效果时，需要先明确攻击向量，针对不同的攻击路径，采集对应的数据，才可能做对应的检测模型。比如，基于SSH登录后的SHELL命令采集，是不会让你发现Webshell的攻击的。而基于网络流量的采集数据，也不会让你获悉黑客是否在SSH后的SHELL环境里执行了什么文件切割打包的动作。 2.3 常见的入侵手法 高危服务入侵：所有的公共服务都叫做高危端口 Web入侵：基于PHP、JAVA、ASP/http://ASP.NET、NODE、C写的cgi等等动态的Web服务本身的漏洞 0day入侵 ：通过NSA泄漏的工具包 通过办公网入侵 ：绝大多数APT报告里，黑客是先对人下手，比如发个邮件，哄骗你打开后，控制了你的PC，再进行长期的观察/翻阅，拿到你的合法凭据后，再到内网漫游 2.4 常见入侵的应对方法 高危服务入侵：在这里做入侵检测的必要性不高，因为高危服务的具体所指非常的多，不一定存在通用的特征，所以，通过加固方式，收敛攻击入口才是更有效的策略。禁止所有高危端口对互联网开放即可 Web入侵：找到黑客GetShell和正常业务行为的一些区别 0day入侵：入侵检测模型可以通用 三、 发现APT所谓APT，就是高级的持续威胁。既然是高级的，按照一般的描述，他们的木马是免杀的（不能假定我们可以发现这个木马）、他们的漏洞不公开的（不能假定我们可以加固抵抗）、他们的手法是高级的（不能假定这个手法在已知的范畴里）。 所以，实际上APT的意思就几乎等同于我们不能发现的入侵事件了。 但是，业界总还有APT检测产品、解决方案的厂商在混饭吃，他们是怎么做的呢？ 说木马免杀的，他们用沙箱+人工分析，哪怕效率低一些，还是试图做出定性，并快速的把IOC（威胁情报）同步给其它客户，发现1例，全网都去排查。 说流量变形对抗的，他们用异常检测的模型，把一些不认识的可疑的IP关系、payload给识别出来——当然，识别出来之后，也要运营人员跟进得仔细才能定性。 说攻击手法高级的，他们还是会假定黑客就用鱼叉、水坑之类的已知手法去执行，然后在邮箱附件、PC终端等环节采集日志，对用户行为进行分析，UEBA试图寻找出用户异于平常的动作。 第二章 蜜罐（部署实验）一、蜜罐原理1.1 什么是蜜罐蜜罐其实就是一个“陷阱”程序，这个陷阱是指对人侵者而特意设计出来的-些伪造的系统漏洞。这些伪造的系统漏洞，在引诱入侵者扫描或攻击时，就会激活能够触发报警事件的软件。这样一来，网管就可以立即知晓有入侵者侵入了。 也就是说通过设置蜜罐程序，一旦操作系统中出现入侵事件，那么系统就可以很快发出报警。在许多大的网络中。一般都设计有专门的蜜罐程序。蜜罐程序一般分为两种：一种是只发现人侵者而不对其采取报复行动，另一种是同时采取报复行动。 0K，在进行了初步的了解后，请读者先来牢记两个英文的含义： Honeypot：是一种故意存在着缺陷的虛拟系统，用来对黑客进行欺骗。Honeynet：是一个很有学习价値的工具，它能使我们了解黑客人侵的攻击方式。 作为一个包含漏洞的系统，它可以帮助有特殊要求的网络模拟出一个或多个易受攻的主机，给xp系统下载黑客提供易受攻击的口标，让黑客误认为入侵成功，可以为所欲为了。使用蜜罐，主要是为了能够套住黑客，以便网络保安系统和人员能够将之“锁定”。 1.2 蜜罐分类 低交互：模拟服务和漏洞以便收集信息和恶意软件，但是攻击者无法和该系统进行交互； 中等交互：在一个特有的控制环境中模拟一个生产服务，允许攻击者的部分交互； 高交互：攻击者可以几乎自由的访问系统资源直至系统重新清除恢复。 1.3 什么是pentbox基于Ruby开发，面向GNU/Linux系统,且兼容Windows、MacOS、Android等系统。 主要用于帮助安全人员对网络、系统的安全性和稳定性进行测试。但它常被用作黑客工具套件,尤其是它提供的NetDoSTest(网络压力测试)。 二、安装和使用Pentbox2.1 解压 2.2 修改pentbox.rb，注释生成日志文件查看文件夹：修改pentbox.rb 2.3 penbox界面根据上面选项，选择Network Tool。然后进行以下选择：80端口已经打开，若有人连接则会显示 2.4 目标机尝试连接已安装Pentbox的机子（ip：10.5.10.42）目标机用浏览器连接机子后，机子展示界面： HONEYPOT ACTIVATED ON PORT 80其中80为域名 第三章 后门检测工具一、实验原理1.1 rootkit简介rootkit是Linux平台下最常见的一种木马后门工具，它主要通过替换系统文件来达到入侵和和隐蔽的目的，这种木马比普通木马后门更加危险和隐蔽，普通的检测工具和检查手段很难发现这种木马。rootkit攻击能力极强，对系统的危害很大，它通过一套工具来建立后门和隐藏行迹，从而让攻击者保住权限，以使它在任何时候都可以使用root权限登录到系统。 rootkit主要有两种类型：文件级别和内核级别，下面分别进行简单介绍。 文件级别rootkit文件级别的rootkit一般是通过程序漏洞或者系统漏洞进入系统后，通过修改系统的重要文件来达到隐藏自己的目的。在系统遭受rootkit攻击后，合法的文件被木马程序替代，变成了外壳程序，而其内部是隐藏着的后门程序。通常容易被rootkit替换的系统程序有login、ls、ps、ifconfig、du、find、netstat等，其中login程序是最经常被替换的，因为当访问Linux时，无论是通过本地登录还是远程登录，/bin/login程序都会运行，系统将通过/bin/login来收集并核对用户的账号和密码，而rootkit就是利用这个程序的特点，使用一个带有根权限后门密码的/bin/login来替换系统的/bin/login，这样攻击者通过输入设定好的密码就能轻松进入系统。此时，即使系统管理员修改root密码或者清除root密码，攻击者还是一样能通过root用户登录系统。攻击者通常在进入Linux系统后，会进行一系列的攻击动作，最常见的是安装嗅探器收集本机或者网络中其他服务器的重要数据。在默认情况下，Linux中也有一些系统文件会监控这些工具动作，例如ifconfig命令，所以，攻击者为了避免被发现，会想方设法替换其他系统文件，常见的就是ls、ps、ifconfig、du、find、netstat等。如果这些文件都被替换，那么在系统层面就很难发现rootkit已经在系统中运行了。 这就是文件级别的rootkit，对系统维护很大，目前最有效的防御方法是定期对系统重要文件的完整性进行检查，如果发现文件被修改或者被替换，那么很可能系统已经遭受了rootkit入侵。检查件完整性的工具很多，常见的有Tripwire、 aide等，可以通过这些工具定期检查文件系统的完整性，以检测系统是否被rootkit入侵。 内核级别的rootkit内核级rootkit是比文件级rootkit更高级的一种入侵方式，它可以使攻击者获得对系统底层的完全控制权，此时攻击者可以修改系统内核，进而截获运行程序向内核提交的命令，并将其重定向到入侵者所选择的程序并运行此程序，也就是说，当用户要运行程序A时，被入侵者修改过的内核会假装执行A程序，而实际上却执行了程序B。 内核级rootkit主要依附在内核上，它并不对系统文件做任何修改，因此一般的检测工具很难检测到它的存在，这样一旦系统内核被植入rootkit，攻击者就可以对系统为所欲为而不被发现。目前对于内核级的rootkit还没有很好的防御工具，因此，做好系统安全防范就非常重要，将系统维持在最小权限内工作，只要攻击者不能获取root权限，就无法在内核中植入rootkit。 1.2 chkrootkit的缺点chkrootkit在检查rootkit的过程中使用了部分系统命令，因此，如果服务器被黑客入侵，那么依赖的系统命令可能也已经被入侵者替换，此时chkrootkit的检测结果将变得完全不可信。为了避免chkrootkit的这个问题，可以在服务器对外开放前，事先将chkrootkit使用的系统命令进行备份。 1.3 rootkit后门检测工具RKHunterRKHunter是一款专业的检测系统是否感染rootkit的工具，它通过执行一系列的脚本来确认服务器是否已经感染rootkit。在官方的资料中，RKHunter可以作的事情有： MD5校验测试，检测文件是否有改动检测rootkit使用的二进制和系统工具文件检测特洛伊木马程序的特征码检测常用程序的文件属性是否异常检测系统相关的测试检测隐藏文件检测可疑的核心模块LKM检测系统已启动的监听端口 二、软件chkrootkit2.1 安装chkrootkit从官网上下载安装，安装完成：注：上图中的错误并不影响下面的操作 2.2 复制一份文件到 /usr/local/chkrootkit路径下，将原有带版本号的删除1234cd ..cp -r chkrootkit-* /usr/local/chkrootkit 拷贝一份文件rm -rf chkrootkit-* 2.3 使用chkrootkit安装完的chkrootkit程序位于/usr/local/chkrootkit目录下，执行如下命令即可显示chkrootkit的详细用法,如图下所示：/usr/local/chkrootkit/chkrootkit -h下面是为上图的各参数进行解释，含义如图下所示： -h 显示帮助信息-v 显示版本信息-l 显示测试内容-d debug模式，显示检测过程的相关指令程序-q 安静模式，只显示有问题的内容-x 高级模式，显示所有检测结果-r dir设置指定的目录为根目录-p dir1：dir2：dirN指定chkrootkit检测时使用系统命令的目录 chkrootkit的使用比较简单，直接执行chkrootkit -x进入高级模式，显示所有检测结果，检测结果如图下所示：/usr/local/chkrootkit/chkrootkit -x 三、软件RKHunter3.1 安装RKHunter官网：http://www.rootkit.nl/projects/rootkit_hunter.html解压之后进入目录，对文件进行编译，结果如图下所示： 12cd rkhunter-1.4.6./installer.sh --layout default --install 安装成功：下图是对常用参数以及含义的解释： -c, –check必选参数，表示检测当前系统–configfile 使用特定的配置文件–cronjob作为cron任务定期运行–sk, –skip-keypress自动完成所有检测，跳过键盘输入–summary显示检测结果的统计信息–update检测更新内容-V, –version显示版本信息–versioncheck检测最新版本 3.2 使用RKHunter下面是通过rkhunter对某个系统的检测，结果如图下所示：执行：/usr/local/bin/rkhunter -c 下面是第一部分，先进行系统命令的检查，主要是检测系统的二进制文件，因为这些文件最容易被rootkit攻击。显示OK字样表示正常，显示Warning表示有异常，需要引起注意，而显示“Not found”字样，一般无需理会。 下面是第二部分，主要检测常见的rootkit程序，显示“Not found”表示系统未感染此rootkit，结果如图所示： 下面是第三部分，主要是一些特殊或附加的检测，例如对rootkit文件或目录检测、对恶意软件检测以及对指定的内核模块检测,结果如图下所示： 下面是第四部分，主要对网络、系统端口、系统启动文件、系统用户和组配置、SSH配置、文件系统等进行检测，结果如图所示： 下面是最后一部分，这个部分其实是上面输出的一个总结，通过这个总结，可以大概了解服务器目录的安全状态，结果如图所示： 第四章 Surikata入侵检测系统一、简介1.1 Suricata简介Suricata是一个高性能的网络IDS，IPS和网络安全监控引擎。 IPS：入侵预防系统(IPS: Intrusion Prevention System)是电脑网络安全设施，是对防病毒软件（Antivirus Programs）和防火墙(Packet Filter, Application Gateway)的补充。 入侵预防系统(Intrusion-prevention system)是一部能够监视网络或网络设备的网络资料传输行为的计算机网络安全设备，能够即时的中断、调整或隔离一些不正常或是具有伤害性的网络资料传输行为。是新一代的侵入检测系统（IDS）。 Suricata是一个网络入侵检测和防护引擎，由开放信息安全基金会及其支持的厂商开发。该引擎是多线程的，内置支持IPV6。可加载现有的Snort规则和签名，支持Barnyard 和 Barnyard2 工具. IDS：英文“Intrusion Detection Systems”的缩写，中文意思是“入侵检测系统”。依照一定的安全策略，通过软、硬件，对网络、系统的运行状况进行监视，尽可能发现各种攻击企图、攻击行为或者攻击结果，以保证网络系统资源的机密性、完整性和可用性。 Barnyard：知名的开源IDS的日志工具，具有快速的响应速度，优异的数据库写入功能，是做自定义的入侵检测系统不可缺少的插件。 1.2 Suricata 入侵检测系统随着安全威胁的不断发生，入侵检测系统（IDS）在如今的数据中心环境中显得尤为必要。然而，随着越来越多的服务器将他们的网卡升级到10GB/40GB以太网，对如此线路上的硬件进行计算密集型的入侵检测越来越困难。其中一种提升入侵检测系统性能的途径是多线程入侵检测系统，它将 CPU 密集型的深度包检测工作并行的分配给多个并发任务来完成。这样的并行检测可以充分利用多核硬件的优势来轻松提升入侵检测系统的吞吐量。在这方面有两个知名的开源项目，分别是 Suricata 和 Bro. 二、安装2.1 安装命令 需要安装依赖包：apt-get -y install libpcre3 libpcre3-dbg libpcre3-dev build-essential autoconf automake libtool libpcap-dev libnet1-dev libyaml-0-2 libyaml-dev zlib1g zlib1g-dev libmagic-dev libcap-ng-dev libjansson-dev pkg-config 下载安装包wget http://www.openinfosecfoundation.org/download/suricata-2.0.8.tar.gz 进入目录后，编译相应模块（对suricata模块进行编译），然后编译安装123cd suricata-2.0.8./configure --sysconfdir=/etc --localstatedir=/varmake &amp;&amp; make install make install-rules安装IDS规则集，由于下载所读过慢，所以直接查看下载完的规则集：ls /root/apps/rules Suricata源代码随带默认的配置文件，不妨安装这些默认的配置文件，结果如图下所示： 让系统共享动态链接库ldconfig 2.2 配置 Suricata IDS 打开配置文件查看基本配置信息，结果如图下所示：指令：vi /etc/suricata/suricata.yaml 为default-log-dir关键字指定 Suricata 日志文件所在的位置，结果如图所示： 找到vars部分，配置对Suricata来说重要的变量，结果如图所示： 找到threading 部分，你可以为不同的 Suricata 线程指定 CPU 关联，结果如图下所示： 三、使用 多种模式Suricata 支持许多运行模式。运行模式决定着 IDC 会使用何种线程。以下命令可以查看所有可用的运行模式，结果如图所示：指令：/usr/local/bin/suricata --list-runmodes 2.将主目录suricata-2.0.8/rlues下的tls-events.rules，复制到/etc/suricata/rules下指令： 12cd suricata-2.0.8/rules/cp tls-events.rules /etc/suricata/rules 删除rules文件，防止重名，创建目录rules，将下载的规则集也复制到/etc/suricata/rules下。指令： 123rm /etc/suricata/rulesmkdir /etc/suricata/rulescp /root/apps/rules/* /etc/suricata/rules 再将本身自带的规则也添加到/etc/suricata/rules目录。指令：cp /root/suricata-2.0.8/rules/* /etc/suricata/rules/ 将 Suricata 运行起来，结果如图所示：指令：/usr/local/bin/suricata -c /etc/suricata/suricata.yaml -i eth0 --init-errors-fatal 注：图中的警告可以忽略，它只是意味着你的网卡不支持LRO。 查看ip地址并创建hongya用户和密码。 123ifconfiguseradd hongyapasswd hongya 登录目标机，进行ssh连接操作机。指令：ssh hongya@172.17.0.11 执行完 按ctrl+c结束 然后vi查看/var/log/suricata/fast.log日志文件，因为suricata检测日志存储在/var/log/suricata目录下，结果如图下所示：指令：vi /var/log/suricata/fast.log 第五章 安装高级入侵检测环境到centos一、简介AIDE的基本功能 对CentOS来说，最流行的入侵检测系统之一就是AIDE。这种系统可以创建数据库，用来核实你机器上文件的完整性。AIDE的主要功能如下： 支持md5、sha1、rmd160、tiger、crc32、sha256和sha512摘要算法支持这些文件类型：权限、Inode、UID、GID、链接名称、大小、块数量、链接数量、mtime、ctime和atime等文件属性支持这些文件系统属性：Posix ACL、SELinux、XAttrs和Extended支持正则表达式，可以选择性地添加或排除文件/目录支持GZIP数据库压缩 二、安装 安装指令：yum install aide 初始化：aide --init 运行检查，初始化数据库后，它会创建/var/lib/aide/aide.bb.new.gz，执行命令aide --check进行检查，结果如图所示：从上图中我们可以看出命令失败了，那是因为，要想使用AIDE来运行检查，数据库必须位于/var/lib/aide/aide.db.gz.。为了解决这个问题，你得使用这个命令更名刚创建的数据库，然后在运行检查结果如图下所示：执行命令：mv /var/lib/aide/aide.db.new.gz /var/lib/aide/aide.db.gz再执行：aide --check 注：我们这里面的数据库没有修改东西，所以全部文件都匹配，否则会生成一份报告 不妨测试一下AIDE的准确性。创建假文件/usr/bin/aidetest，结果如图所示：12touch /usr/bin/aidetestcd /usr/bin 我们再次运行aide –check进行检查，结果如图下所示：","categories":[],"tags":[{"name":"攻防","slug":"攻防","permalink":"https://jeffup.github.io/tags/%E6%94%BB%E9%98%B2/"},{"name":"实验","slug":"实验","permalink":"https://jeffup.github.io/tags/%E5%AE%9E%E9%AA%8C/"}]},{"title":"linux云计算","slug":"linux云计算","date":"2020-02-08T01:52:28.000Z","updated":"2020-02-08T03:27:42.157Z","comments":true,"path":"2020/02/08/linux云计算/","link":"","permalink":"https://jeffup.github.io/2020/02/08/linux%E4%BA%91%E8%AE%A1%E7%AE%97/","excerpt":"","text":"一 grep的使用1. 颜色：--color```会直接高亮，默认不高亮12### 2. 普通的正则搜索：例子：从文件`/etc/passwd`中搜出`root`，并且高亮。 root@debian:~# grep –color ‘root’ /etc/passwdroot:x:0:0:root:/root:/bin/bash 其他选项： |命令|备注| |-|-| |-i|忽略大小写| |-v|搜索不包含该字符串的内容| |-n|显示符合匹配的行号| |-o|只显示搜索出来的字符串本身| |-q|不显示内容，但有返回值：`$?`，若含有，则`$?`为false：1| |-A -B|A为after，B为before，搜索范围为后几行或者前几行如-A3，前三行| |-C|又有前又有后| |-e|或者包括，例如`grep -e &apos;root&apos; -e &apos;bash&apos; /etc/passwd` |-w|单词，左右为数字或者_下划线，不作为单词| |-f|搜索-f指令文件中的文件中的字符串| *注：-q选项可以用这个命令代替：`grep &apos;root&apos; /etc/passwd &amp;&gt; /dev/null`效果一样的。* ### 3. 匹配的其他形式： * 搜索文件：`ls *ks*` 搜索包含ks正则的文件名 * 搜索内容：`cat -n file.txt |grep ks` 搜索包含ks字符串的内容，并显示行号。 * 配合使用`cut`：cut -d &quot; &quot; -f5以空格为分隔，选取第五列 ### 4. 正则匹配 |符号|备注| |-|-|","categories":[],"tags":[]},{"title":"实现python爬虫的简单细节分析","slug":"实现python爬虫的简单细节分析","date":"2019-12-23T01:51:18.000Z","updated":"2019-12-23T01:53:01.588Z","comments":true,"path":"2019/12/23/实现python爬虫的简单细节分析/","link":"","permalink":"https://jeffup.github.io/2019/12/23/%E5%AE%9E%E7%8E%B0python%E7%88%AC%E8%99%AB%E7%9A%84%E7%AE%80%E5%8D%95%E7%BB%86%E8%8A%82%E5%88%86%E6%9E%90/","excerpt":"实现python爬虫的简单细节分析","text":"实现python爬虫的简单细节分析 爬虫部分1. 这肯定得加个User-Agent，不然连不上这里面可能还要加上cookie，这个有点诡异。你说，有一个值等于 0, 60 ，怎么办？把它变成[]，还是””？？？ 2. 常规路数，使用bs4123456789101112def getHtml(url): try: r = requests.get(url, headers=&#123;&apos;User-Agent&apos;: &apos;Mozilla/5.0&apos;&#125;) r.raise_for_status() r.encoding = &quot;utf-8&quot; return r.text except: print(&quot;Failed!!!&quot;)url = BASE_URL + str(year) + &apos;.html&apos;html = getHtml(url)soup = BeautifulSoup(html, &quot;html.parser&quot;) 然后用find和find_all找到所有相关标签，当然可以指定class=？？？ 3. 爬取表格12345678comment_list = soup.find(&apos;table&apos;, attrs=&#123;&apos;class&apos;: &apos;table&apos;&#125;).find_all(&apos;tr&apos;)for j in comment_list[1:]: # tr2[1:]遍历第1列到最后一列，表头为第0列 td = j.find_all(&apos;td&apos;) # td表格 Rate = td[0].get_text().strip() # 遍历排名 Country = td[1].get_text().strip() # 遍历国家 Area = td[2].get_text().strip() # 遍历洲 Num = td[3].get_text().strip() # 遍历人数 自己看，因为有的会带有列名，注意。 4. 正则表达提取括号内的内容： 1re.findall(r&quot;.*\\((.*)\\)&quot;, Num) 由于提取之后会变成123,123这样的玩意，所以，将其replace替换 1tNum = &quot;&quot;.join(re.findall(r&quot;.*\\((.*)\\)&quot;, Num)).replace(&apos;,&apos;, &apos;&apos;) 好了，这里又将遇到问题：因为有的数据因数字较小，所以不会有()，那么re.findall之后的内容就只有None，如果再进行float，将会报错：ValueError。这时我们可以运用异常处理来解决： 1234try: fNum = float(tNum)except ValueError: fNum = float(Num) 5. 字典与列表的基本应用这里我只用了很少，不管了，先写下来： 添加字典：直接dict[yourkey]=？？就可以 添加列表数据：listData.append(youwant) 删除字典：dict.pop(key) 数据读写部分这里都是对excel表格的操作。 1. 读excel打开文件并且选择相应的sheet注意，因为我存的是xls，所以不能用openxls来进行读，而应该用xlrd 12workbook= xlrd.open_workbook(filepath)worksheet=workbook.sheet_by_name(&apos;ALLdata&apos;) 获取最大行列数12mrow=worksheet.nrowsmcol=worksheet.ncols 读单元格1worksheet.cell(row, colum).value 2. 写excel新建123workbook = xlwt.Workbook()#添加sheet表sheet = workbook.add_sheet(&apos;ALLdata&apos;, cell_overwrite_ok=True) 写入1sheet.write(row, col, str(value)) 这里value必须是str类型，不然会报错！ 保存1workbook.save(filename) 数据分析部分1. 数据拟合及预测拟合函数生成123f1= np.polyfit(xdata, ydata, 3)p1 = np.poly1d(f1)yvals1 = p1(xdata) 注：xdata，ydata是x，y坐标点的系列值，3是曲线拟合次数，此时p1即3次多项式。先把xdata代入p1多项式中，将会生成yvals1相应的值，这个可以作为预测值。 2. 图像生成123456789ln1 = plt.plot(xdata, ydata, color=&apos;red&apos;, label=&apos;original values&apos;)pln1 = plt.plot(xdata, yvals1, color=&apos;blue&apos;, linewidth=2.0, linestyle=&apos;-.&apos;, label=&apos;polyfit values&apos;)# yvals1 = p1(xdata) # 拟合y值plt.xlabel(&apos;year&apos;)plt.ylabel(&apos;population&apos;)plt.legend(loc=4)# plt.show()plt.savefig(country+&quot;.png&quot;)plt.close() 注： ln1是原来的图，那个label是标签（指定这个曲线是啥玩意） pln1是拟合之后的值，使用拟合之后的yvals1。 linestyle=’-.’是线的类型，有– -. - 空等等 而plt.xlabel是指定x轴是啥 plt.show()展示图像 plt.savefig(filename)保存图像为filename 如果不关闭，那么这些xlabel和ylabel会混杂在一起，所以必须使用plt.close()","categories":[],"tags":[{"name":"python","slug":"python","permalink":"https://jeffup.github.io/tags/python/"},{"name":"爬虫","slug":"爬虫","permalink":"https://jeffup.github.io/tags/%E7%88%AC%E8%99%AB/"},{"name":"数据读写","slug":"数据读写","permalink":"https://jeffup.github.io/tags/%E6%95%B0%E6%8D%AE%E8%AF%BB%E5%86%99/"}]},{"title":"UltraEdit的使用及文件类型判定","slug":"UltraEdit的使用及文件类型判定","date":"2019-12-02T07:24:17.000Z","updated":"2019-12-02T07:26:28.648Z","comments":true,"path":"2019/12/02/UltraEdit的使用及文件类型判定/","link":"","permalink":"https://jeffup.github.io/2019/12/02/UltraEdit%E7%9A%84%E4%BD%BF%E7%94%A8%E5%8F%8A%E6%96%87%E4%BB%B6%E7%B1%BB%E5%9E%8B%E5%88%A4%E5%AE%9A/","excerpt":"实验原理1. 文件格式定义 文件格式（或文件类型）是指电脑为了存储信息而使用的对信息的特殊编码方式，是用于识别内部储存的资料。比如有的储存图片，有的储存程序，有的储存文字信息。","text":"实验原理1. 文件格式定义 文件格式（或文件类型）是指电脑为了存储信息而使用的对信息的特殊编码方式，是用于识别内部储存的资料。比如有的储存图片，有的储存程序，有的储存文字信息。每一类信息，都可以一种或多种文件格式保存在电脑存储中。每一种文件格式通常会有一种或多种扩展名可以用来识别，但也可能没有扩展名。扩展名可以帮助应用程序识别的文件格式。对于硬盘机或任何电脑存储来说，有效的信息只有0和1两种。所以电脑必须设计有相应的方式进行信息-位元的转换。对于不同的信息有不同的存储格式。 2.文件格式概述 有些文件格式被设计用于存储特殊的数据，例如：图像文件中的JPEG文件格式仅用于存储静态的图像，而GIF既可以存储静态图像，也可以存储简单动画；Quicktime 格式则可以存储多种不同的媒体类型。文本类的文件有：text文件一般仅存储简单没有格式的ASCII或Unicode的文本；HTML文件则可以存储带有格式的文本；PDF格式则可以存储内容丰富的，图文并茂的文本。 同一个文件格式，用不同的程序处理可能产生截然不同的结果。例如Word 文件，用Microsoft Word观看的时候，可以看到文本的内容，而以无格式方式在音乐播放软件中播放，产生的则是噪声。一种文件格式对某些软件会产生有意义的结果，对另一些软件来看，就像是毫无用途的数字垃圾。 3. 文件格式的规范 许多文件格式都有公开的、不同程度规范或者建议的格式。这些规范或者建议描述了数据如何编码，如何排列。有时也规定了是否需要特定的电脑程序读取或处理。有两种情况下，文件格式没有公开。第一种情况是：开发者将文件格式视作商业秘密不愿公开；第二种情况是：开发者不愿或花去很少的时间用于规范文档。 需要注意的是，使用不公开的文件格式可能会带来额外的成本。要了解这类文件格式或者需要通过对获得的文件进行逆向工程，或者通过向开发者付费来获得文件的格式。第二种方式中往往还需要与开发者签订不扩散协议。不论怎样两种方式都是费时，费钱的。 4. 识别文件的类型 从程序的角度来看，文件是数据流，文件系统为每一种文件格式规定了访问的方法。例如：元数据。不同的操作系统都习惯性的采用各自的方式解决这个问题，每种方式都有各自的优缺点。 当然，现代的操作系统和应用程序，一般都需要这里所讲述的方法处理不同的文件。 5. 扩展名 用扩展名识别文件格式的方式最先在数字设备公司的CP/M操作系统被采用。而后又被DOS和Windows操作系统采用。扩展名是指文件名中，最后一个点（.）号后的字母序列。例如，HTML文件通过.htm或.html扩展名识别；GIF图形文件用.gif扩展名识别。在早期的FAT文件系统中，扩展名限制只能是三个字符，因此尽管现在绝大多数的操作系统已不再有此限制，许多文件格式至今仍然采用三个字符作扩展名。因为没有一个正式的扩展名命名标准，所以，有些文件格式可能会采用相同的扩展名，出现这样的情况就会使操作系统错误地识别文件格式，同时也给用户造成困惑。 扩展名方式的一个特点是，更改文件扩展名会导致系统误判文件格式。例如，将filename.html 简单改名为filename.txt会使系统误将HTML文件识别为纯文本格式。尽管一些熟练的用户可以利用这个特点，但普通用户很容易在改名时发生错误，而使得文件变得无法使用。因此，现代的有些操作系统管理程序，例如Windows Explorer加入了限制向用户显示文件扩展名的功能。 6. 特征签名 一种广泛应用在UNIX及其派生的操作系统上的方法是将一个特殊的数字存放在文件的特定位置里。最初这个数字一般是文件开始处的2个字节。现在一般是将任何可以独一无二字符序列都可以作为特征签名。例如GIF图形文件是将文件开始处的六个字节作为特征签名的，它可以是GIF87a或者GIF89a。但也有些文件很难通过这种方式识别，比如HTML文件。 采用这种方式可以更好的防止对文件格式发生误判，并且特征签名可以给出关于文件格式的更详细的信息。这种方式的缺点是效率较低。特别是显示大量的文件时，由于每种特征签名具有不同的识别方式，将消耗系统大量的资源对文件格式进行判断。扩展名和后面将提到的元数据方式由于采用固定格式数据，可进行快速匹配。应用程序往往利用特征签名来判断文件是否完整和有效。 实践操作1.操作系统 操作机：Windows_7 2.实验工具 UltraEdit UltraEdit 是一套功能强大的文本编辑器，可以编辑文本、十六进制、ASCII 码，完全可以取代记事本（如果电脑配置足够强大），内建英文单字检查、C++ 及 VB 指令突显，可同时编辑多个文件，而且即使开启很大的文件速度也不会慢。 步骤1：用UltraEdit工具查看doc和gif文件类型1.1 打开目录”D:\\1、信息安全\\3、信息系统安全\\17软件安全课程\\1.实验工具（一）文件格式猜测实验”，此文件夹下包含几种不同的文件格式。如图所示: 1.2 从桌面打开程序UltraEdit,如图所示： 1.3 点击“文件”-“打开”，打开目录D:\\1、信息安全\\3、信息系统安全\\17软件安全课程\\1.实验工具（一）文件格式猜测实验文件夹下的1-1.doc文件。 1.4 查看打开的1-1.doc文件,并在“00002730h”行查询此文件的格式标识。如图所示：在文件中部出现Microsoft Office Word文档说明此文件格式为word文档。 1.5 再次使用UltraEdit软件打开1-2-2.gif文件。如图所示： 1.6 查看1-2-2.gif的文件格式为GIF。如图所示： 1.7 继续查看1-2.gif的文件格式，你会发现与1-2-2.gif的文件格式一样。如图： 步骤2：用UltraEdit工具查看rar和zip压缩包及其包含文件的文件类型2.1 回到工具目录D:\\1、信息安全\\3、信息系统安全\\17软件安全课程\\1.实验工具（一）文件格式猜测实验文件夹。双击左键打开1-3.rar解压包，可以看到1-1.doc，1-2-2.gif，1-2.gif。如图所示： 2.2 关闭1-3.rar解压包，使用Uedit32软件打开1-3.rar，可以看到文件格式为Rar，如图所示： 2.3 我们可以再UltraEdit软件中查找到1-3.rar中包含的格式以及1-3.rar里的文件格式。如图所示： 2.4 使用UltraEdit打开1-3.zip文件，操作如1-3.rar一样的步骤。","categories":[],"tags":[{"name":"课程","slug":"课程","permalink":"https://jeffup.github.io/tags/%E8%AF%BE%E7%A8%8B/"},{"name":"工具","slug":"工具","permalink":"https://jeffup.github.io/tags/%E5%B7%A5%E5%85%B7/"}]},{"title":"系统常用命令","slug":"系统常用命令","date":"2019-12-01T08:18:58.000Z","updated":"2019-12-02T07:52:23.134Z","comments":true,"path":"2019/12/01/系统常用命令/","link":"","permalink":"https://jeffup.github.io/2019/12/01/%E7%B3%BB%E7%BB%9F%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/","excerpt":"windowAT 计划在计算机上运行的命令和程序。ATTRIB 显示或更改文件属性。","text":"windowAT 计划在计算机上运行的命令和程序。ATTRIB 显示或更改文件属性。 BREAK 设置或清除扩展式 CTRL+C 检查。CACLS 显示或修改文件的访问控制列表(ACLs)。CALL 从另一个批处理程序调用这一个。CD 显示当前目录的名称或将其更改。 CHCP 显示或设置活动代码页数。CHDIR 显示当前目录的名称或将其更改。CHKDSK 检查磁盘并显示状态报告。CHKNTFS 显示或修改启动时间磁盘检查。CLS 清除屏幕。CMD 打开另一个 Windows 命令解释程序窗口。COLOR 设置默认控制台前景和背景颜色。COMP 比较两个或两套文件的内容。COMPACT 显示或更改 NTFS 分区上文件的压缩。CONVERT 将 FAT 卷转换成 NTFS。您不能转换当前驱动器。COPY 将至少一个文件复制到另一个位置。DATE 显示或设置日期。 DEL 删除至少一个文件。DIR 显示一个目录中的文件和子目录。DISKCOMP 比较两个软盘的内容。DISKCOPY 将一个软盘的内容复制到另一个软盘。DOSKEY 编辑命令行、调用 Windows 命令并创建宏。ECHO 显示消息，或将命令回显打开或关上。ENDLOCAL 结束批文件中环境更改的本地化。ERASE 删除至少一个文件。EXIT 退出 CMD.EXE 程序(命令解释程序)。FC 比较两个或两套文件，并显示不同处。FIND 在文件中搜索文字字符串。FINDSTR 在文件中搜索字符串。FOR 为一套文件中的每个文件运行一个指定的命令。FORMAT 格式化磁盘，以便跟 Windows 使用。FTYPE 显示或修改用于文件扩展名关联的文件类型。GOTO 将 Windows 命令解释程序指向批处理程序中某个标明的行。GRAFTABL 启用 Windows 来以图像模式显示扩展字符集。HELP 提供 Windows 命令的帮助信息。IF 执行批处理程序中的条件性处理。LABEL 创建、更改或删除磁盘的卷标。MD 创建目录。MKDIR 创建目录。MODE 配置系统设备。MORE 一次显示一个结果屏幕。MOVE 将文件从一个目录移到另一个目录。PATH 显示或设置可执行文件的搜索路径。PAUSE 暂停批文件的处理并显示消息。POPD 还原 PUSHD 保存的当前目录的上一个值。PRINT 打印文本文件。PROMPT 更改 Windows 命令提示符。PUSHD 保存当前目录，然后对其进行更改。RD 删除目录。RECOVER 从有问题的磁盘恢复可读信息。REM 记录批文件或 CONFIG.SYS 中的注释。REN 重命名文件。RENAME 重命名文件。REPLACE 替换文件。RMDIR 删除目录。SET 显示、设置或删除 Windows 环境变量。SETLOCAL 开始批文件中环境更改的本地化。SHIFT 更换批文件中可替换参数的位置。SORT 对输入进行分类。START 启动另一个窗口来运行指定的程序或命令。SUBST 将路径跟一个驱动器号关联。TIME 显示或设置系统时间。TITLE 设置 CMD.EXE 会话的窗口标题。TREE 以图形模式显示驱动器或路径的目录结构。TYPE 显示文本文件的内容。VER 显示 Windows 版本。VERIFY 告诉 Windows 是否验证文件是否已正确写入磁盘。VOL 显示磁盘卷标和序列号。XCOPY 复制文件和目录树。appwiz.cpl————添加删除程序control userpasswords2——–用户帐户设置cleanmgr——-垃圾整理CMD————–命令提示符可以当作是 Windows 的一个附件，Ping，Convert 这些不能在图形环境下 使用的功能要借助它来完成。cmd——jview察看Java虚拟机版本。command.com——调用的则是系统内置的 NTVDM，一个 DOS虚拟机。它完全是一个类似 Virtual PC 的 虚拟环境，和系统本身联系不大。 当我们在命令提示符下运行 DOS 程序时，实际上也 是自动转移到 NTVDM虚拟机下，和 CMD 本身没什么关系。calc———–启动计算器chkdsk.exe—–Chkdsk磁盘检查compmgmt.msc—计算机管理conf———–启动 netmeetingcontrol userpasswords2—–User Account 权限设置devmgmt.msc— 设备管理器diskmgmt.msc—磁盘管理实用程序dfrg.msc——-磁盘碎片整理程序drwtsn32—— 系统医生dvdplay——–启动Media Playerdxdiag———–DirectX Diagnostic Toolgpedit.msc——-组策略编辑器gpupdate /target:computer /force 强制刷新组策略eventvwr.exe—–事件查看器explorer——-打开资源管理器logoff———注销命令lusrmgr.msc—-本机用户和组msinfo32———系统信息msconfig———系统配置实用程序net start (servicename)—-启动该服务net stop (servicename)—–停止该服务notepad——–打开记事本nusrmgr.cpl——-同control userpasswords，打开用户帐户控制面板Nslookup——-IP地址侦测器oobe/msoobe /a—-检查XP是否激活perfmon.msc—-计算机性能监测程序progman——–程序管理器regedit———-注册表编辑器regedt32——-注册表编辑器regsvr32 /u *.dll—-停止dll文件运行route print——查看路由表rononce -p —-15秒关机rsop.msc——-组策略结果集rundll32.exe rundll32.exe %Systemroot%System32shimgvw.dll,ImageView_Fullscreen—-启动一个空白的Windows 图片和传真查看器secpol.msc——–本地安全策略services.msc—本地服务设置sfc /scannow—–启动系统文件检查器sndrec32——-录音机taskmgr—–任务管理器（适用于2000／xp／2003）tsshutdn——-60秒倒计时关机命令winchat——–XP自带局域网聊天winmsd———系统信息winver—–显示About Windows 窗口wupdmgr———–Windows Update ‘;update dv_user set usergroupid=1 where username=’san’–","categories":[],"tags":[{"name":"汇总","slug":"汇总","permalink":"https://jeffup.github.io/tags/%E6%B1%87%E6%80%BB/"}]},{"title":"渗透相关资料汇总","slug":"渗透相关资料汇总","date":"2019-12-01T08:04:48.000Z","updated":"2019-12-02T07:51:55.971Z","comments":true,"path":"2019/12/01/渗透相关资料汇总/","link":"","permalink":"https://jeffup.github.io/2019/12/01/%E6%B8%97%E9%80%8F%E7%9B%B8%E5%85%B3%E8%B5%84%E6%96%99%E6%B1%87%E6%80%BB/","excerpt":"渗透相关资料汇总","text":"渗透相关资料汇总 漏洞及渗透练习平台WebGoat漏洞练习环境https://github.com/WebGoat/WebGoathttps://github.com/WebGoat/WebGoat-LegacyDamn Vulnerable Web Application(漏洞练习平台)https://github.com/RandomStorm/DVWA 数据库注入练习平台https://github.com/Audi-1/sqli-labs用node编写的漏洞练习平台，like OWASP Node Goathttps://github.com/cr0hn/vulnerable-node 花式扫描器 端口扫描器Nmaphttps://github.com/nmap/nmap 本地网络扫描器https://github.com/SkyLined/LocalNetworkScanner 子域名扫描器https://github.com/lijiejie/subDomainsBrute 漏洞路由扫描器https://github.com/jh00nbr/Routerhunter-2.0 迷你批量信息泄漏扫描脚本https://github.com/lijiejie/BBScan Waf类型检测工具https://github.com/EnableSecurity/wafw00f 信息搜集工具社工插件，可查找以email、phone、username的注册的所有网站账号信息https://github.com/n0tr00t/SregGithub信息搜集，可实时扫描查询git最新上传有关邮箱账号密码信息https://github.com/sea-god/gitscangithub Repo信息搜集工具https://github.com/metac0rtex/GitHarvester WEB工具 webshell大合集https://github.com/tennc/webshell 渗透以及web攻击脚本https://github.com/brianwrf/hackUtils web渗透小工具大合集https://github.com/rootphantomer/hacktoolsfor_me XSS数据接收平台https://github.com/firesunCN/BlueLotus_XSSReceiver XSS与CSRF工具https://github.com/evilcos/xssor Short for command injection exploiter，web向命令注入检测工具https://github.com/stasinopoulos/commix 数据库注入工具https://github.com/sqlmapproject/sqlmap Web代理，通过加载sqlmap api进行sqli实时检测https://github.com/zt2/sqli-hunter 新版中国菜刀https://github.com/Chora10/Cknife .git泄露利用EXPhttps://github.com/lijiejie/GitHack 浏览器攻击框架https://github.com/beefproject/beef 自动化绕过WAF脚本https://github.com/khalilbijjou/WAFNinja http命令行客户端，可以从命令行构造发送各种http请求（类似于Curl）https://github.com/jkbrzt/httpie 浏览器调试利器https://github.com/firebug/firebug 一款开源WAFhttps://github.com/SpiderLabs/ModSecurity windows域渗透工具 windows渗透神器https://github.com/gentilkiwi/mimikatz Powershell渗透库合集https://github.com/PowerShellMafia/PowerSploit Powershell tools合集https://github.com/clymb3r/PowerShell Fuzz Web向Fuzz工具https://github.com/xmendez/wfuzz HTTP暴力破解，撞库攻击脚本https://github.com/lijiejie/htpwdScan 漏洞利用及攻击框架 msfhttps://github.com/rapid7/metasploit-framework Poc调用框架，可加载Pocsuite,Tangscan，Beebeeto等https://github.com/erevus-cn/pocscan Pocsuitehttps://github.com/knownsec/Pocsuite Beebeetohttps://github.com/n0tr00t/Beebeeto-framework 漏洞POC&amp;EXP ExploitDB官方git版本https://github.com/offensive-security/exploit-database php漏洞代码分析https://github.com/80vul/phpcodz Simple test for CVE-2016-2107https://github.com/FiloSottile/CVE-2016-2107 CVE-2015-7547 POChttps://github.com/fjserna/CVE-2015-7547 JAVA反序列化POC生成工具https://github.com/frohoff/ysoserial JAVA反序列化EXPhttps://github.com/foxglovesec/JavaUnserializeExploits Jenkins CommonCollections EXPhttps://github.com/CaledoniaProject/jenkins-cli-exploit CVE-2015-2426 EXP (windows内核提权)https://github.com/vlad902/hacking-team-windows-kernel-lpe use docker to show web attack(php本地文件包含结合phpinfo getshell 以及ssrf结合curl的利用演示)https://github.com/hxer/vulnapp php7缓存覆写漏洞Demo及相关工具https://github.com/GoSecure/php7-opcache-override XcodeGhost木马样本https://github.com/XcodeGhostSource/XcodeGhost 中间人攻击及钓鱼中间人攻击框架https://github.com/secretsquirrel/the-backdoor-factoryhttps://github.com/secretsquirrel/BDFProxyhttps://github.com/byt3bl33d3r/MITMfInject code, jam wifi, and spy on wifi usershttps://github.com/DanMcInerney/LANs.py可扩展的中间人代理工具https://github.com/intrepidusgroup/mallorywifi钓鱼https://github.com/sophron/wifiphisher 密码破解密码破解工具https://github.com/shinnok/johnny本地存储的各类密码提取利器https://github.com/AlessandroZ/LaZagne 二进制及代码分析工具二进制分析工具https://github.com/devttys0/binwalk系统扫描器，用于寻找程序和库然后收集他们的依赖关系，链接等信息https://github.com/quarkslab/binmaprp++ is a full-cpp written tool that aims to find ROP sequences in PE/Elf/Mach-O (doesn’t support the FAT binaries) x86/x64 binaries.https://github.com/0vercl0k/rpWindows Exploit Development工具https://github.com/lillypad/badger二进制静态分析工具（python）https://github.com/bdcht/amocoPython Exploit Development Assistance for GDBhttps://github.com/longld/peda对BillGates Linux Botnet系木马活动的监控工具https://github.com/ValdikSS/billgates-botnet-tracker木马配置参数提取工具https://github.com/kevthehermit/RATDecodersShellphish编写的二进制分析工具（CTF向）https://github.com/angr/angr针对python的静态代码分析工具https://github.com/yinwang0/pysonar2一个自动化的脚本（shell）分析工具，用来给出警告和建议https://github.com/koalaman/shellcheck基于AST变换的简易Javascript反混淆辅助工具https://github.com/ChiChou/etacsufbo EXP编写框架及工具二进制EXP编写工具https://github.com/t00sh/rop-toolCTF Pwn 类题目脚本编写框架https://github.com/Gallopsled/pwntoolsan easy-to-use io library for pwning developmenthttps://github.com/zTrix/zio跨平台注入工具（ Inject JavaScript to explore native apps on Windows, Mac, Linux, iOS and Android.）https://github.com/frida/frida 隐写相关工具隐写检测工具https://github.com/abeluck/stegdetect 各类安全资料域渗透教程https://github.com/l3m0n/pentest_studypython security教程（原文链接http://www.primalsecurity.net/tutorials/python-tutorials/）https://github.com/smartFlash/pySecuritydata_hacking合集https://github.com/ClickSecurity/data_hackingmobile-security-wikihttps://github.com/exploitprotocol/mobile-security-wiki书籍《reverse-engineering-for-beginners》https://github.com/veficos/reverse-engineering-for-beginners一些信息安全标准及设备配置https://github.com/luyg24/IT_securityAPT相关笔记https://github.com/kbandla/APTnotesKcon资料https://github.com/knownsec/KConctf及黑客资源合集https://github.com/bt3gl/My-Gray-Hacker-Resourcesctf和安全工具大合集https://github.com/zardus/ctf-tools《DO NOT FUCK WITH A HACKER》https://github.com/citypw/DNFWAH 各类CTF资源近年ctf writeup大全https://github.com/ctfs/write-ups-2016https://github.com/ctfs/write-ups-2015https://github.com/ctfs/write-ups-2014fbctf竞赛平台Demohttps://github.com/facebook/fbctfctf Resourceshttps://github.com/ctfs/resources 各类编程资源大礼包（什么都有）https://github.com/bayandin/awesome-awesomenessbash-handbookhttps://github.com/denysdovhan/bash-handbook python资源大全https://github.com/jobbole/awesome-python-cngit学习资料https://github.com/xirong/my-git安卓开源代码解析https://github.com/android-cn/android-open-project-analysispython框架，库，资源大合集https://github.com/vinta/awesome-pythonJS 正则表达式库（用于简化构造复杂的JS正则表达式）https://github.com/VerbalExpressions/JSVerbalExpressionsPythonpython 正则表达式库（用于简化构造复杂的python正则表达式）https://github.com/VerbalExpressions/PythonVerbalExpressionspython任务管理以及命令执行库https://github.com/pyinvoke/invokepython exe打包库https://github.com/pyinstaller/pyinstallerpy3 爬虫框架https://github.com/orf/cyborg一个提供底层接口数据包编程和网络协议支持的python库https://github.com/CoreSecurity/impacketpython requests 库https://github.com/kennethreitz/requestspython 实用工具合集https://github.com/mahmoud/boltonspython爬虫系统https://github.com/binux/pyspiderctf向 python工具包https://github.com/P1kachu/v0lt 科学上网科学上网工具https://github.com/XX-net/XX-Net老司机福利微信自动抢红包动态库https://github.com/east520/AutoGetRedEnv微信抢红包插件（安卓版）https://github.com/geeeeeeeeek/WeChatLuckyMoney神器https://github.com/yangyangwithgnu/hardseed 其他以下内容来自：https://github.com/We5ter/Scanners-Box/blob/master/README_CN.md 子域名枚举类https://github.com/lijiejie/subDomainsBrute (经典的子域名爆破枚举脚本)https://github.com/ring04h/wydomain (子域名字典穷举)https://github.com/le4f/dnsmaper (子域名枚举与地图标记)https://github.com/0xbug/orangescan (在线子域名信息收集工具)https://github.com/TheRook/subbrute （根据DNS记录查询子域名)https://github.com/We5ter/GoogleSSLdomainFinder (基于谷歌SSL透明证书的子域名查询脚本)https://github.com/mandatoryprogrammer/cloudflare_enum （使用CloudFlare进行子域名枚举的脚本）https://github.com/18F/domain-scan (A domain scanner）https://github.com/Evi1CLAY/Cool … Python/DomainSeeker（多方式收集目标子域名信息）数据库漏洞扫描类https://github.com/0xbug/SQLiScanner (一款基于SQLMAP和Charles的被动SQL注入漏洞扫描工具)https://github.com/stamparm/DSSS (99行代码实现的sql注入漏洞扫描器)https://github.com/LoRexxar/Feigong（针对各种情况自由变化的MySQL注入脚本）https://github.com/youngyangyang04/NoSQLAttack (一款针对mongoDB的攻击工具)https://github.com/Neohapsis/bbqsql（SQL盲注利用框架）https://github.com/NetSPI/PowerUpSQL（攻击SQLSERVER的Powershell脚本框架）弱口令或信息泄漏扫描类https://github.com/lijiejie/htpwdScan (一个简单的HTTP暴力破解、撞库攻击脚本)https://github.com/lijiejie/BBScan (一个迷你的信息泄漏批量扫描脚本)https://github.com/lijiejie/GitHack (.git文件夹泄漏利用工具)https://github.com/wilson9x1/fenghuangscanner_v3 (端口及弱口令检测)https://github.com/ysrc/F-Scrack (对各类服务进行弱口令检测的脚本)https://github.com/Mebus/cupp （根据用户习惯生成弱口令探测字典脚本）https://github.com/RicterZ/genpAss （中国特色的弱口令生成器）https://github.com/netxfly/crack_ssh （go写的协程版的ssh\\redis\\mongodb弱口令破解工具）物联网设备扫描https://github.com/rapid7/IoTSeeker （物联网设备默认密码扫描检测工具)https://github.com/shodan-labs/iotdb (使用nmap扫描IoT设备)xss扫描器https://github.com/shawarkhanethicalhacker/BruteXSS （Cross-Site Scripting Bruteforcer）https://github.com/1N3/XSSTracer (A small python script to check for Cross-Site Tracing)https://github.com/0x584A/fuzzXssPHP (PHP版本的反射型xss扫描)https://github.com/chuhades/xss_scan (批量扫描xss的python脚本）企业网络自检https://github.com/sowish/LNScan （详细的内部网络信息扫描器）https://github.com/ysrc/xunfeng (网络资产识别引擎，漏洞检测引擎）https://github.com/SkyLined/LocalNetworkScanner (javascript实现的本地网络扫描器)https://github.com/laramies/theHarvester （企业被搜索引擎收录敏感资产信息监控脚本：员工邮箱、子域名、Hosts）https://github.com/x0day/Multisearch-v2 (bing、google、360、zoomeye等搜索引擎聚合搜索，可用于发现企业被搜索引擎收录的敏感资产信息）webshell检测https://github.com/We5ter/Scanners-Box/tree/master/Find_webshell/ （php后门检测，脚本较简单，因此存在误报高和效率低下的问题）https://github.com/yassineaddi/BackdoorMan （A toolkit find malicious, hidden and suspicious PHP scripts and shells in a chosen destination）内网渗透https://github.com/0xwindows/VulScritp （企业内网渗透脚本，包括banner扫描、端口扫描；phpmyadmin、jenkins等通用漏洞利用等）https://github.com/lcatro/networkbackdoorscanner（基于网络流量的内网探测框架）https://github.com/fdiskyou/hunter（调用 Windows API 枚举用户登录信息）中间件扫描、指纹识别类https://github.com/ring04h/wyportmap (目标端口扫描+系统服务指纹识别)https://github.com/ring04h/weakfilescan (动态多线程敏感信息泄露检测工具)https://github.com/EnableSecurity/wafw00f (WAF产品指纹识别)https://github.com/rbsec/sslscan （ssl类型识别)https://github.com/urbanadventurer/whatweb (web指纹识别)https://github.com/tanjiti/FingerPrint (web应用指纹识别)https://github.com/nanshihui/Scan-T （网络爬虫式指纹识别)https://github.com/OffensivePython/Nscan (a fast Network scanner inspired by Masscan and Zmap)https://github.com/ywolf/F-NAScan (网络资产信息扫描, ICMP存活探测,端口扫描，端口指纹服务识别）https://github.com/ywolf/F-MiddlewareScan （中间件扫描）https://github.com/maurosoria/dirsearch (Web path scanner)https://github.com/x0day/bannerscan （C段Banner与路径扫描）https://github.com/RASSec/RASscan (端口服务扫描)https://github.com/3xp10it/bypass_waf （waf自动暴破）https://github.com/3xp10it/mytools/blob/master/xcdn.py（获取cdn背后的真实ip）https://github.com/Xyntax/BingC（基于Bing搜索引擎的C段/旁站查询，多线程，支持API）https://github.com/Xyntax/DirBrute（多线程WEB目录爆破工具）https://github.com/zer0h/httpscan（一个爬虫式的网段Web主机发现小工具）https://github.com/lietdai/doom（thorn上实现的分布式任务分发的ip端口漏洞扫描器）专用扫描器https://github.com/blackye/Jenkins (Jenkins漏洞探测、用户抓取爆破)https://github.com/code-scan/dzscan (discuz扫描)https://github.com/chuhades/CMS-Exploit-Framework (CMS攻击框架)https://github.com/lijiejie/IISshortnameScanner (an IIS shortname Scanner)https://github.com/We5ter/Scanne … ter/FlashScanner.pl (flashxss扫描)https://github.com/coffeehb/SSTIF（一个Fuzzing服务器端模板注入漏洞的半自动化工具）无线网络https://github.com/savio-code/fern-wifi-cracker/ (无线安全审计工具)https://github.com/m4n3dw0lf/PytheM（Python网络/渗透测试工具）https://github.com/P0cL4bs/WiFi-Pumpkin（无线安全渗透测试套件）综合类https://github.com/az0ne/AZScanner (自动漏洞扫描器，子域名爆破，端口扫描，目录爆破，常用框架漏洞检测)https://github.com/blackye/lalascan (自主开发的分布式web漏洞扫描框架，集合owasp top10漏洞扫描和边界资产发现能力)https://github.com/blackye/BkScanner (BkScanner 分布式、插件化web漏洞扫描器)https://github.com/ysrc/GourdScanV2 （被动式漏洞扫描)https://github.com/alpha1e0/pentestdb (WEB渗透测试数据库)https://github.com/netxfly/passive_scan (基于http代理的web漏洞扫描器)https://github.com/1N3/Sn1per (自动化扫描器，包括中间件扫描以及设备指纹识别)https://github.com/RASSec/pentestEr_Fully-automatic-scanner （定向全自动化渗透测试工具）https://github.com/3xp10it/3xp10it （3xp10it自动化渗透测试框架）https://github.com/Lcys/lcyscan（python插件化漏洞扫描器）https://github.com/Xyntax/POC-T（渗透测试插件化并发框架） CTF平台http://www.shiyanbar.com/http://oj.xctf.org.cn/http://ctf.bugku.com/http://rookiehacker.org/ 作者：初识微夏链接：https://www.zhihu.com/question/23190460/answer/398906959来源：知乎著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。","categories":[],"tags":[{"name":"汇总","slug":"汇总","permalink":"https://jeffup.github.io/tags/%E6%B1%87%E6%80%BB/"}]},{"title":"Linux添加系统调用","slug":"Linux添加系统调用","date":"2019-12-01T07:59:42.000Z","updated":"2019-12-01T10:35:51.354Z","comments":true,"path":"2019/12/01/Linux添加系统调用/","link":"","permalink":"https://jeffup.github.io/2019/12/01/Linux%E6%B7%BB%E5%8A%A0%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8/","excerpt":"重新编译Linux内核 增加一个Linux的系统调用。 写一个程序进行调用。","text":"重新编译Linux内核 增加一个Linux的系统调用。 写一个程序进行调用。 一、实验目的 重新编译Linux内核。 增加一个Linux的系统调用。 写一个程序进行调用。 二、实验环境 电脑型号 华硕 X542UQR 操作系统 Microsoft Windows 10 专业版 (64位) CPU (英特尔)Intel(R) Core(TM) i7-8550U CPU @ 1.80GHz(1992 MHz) 主板 华硕 X542UQR 内存 8.00 GB ( 2400 MHz) 主硬盘 1000 GB (东芝 67TAW48 已使用时间: 1875小时) 实验软件 VMware® Workstation 14 Pro 实验系统 Centos 7 实验内核版本 Linux 4.20.1 三、实验内容与步骤3.1 准备阶段——构造环境 安装Developement Tools： [root@localhost ~]# yum groupinstall ‘Developement Tools’ 安装ncurses： [root@localhost ~]# yum install -y ncurses 安装elfutils-libelf-devel： [root@localhost ~]# yum install ncurses-devel bison flex elfutils-libelf-devel openssl-devel 3.2 实验阶段 下载新内核：到官网：www.kenerl.org 中下载内核版本Linux-4.20.1。 解压内核压缩包： [root@localhost 下载]# tar -xvJf linux-4.20.1 -C /usr/src/kenerls 进入内核4.20.1中： [root@localhost jhuang]# cd /usr/src/kernels/linux-4.20.1 添加声明： [root@localhost linux-4.20.1]# gedit include/linux/syscalls.h 添加系统函数： [root@localhost linux-4.20.1]# gedit kernel/sys.c 添加系统调用 [root@localhost linux-4.20.1]# gedit arch/x86/entry/syscalls/syscall_64.tbl 编译内核 [root@localhost linux-4.20.1]# make oldconfig[root@localhost linux-4.20.1]# make menuconfig 直接选择默认设置 [root@localhost linux-4.20.1]# make -j 4[root@localhost linux-4.20.1]# make modules_install[root@localhost linux-4.20.1]# make install[root@localhost linux-4.20.1]# reboot 选择第一个内核版本进行编译 编程 [root@localhost ~]# cd /home/jhuang/桌面/note/[root@localhost note]# touch myc.c[root@localhost note]# gedit myc.c 进入页面： 编译程序： [root@localhost note]# gcc -c myc.c[root@localhost note]# gcc -o myc myc.o[root@localhost note]# ./myc 四、实验结果分析 五、几个问题1. 为什么你要添加三个调用并使用不同的调用方式，如64、common、x32？ 答：为了保证我能成功调用我添加的系统函数，我觉得写多个方式的函数比较保险，并且用不同的输出信息予以区分，这样会让我更加深入了解系统调用的原理。 2. 刚刚安装的内核是缺少很多必要的环境组件的，这会导致内核编译不成功，你是怎么解决的？ 答：我先是升级了所有现有的软件，然后再在接下来的编译过程中，遇到缺少什么套件，就安装什么套件。 3. 我看到你编译了多次不同的内核，是因为遇到什么问题吗？ 答：第一次我安装了版本为3.2.75的内核，由于它不是在官网下的，所以可能存在被人修改过的嫌疑，虽然内核编译成功了，但是不能成功进入我所期待的页面，所以放弃了，重新找了个内核版本为3.10.89的内核，这也不是在kernel.org上下的，所以同样遇到问题，这个问题是：开机时虚拟机显示被客户机操作系统禁用了cpu，由于在网上搜不到较好的解决方案，所以去官网下载了如今的4.20.1版本的内核，最后编译成功。","categories":[],"tags":[{"name":"操作系统","slug":"操作系统","permalink":"https://jeffup.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"},{"name":"课程","slug":"课程","permalink":"https://jeffup.github.io/tags/%E8%AF%BE%E7%A8%8B/"}]},{"title":"DNSTunnel技术攻防","slug":"DNSTunnel技术攻防","date":"2019-12-01T03:16:30.000Z","updated":"2019-12-01T03:42:16.750Z","comments":true,"path":"2019/12/01/DNSTunnel技术攻防/","link":"","permalink":"https://jeffup.github.io/2019/12/01/DNSTunnel%E6%8A%80%E6%9C%AF%E6%94%BB%E9%98%B2/","excerpt":"1. DNS概述DNS在我们的网络世界中是一个非常重要的协议，它将长串的不适合记忆的IP地址映射成可读性较强的字符域名。整个域名空间呈层次化的树状结构，顶层是根域，全球一共有13个根域。根域下为我们平常熟悉的顶级域，如.com,.net,.org等。域名的存储、解析和管理都要通过域名服务器来实现。根据域名所属域和授权范围可以划分Zone，Zone上的主服务器和辅服务器均被称为权威域名服务器。权威域名服务器上保存了该域的所有主机信息。","text":"1. DNS概述DNS在我们的网络世界中是一个非常重要的协议，它将长串的不适合记忆的IP地址映射成可读性较强的字符域名。整个域名空间呈层次化的树状结构，顶层是根域，全球一共有13个根域。根域下为我们平常熟悉的顶级域，如.com,.net,.org等。域名的存储、解析和管理都要通过域名服务器来实现。根据域名所属域和授权范围可以划分Zone，Zone上的主服务器和辅服务器均被称为权威域名服务器。权威域名服务器上保存了该域的所有主机信息。 DNS的记录类型有很多，大家常见的有A，AAAA,CNAME,MX,SOA,NS等。DNS的解析过程可以分为两种类型：迭代查询和递归查询。通常本机到Local DNS Server的过程属于递归查询，而Local DNS Server对查询域名的解析过程属于迭代查询。为了减轻Local DNS Server的压力，提高解析速度，引入了缓存机制。缓存和TTL紧密相连，当TTL过期，Local DNS Server则会丢弃缓存的数据，重新从权威域名服务器上获取新的数据。 2. 隧道技术为了逃避监测，绕过杀软，更好的隐藏自身，很多木马的传输层都使用了隧道技术，隧道技术是一种通过使用互联网络的基础设施在网络之间传递数据的方式，使用隧道传递的Data(数据)或Payload(负载）可以是不同协议的数据帧或包。 隧道协议将其它协议的数据帧或包，重新封装然后通过隧道发送，新的帧头提供路由信息，以便通过互联网传递被封装的 Payload。其数据传输特点（Feature）就是不通过网络直接发送数据包，通过封装技术在另一个(通常是加密的)连接中发送数据。 常见基于数据包隧道有IPsec、L2TP、PPTP、PPPoE、SSH、TLS、SOCKS等等，其主要作用是规避防火墙。 一个被防火墙阻挡的协议可被包在另一个没被防火墙阻挡的协议里，如HTTP。如果防火墙并没有排除此种包装，这技巧可用来逃避防火墙政策。隧道可按要求创建起一条与其他服务器的通信线路，届时使用SSL等加密手段进行通信。 3. DNS隧道介绍DNS隧道技术就是指利用DNS协议建立隐蔽信道，实现隐蔽数据传输。 传统socket隧道已极少，TCP、UDP大量被防御系统拦截，DNS、ICMP、HTTP/HTTPS等难于禁止的协议已成为黑客控制隧道的主流。比如在安全策略严格的内网环境中，常见的C&amp;C通讯端口都被众多安全设备所监控。在对目标内网的终端进行渗透时，网段只允许白名单流量出站，同时其它端口都被屏蔽时，传统C&amp;C通讯手段无法建立，反弹Shell变得十分困难。 在这种情况下，DNS隧道往往可以成功，一方面是因为 DNS 报文具有天然的穿透防火墙的能力;另一方面,目前的杀毒软件、IDS 等安全策略很少对 DNS 报文进行有效的监控管理。 最早是在2004年DanKaminsky在Defcon大会上发布的基于NSTX的DNS隐蔽隧道工具，之后出现了越来越多的DNS隐蔽通道工具 iodine: https://github.com/yarrick/iodine Dns2tcp: https://www.aldeid.com/wiki/Dns2tcp tcp-over-dns: http://analogbit.com/software/tcp-over-dns/ Heyoka: http://heyoka.sourceforge.net/ Dnscat: https://wiki.skullsecurity.org/Dnscat OzymanDNS https://dnstunnel.de/ DNSScapy https://code.google.com/archive/p/dnscapy/ DnsShell https://github.com/sensepost/DNS-Shell ReverseDnsShell https://github.com/ahhh/Reverse_DNS_Shell … 4. DNS隧道分类4.1 IP直连型如果DNS隧道的服务器可以与本地主机通过IP直接通信，传输协议采用DNS协议，则称为IP直连型。 IP直连型DNS隧道木马的服务器端开放53端口，被控端利用UDP Socket套接字直接与C&amp;C服务建立连接。在这种情况下，两者传输的内容实际上是基于UDP服务。这种木马与传统UDP木马的几点不同 利用53端口进行传输交互数据，而53端口的外联基本上在所有机器上都必须开放，否则则无法使用互联网DNS服务； 精心构造传输的载荷内容，使其至少从格式上是符合DNS query包格式，因为如果攻击者构造的UDP载荷内容不符合DNS报文格式，在Wireshark等流量分析工具的流量解析下，很容易出现DNS报文异常的情况。 4.2 域名解析型域名解析型也可以叫做DNS迭代查询中继型，基本通信架构如下图所示 被控端把要传输的内容封装在DNS请求包中，发起一次正常的DNS解析请求； 当被控端向任意一台DNS服务器请求该域名下的子域名时，本地DNS服务器无论是通过递归查询还是迭代查询，都会向外转发这个DNS请求，最终这个DNS请求都会被送到黑客控制的权威NS服务器中（这意味着黑客必须事先配置好NS以及A记录解析）； DNS服务器控制端解析请求报文，得到被控端传来的信息，然后将攻击控制命令通过封装在DNS响应报文中； 从而实现双方通信，所有的通信都必须由被控端（Client端）主动发起，不断回传数据并接受新指令。 中继过程中的一个关键点是对DNS缓存机制的规避，因为如果需要解析的域名在Local DNS Server中已经有缓存时，Local DNS Server就不会转发数据包。所以在我们构造的请求中，每次查询的域名都是不一样的或者是已经是过期的。 这个特征同时也包含了一个可用于检测的规律，即在DNS Tunnel的会话中，Dns Query Host的数量会比正常情况下要多，对DNS载荷的编码是DNS Tunnel的另一个核心技术，从高层来看，载荷只是客户端和服务器通信的正常流量。 例如客户端发送一个A记录请求给服务器，查询的主机名为2roAUwBaCGRuc3R1bm5lbGluZwo.test.domain.com,其中2roAUwBaCGRuc3R1bm5lbGluZwo则是客户端传递给服务器的信息，这串字符解码后的信息便是dnstunneling。 在大多数场景下，内网的Client位于防火墙后，Server不可能发起连接。所以大多数工具，Client会定时向Server发送请求，保证二者之间的通信状态。 4.3 IP直连型和域名解析型异同点这2种方法虽然工作原理上存在差别，但是从流量角度上来看都是基于DNS协议，但是这里在实际工程中也要注意，你旁路采集的方式可能会影响到你最终能否采集到完整的通信日志，例如如果你是采用记录DNS解析的方法，则可能会漏过UDP IP直连的这种通信方式，如果直接在网关上进行“端口和协议解析”则可以保证全流量采集。 IP直连型DNS隧道木马直接与DNS服务器通过UDP Socket通信，因此通信效率要比域名型DNS隧道木马高，但是这种DNS隧道木马致命的弱点是直接把IP暴露在网络流量中，如果客户端指定信任的DNS服务器解析DNS服务，那么IP直连型DNS隧道木马就很容易被IP黑白名单封杀； 对于域名型DNS隧道木马而言，只要客户机能与任意一台外网的DNS服务器通信，那么域名型DNS隧道木马就可以工作，因此域名型 DNS隧道木马生存能力更强，隐蔽性更高，更适合进行隐蔽的控制渗透任务。 5. DNS隧道案例DNS隧道有诸多优点，也被各种黑客组织所用，经过各种变形、加密，制作各种后门和木马程序，复杂程度越来越高。 5.1 XshellGhost2017年8月NetSarang旗下多款软件的关键模块被植入了高级后门，这是一起入侵感染供应链软件的大规模攻击事件，被称为为“XshellGhost”。 后门会将主机的用户信息通过特定DGA(域名生成算法)产生的DNS域名传送至黑客的远程命令控制服务器，同时黑客的服务器会动态下发任意的恶意代码至用户机器执行，其中具有TCP、HTTP、UDP、DNS、HTTPS、SSL网络协议进行远程控制能力，其中DNS通信模块因主动运行被发现。 在发送数据包时，会将数据嵌套到 DNS 协议中发送，其中数据会编码成特定的字符串，添加在要配置文件中的 CCDNS URL前，实现DNS隧道通讯。 也是因为该事件的爆发，DNS隧道的防御逐渐被重视，各大公司纷纷启动对DNS隧道的监控。 5.2 ALMA CommunicatorALMA Communicator在2017年12月被发现来自OilRig黑客组织，它使用了DNS隧道来作为C2通信信道，使用了专门的子域名来给C2服务器传输数据，服务器使用了专门的IPv4地址来给木马发送数据。 在构建这种专门的子域名时，木马会生成一个随机的四位数字，并连接一个硬编码字符串，最后再在字符串末尾添加一个用于标识受感染系统的唯一标识符。最后，它会添加硬编码的-0-2D-2D字符串来结束子域名（用于C2服务器通信）的构造，下图显示的是域名的结构该木马在向C2服务器发送数据时所使用的DNS查询语句的结构，其中每一次DNS请求一次只能发送10个字节的数据，下图是DNS查询时的结构目前OilRig黑客组织仍在他们的攻击活动中使用这种技术，并不断变种更新 5.3 Trojan.Win32.Ismdoor.gen该木马在2017年被发现，是一个有多层的C2通信协议结构，使用DNS隧道传输，并将传出“datagrams”（数据报）的长度被限制在60字符，C2服务器的命令解析到IPv6地址，一个典型的查询发送到C2服务器如下:n.n.c...com 在DNS隧道传输层上面适当的位置有一个会话层协议,这意味着交换“短”和“长”数据包的能力。会话层与传输层的不同之处在于,它有一种机制来检查丢失的消息。当传输层通过一种数据交换关闭会话时（该数据交换是关于发送和接收数据包的数量），会话层便检查确保每一个发送的数据包已经被正确接收进而关闭。由服务器决定使用哪个选项；例如,“长”数据包协议是用来从受感染的电脑上传文件。 短消息在这个层次上,机器人的操作可分为五个步骤: 向服务器声明会话ID; 在数据包中发送消息; 发送已发送数据包数量; 接收传入数据包的数量; 接收传入的数据包。 长消息在这种情况下,与服务器通信可以分为以下步骤: 发送文件分成的数据包的数量; 发送文件; 向服务器发送周期查询以检查丢失的数据包; 重新发送丢失的数据包。 5.4 PlugX该后门木马结合DNS隧道传输技术和PlugX远控程序，通过建立的DNS隧道进行攻击控制，和XshellGhost相似，将用户信息编码到子域名部分发起TXT类型的DNS查询进行受控端上线。但不同的是它将编码后的全域名发送到公共DNS服务器来建立通信隧道，并且也是通过查询TXT来返回数据。 程序就对接收到的TXT回包进行校验和解码，除了正常编码的TXT数据外，还添加一条长度为0的空Text作为结尾才可以通过程序检查到达下一步控制流程 5.5 DarkHydrus APT组织2019年1月被发现针对中东地区的定向攻击活动，后门程序利用了复杂的DNS隧道技术与C2进行通信并执行指令，且通过GoogleDrive API实现文件的上传下载。 后门使用了第二类也就是域名型隧道，而且会根据不同的查询类型，使用不同的正则表达式去匹配DNS服务器返回的结果数据。 木马先会通过向攻击者控制的DNS服务器发送DNS查询请求来发送当前木马的上线ID给攻击者接着根据当前DNS请求的类型分别用不同的正则表达式规则匹配其返回的数据结果，并取取其中的数据比如执行nslookup并使用查询类型为A进行查询，最终使用以下正则表达式匹配返回的数据结果使用查询类型AC得到返回的数据，并使用以下正则表达式匹配返回的数据结果使用查询类型为AAAA得到的数据使用以下正则表达式匹配返回的数据结果使用其他DNS查询类型得到的数据使用以下正则表达式匹配返回的数据结果该木马共使用了A、AAAA、AC、CNAME、TXT、SRV、SOA、MX等DNS查询类型 6. 防御检测目前安全产品多是基于监控终端请求异常长度的域名等规则方式进行DNS隧道检测，但可以通过修改域名长度、请求频率等特征轻易绕过传统基于规则的DNS隧道的检测模型，相比于基于规则的静态阈值检测误报高，易被绕过等问题，还可以使用机器学习技术从历史数据中学习出一个DNS隧道模式用于检测。 主要可以从以下几个方面对DNS隧道进行检测。 6.1 DNS Query Type成分组成异常检测 DNS Tunnel很多DNS Tunneling使用TXT记录类型发送请求和响应（例如文件上传等大数据量功能），而在正常的DNS网络流量中，TXT记录的比例可能只有1%-2%，如果时间窗口内，TXT记录的比例激增，那么也意味着可能存在异常。 DNS FF Botnet另外，在FF Botnet中，NXDOMAIN的比例也会比正常情况下要高。 DNS Query Types Numbers僵尸网络的DNS查询主要是查找C2的IP地址，查询类型的数量是有限的，四种主要的查询类型是A，AAAA，MX和NS。但是，良性名称查询的类型多于那些，其可能还包括ANY，TXT，SRV，SOA，CNAME，A6等。那么可以统计一个会话中的DNS Type数量，判断异常 6.2 基于Zipf定律的异常检测根据Zipf定律，在自然语言的语料库里，词频往往会集中于某些小子集中，并且高频词到低频次的频率逐渐下降。 DNS Tunneling中由于域名做了编码，不符合Zipf定律（例如dns2tcp），整个分布趋于平稳。我们可以通过检测排序后的词频平均斜率来检测是否符合Zipf定律。 6.3 DNS会话时长检测TCP会话在建立通信过程中存在“三次握手”和断开连接的“四次握手”行为，因此TCP会话可以计算会话时长。 DNS会话属于UDP会话的其中一种，由于UDP无连接的特性，DNS没有会话时长的严格定义。定义在一次DNS会话中，最后一个DNS报文的时间和第一个DNS报文的时间差就作为这个DNS会话的时长。 正常情况下，一次DNS解析过程首先由客户机在本地随机开启一个UDP端口，然后向指定的DNS服务器53端口发送DNS请求报文，两者由此建立一个UDP通道。客户机一旦得到相应DNS回复报文，这个 DNS解析过程就结束了，如果没有后继的DNS解析任务，创建的UDP套接字会保存一段时间然后关闭，完成一次DNS会话，再次进行DNS解析的时候，再随机开启另一个UDP端口，重复上述过程。因此，正常域名解析DNS会话的时间短； 对于DNS隧道木马而言，创建的UDP套接字通常会等到木马下线或者木马生命结束才关闭，UDP套接字会被复用，导致DNS隧道木马的DNS会话时长远大于正常DNS会话时长。 6.4 DNS会话中数据包总数因为DNS隧道木马的会话一般随着木马生命周期的结束而结束，在整个木马的生命周期里会向外发送心跳报文、传输本机敏感信息、资源文件等，控制端会下达相关的远程控制指令等。所以在DNS隧道木马会话中DNS报文数量大。然而，正常客户端产生的DNS会话随着一次DNS解析任务结束而结束，DNS会话比较简短。大多数情况是2个，由1个DNS请求报文和1个DNS响应报文组成。 6.3 “上行大包”请求比例在DNS请求报文中，如果Queries字段大于50字节，那么定义该DNS请求报文为上行大包。 DNS隧道木马被控端把要传输的内容封装在Queries字段的域名中，DNS隧道木马为了在一次传输过程中携带尽可能多的隐蔽信息，往往造成Queries字段中的域名长度偏长。与正常DNS会话相比，DNS隧道木马会话中“上行大包”占请求报文总数的比例较大。 另一方面，如果攻击者为规避检测，强制拆分构造相对短小的域名，从而减少每次发送的报文携带的隐蔽通信内容。当被控端传送某一固定的敏感资源文件，由于传送的资源文件大小是固定的,如果牺牲一次携带的隐蔽信息的内容，势必造成整个DNS会话的DNS报文总数的增加，所以在一次DNS隧道木马的会话中，DNS报文总数和DNS报文长度是负相关的。 6.4 “下行小包”响应比例将DNS应答报文中Answers字段小于50字节的数据包称为“下行小包”。 DNS隧道木马在交互过程中，控制端发送的控制命令一般有特定含义，且短小精简，因此DNS隧道回复报文一般是“下行小包”。 对于正常本机DNS解析请求而言，客户机是资源请求者，DNS服务器返回的数据除了Answers字段外，还经常返回授权和额外信息字段信息，因此正常的DNS响应报文相对较大。 6.5. 域名对应的主机名数量对于DNS隧道木马而言，控制端要不断借助DNS Query的Query_name来承载要传输的内容，所以从主机数量这个维度来看，在一个DNS Tunnel会话中，域名对应的主机名数量会明显大于正常的DNS通信。 6.6. FQDN数异常检测域名有全称和简称的区别。全称的域名，直译为”完全的合格的域名”(FQDN，Fully Qualified Domain Name)，表现为由”.”隔开的点分式层次结构，叫名称空间，它指定了一台主机和它所属域的隶属关系，而简称通常就是这台主机的计算机名，在域名的最左边。 可以这么说FQDN(完全合格的域名)，是域加计算机名的总称。比如: www.microsoft.com 这个FQDN中，www是主机名，microsoft.com是域。 www+microsoft.com 组合在一块就成了一个完整的域名(FQDN)。 可以通过分析一定时间窗口内所产生的FQDN数，通常DNS Tunneling的FQDN数在一定时间窗口内会远高于正常的DNS流量。 6.7 响应时间特征正常的DNS Server会在较短时间内完成DNS响应，而DNS Tunnel由于需要进行数据的解码以及后续处理逻辑，响应时间会稍微较长。 6.8 发包频率行为DNS Tunnel中DNS请求数量会很大，可以作为检测依据，但在实际的环境中，存在一些DNS Flood攻击行为，这部分攻击触发的行为日志很容易命中到DNS Tunnel模型，对于这种情况，需要将所有DNS会话包之前的间隔统计出来，计算它们的均值/方差等特征 7. 总结DNS隧道技术由于隐蔽性高，穿透性强，备受黑客组织青睐，逐渐发展出复杂的通信技术手段。又由于防御手段有限，传统规则检测技术高误报，易绕过，数据科学和机器学习技术逐渐被使用，同时也出现了对抗数据分析和机器学习的更高级设计，但总能在统计分析上找到一些特定的规律。","categories":[{"name":"理论","slug":"理论","permalink":"https://jeffup.github.io/categories/%E7%90%86%E8%AE%BA/"}],"tags":[{"name":"DNS","slug":"DNS","permalink":"https://jeffup.github.io/tags/DNS/"},{"name":"攻防","slug":"攻防","permalink":"https://jeffup.github.io/tags/%E6%94%BB%E9%98%B2/"}]},{"title":"JavaScript基础知识","slug":"JavaScript基础知识","date":"2019-11-24T12:04:49.000Z","updated":"2019-11-24T12:42:40.654Z","comments":true,"path":"2019/11/24/JavaScript基础知识/","link":"","permalink":"https://jeffup.github.io/2019/11/24/JavaScript%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/","excerpt":"JavaScript的基本知识一、在html中的使用","text":"JavaScript的基本知识一、在html中的使用 1.1 在页面中直接嵌入JavaScript1234567891011&lt;!doctype html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=\"utf-8\"&gt;&lt;script language=\"javascript\"&gt; alert(1)&lt;/script&gt;&lt;/head&gt;&lt;/html&gt; 执行后会直接弹出框。 1.2 script标签常用的属性和说明 属性 说明 language 设置所使用的的脚本语言及版本 src 设置一个外部文件的路径位置 type 设置所使用的脚本语言，此属性已经代替language defer 此属性表示当html文档加载完毕之后再执行脚本语言 1.3 外部调用 使用src调用js文件（外部js文件不需要用括起来） 使用函数调用本文档中的script函数如：1&lt;input onclick=&quot;myjsFun()&quot; /&gt; 二、基础2.1 变量2.1.1 变量类型有很多，基本的都有，如果想表达十六进制，则在数据之前加上0x即可。然而JavaScript是无类型语言，所以，声明变量直接用var即可 2.1.2 未定义值和空值 空值（null）不是0也不是空的字符串 一个值是空值表示已经赋过值，而未定义（undefined）表示没有赋值，两者不一样。 2.2 运算符和表达式2.2.1 比较运算符只挑一些讲 运算符 描述 示例 == 等于，只涉及表面值的判断，不涉及数据类型 “17”==17 return true === 绝对等于，同时涉及表面值和数据类型的判断 “17”==17 return false 注：这个在php中也适用。而不等于分别是!= 和!== 2.2.2 条件运算符 操作数？结果1：结果2 这个跟C++一样啊？这里来个九九乘法表练习！ 1234567891011121314151617181920212223&lt;!doctype html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=\"utf-8\"&gt;&lt;script language=\"javascript\"&gt; document.write(\"&lt;table&gt;\"); var str = \"javascript 9*9\"; document.write(\"&lt;h1&gt;\"+str+\"&lt;/h1&gt;\"); for(var i = 1;i&lt;10;i++) &#123; document.write(\"&lt;tr&gt;\"); for(var j = 1;j&lt;=i;j++) &#123; document.write(i!=j?\"&lt;th&gt;\":\"&lt;th bgcolor='#FF0000'&gt;\"); document.write(i+\"*\"+j+\"=\"+i*j); document.write(\"&lt;/th&gt;\"); &#125; document.write(\"&lt;/tr&gt;\"); &#125;&lt;/script&gt;&lt;/head&gt;&lt;/html&gt; 三、函数格式如下： function 自定义函数名（形参1，形参2…）｛ 函数体｝ 函数要在script标签中定义，使用的话，直接在html中调用函数名和参数即可，如onclick=”myFun()”。 几种特殊内置的函数： 函数 说明 eval() 求字符串中表达式的值 isFinite() 判断一个数值是否是无穷大 isNaN() 判断一个数值时都是NaN parseInt() 将字符型转化为整型 parseFloat() 将字符型转化为浮点型 encodeURI() 将字符串转化为有效的URL encodeURIComponent() 将字符串转化为有效的URL组件 decodeURI() 对encodeURI()编码的文本进行解码 decodeURIComponent() encodeURIComponent()编码的文本进行解码 四、对象编程4.1 Window对象4.1.1 属性 属性 描述 document 对话框中显示的当前文档 location 指定当前文档的url name 对话框名字 navigator 表示浏览器对象，用于获取与浏览器相关的信息 这个可以直接调用，如document.write() document.getelementById(‘test’) 4.1.2 方法 方法 描述 prompt 弹出一个提示对话框（有输入框） alert 弹出一个确认框 open 打开URL路径下的文件 close 关闭被引用的对话框 navigate(URL) 在对话框中显示URL下的文件内容 4.2 对话框 prompt（带输入的）对话框 alert直接提示对话框（仅仅是提示） confirm（带确认的）对话框 4.3 history4.3.1 属性 属性 描述 length 历史列表长度 current 当前文档URL（这个在火狐没有！？） next 列表中下个URL previous 前一个URL 4.3.2 方法 方法 描述 back 回到上一个URL forward 去后一个（下一页）URL go 进入指定页面(go(-1)==back()) 4.4 Document文档对象常用方法及实现： 方法 描述 close 文档的输出流 open 打开一个文档并接收write和writen方法的创建页面内容 write 可以在文档中写入HTML语句或者JavaScript语句 writeln 与write一样，但是以换行符结束 createElement 创建一个HTML标记 getElementById 获取指定id的HTML标记（如果内容多则以元组形式保存，需要用[*]访问） 4.5 DOM（文档对象模型）4.5.1 DOM分层如： 1234&lt;tr&gt; &lt;th&gt;&lt;/th&gt; &lt;input ... /&gt;&lt;tr&gt; 这里面tr是th和input的parentNode，而返过来，input和th是tr的childNode。而th和input是兄弟节点。 4.5.2 节点属性如下： 属性 说明 nodeName 节点名称 nodeType 节点的类型 nodeValue 节点的值，通常只应用于文本节点 parentNode 返回当前节点的额父节点 childNodes 子节点列表 firstChild 返回第一个子节点 lastChild 返回最后一个子节点 previousSibling 返回当前节点的前一个兄弟节点 nextSibling …后一个兄弟节点 attributes 元素的属性列表 4.5.3 节点操作 操作 方法 创建 appendChild 插入追加 insertBefore(new,ref) new新节点，ref指定在哪个节点后面添加 拷贝 clone(bool) true深拷贝，false浅拷贝 删除 removeChild 替换 replaceChild 4.5.4 DHTML与相应的DOM innerText 返回除去标签的文本内容 innerHTML 返回带有HTML标签的文本内容 五、事件处理注：如同onclick这种事件我就不多讲啦！ 5.1 事件流就是说一个事件触发后该先交给谁处理，然后再给谁，然后怎么返回。 5.2 DOM事件模型看图：还可以用以下程序验证： 123456789101112131415161718192021&lt;!doctype html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=\"utf-8\"&gt;&lt;title&gt;事件处理测试&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;button id='clickMe'&gt;点了我&lt;/button&gt;&lt;script&gt; var buttonClick=document.getElementById('clickMe') buttonClick.onclick=function()&#123; console.log('我点击了button');&#125; document.body.onclick=function()&#123; console.log('我点击了body');&#125; document.onclick=function()&#123; console.log('我点击了document');&#125; window.onclick=function()&#123; console.log('我点击了window');&#125; &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 5.3 事件对象当触发DOM上的某个事件时，会产生一个时间的对象。如键盘信息，鼠标信息等。如： 12345var buttonClick=document.getElementById('clickMe') buttonClick.onclick=function(event)&#123; console.log('我点击了button'); console.log(event);&#125; 其结果如下：这里，event是自带的。它返回了很多信息！ 总结：这差不多就是全部内容了。","categories":[{"name":"理论","slug":"理论","permalink":"https://jeffup.github.io/categories/%E7%90%86%E8%AE%BA/"},{"name":"代码编程","slug":"理论/代码编程","permalink":"https://jeffup.github.io/categories/%E7%90%86%E8%AE%BA/%E4%BB%A3%E7%A0%81%E7%BC%96%E7%A8%8B/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://jeffup.github.io/tags/JavaScript/"},{"name":"HTML","slug":"HTML","permalink":"https://jeffup.github.io/tags/HTML/"}]},{"title":"工具OllyDbg的使用","slug":"工具OllyDbg的使用","date":"2019-11-10T08:08:12.000Z","updated":"2019-11-25T12:36:47.697Z","comments":true,"path":"2019/11/10/工具OllyDbg的使用/","link":"","permalink":"https://jeffup.github.io/2019/11/10/%E5%B7%A5%E5%85%B7OllyDbg%E7%9A%84%E4%BD%BF%E7%94%A8/","excerpt":"一、前言OllyDbg简称OD，是一款具有可视化界面的用户模式调试器，","text":"一、前言OllyDbg简称OD，是一款具有可视化界面的用户模式调试器，结合了动态调试和静态分析，具有强大的反汇编引擎，能够识别数千个被C和Windows所使用的函数，并能将其参数注释出，能自动分析函数过程，循环语句，代码中的字符串等，非常容易上手，并且对异常的跟踪处理相当灵活，这些特性使得OllyDbg成为调试ring3级程序的首选工具，爱好者不断地修改，扩充OllyDbg，脚本执行能力和开发插件接口使得其变得越来越强大。 二、界面构成2.1 开始页面开始页面如图： 2.2 实验准备现在我编译一个很简单的C++程序（normal.exe）： 1234567891011121314151617#include &lt;iostream&gt;using namespace std;int main()&#123; int flag = 1; if(flag) &#123; cout &lt;&lt; \"hello world!\" &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; \"you have cracked it!\" &lt;&lt; endl; &#125; system(\"pause\"); return 0;&#125; 其正常输出如下： 2.3 载入程序，解释界面单击“File”-&gt;“open”选项，打开一个EXE文件，这次打开的是之前编译过的C++程序。 载入程序后的界面如下：下面解释各个部分的功能含义： 标题栏显示当前线程（main）和当前运行的程序名（normal） 菜单栏 快捷入口里面集成了许多系统工具，如文本编辑器(notepad)，计算器(calc)等 调试快捷键 (1) 打开新的可执行文件[快捷键F3](2) 重新载入程序[快捷键Ctrl+F2](3) 关闭程序 [快捷键Alt+F2](4) 运行程序[快捷键F9](5) 暂停执行程序 [快捷键F12](6) 单步步入[快捷键F7](7) 单步步过[快捷键F8](8) 跟踪步入[快捷键Ctrl+F11](9) 跟踪步过[快捷键Ctrl+F12](10) 执行到返回[快捷键Ctrl+F9](11) 转到反汇编窗中口的地址(转到表达式)[快捷键Ctrl+G] 窗口快捷键使用OD打开目标程序后，OD会打开多个子窗口，单击各个标签按钮可以在各个子窗口之间切换，这些按钮依次对应Log窗口，Executable modules窗口，Memory窗口，Threads窗口，Windows窗口，Handles窗口，CPU窗口，Patches窗口，Call stack窗口，Breakpoints窗口，References窗口，Run trace窗口，Source窗口。 反汇编面板窗口 Address列：显示被双击行地址的相对地址，再次双击返回标准地址模式 Hex dump列:设置或取消无条件断点，对应的快捷键是“F2”键。 Disassembly列:调用汇编器，可直接修改汇编代码，对应的快捷键是空格键。 Comment列:允许增加或编辑注释，对应的快捷键是“；”键。 寄存器面板窗口寄存器面板窗口（ Registers window）显示CP各寄存器的值，支持浮点、MM和3DNow寄存器。可以单击右键或窗口标题切换显示寄存器的方式。 信息面板窗口在进行动态跟踪时，信息面板窗口（Information window）将显示与指令相关的各寄存器的值、API函数调用提示和跳转提示等信息。 数据面板窗口数据面板窗口（ Dump window）以十六进制和字符方式显示文件在内存中的数据。要显示指定内存地址的数据，可单击右键快捷菜单中的Go to expression命令或按“Ctrl+G”快捷键，打开地址窗口，输入地址。 栈面板窗口栈面板窗口（Stack window）显示栈的内容，即ESP指向地址的内容。将数据放入栈的操作称为入栈（push），从栈中取出数据的操作称为出栈（pop）栈窗口非常重要，各API函数和子程序都利用它传递参数和变量等。 三、实战：运用OD现在运用OD将一个软件（名为URLegal.exe）进行注册码破解。 3.1 简单测试软件界面如下：点开注册页面如下：尝试注册（注册信息：Name:hjf 、Code:123456）： 3.2 开始逆向3.2.1 加载程序后，点击运行，运行后OD界面如下： 3.2.2 查找字符串由于注册失败界面有提示框，里面包含字符串，则搜索字符串，双击便可以进入实现注册判断的代码部分。 3.2.3 判断关键跳进入后视图如下：可以看到标记1处为跳到标记2处的关键跳之一，还有另外一个关键跳为JNZ下面的JE跳，而一般而言，关键跳的前一个CALL指令为关键CALL指令，现对JNZ上的CALL指令进行断点。我们还可以看到堆栈中（标记3）的内容，有我们刚输入的CODE，大概猜测是用于比较用的。 3.2.4 找真正的关键跳由于可能的关键跳有两个，一个是JNZ一个是JE，接下来判断哪个是关键跳，下断点后运行如图：可以看到：EAX寄存器中的值为0，则test指令执行后零标志寄存器ZF=1，JNZ不会进行跳转 text eax,eax是与运算，只有当eax为00000000才能保证0标志位ZF=1 即满足下面的跳转。换言之，这个是测试eax是否为0，为0则跳 。 继续进行步过(F8)，到达JE跳中（标记3），可以从下图中看到，JE下的跳转是红色的（会执行跳转），则判断JE上的CALL指令（标记2）为关键指令。而且，在CALL和JE中间还有指令AND和TEST，这些都是对EAX寄存器进行操作。 3.2.5 进入关键CALL判断完关键跳为JE，则尝试进入关键CALL，如下图所示：可以看到函数对堆栈进行push操作，可以大致肯定其用于比较操作。也就是说以下信息就是我们的正确CODE!可以直接拿来注册（经过验证是正确的）。 0019F950 00A3A030 ASCII “0781B2666326E5574C053884D070882E” 3.2.6 爆破既然已经发现跳转时由于EAX寄存器的值，那么可以推断是由于在关键CALL中修改了EAX导致后面的关键跳执行，则找到最后修改EAX的指令，进行NOP填充，如图：跳出CALL后可以看到JE不执行了 3.2.7 运行成功！关键跳不执行，则可以直接运行了，可以看到注册成功页面： 3.3 其他功能3.3.1 断点查看可以在快捷菜单选择B，或者快捷键alt+b，可以看到我下的全部断点：可以对断点进行Disable、Remove等操作 3.3.2 函数参考加载程序执行后，按下快捷键ctrl+N就可以看到调用的全部函数了，如图：这样我们就可以很方便地对函数出现处进行断点： 3.3.3 内存通过分析上面的关键CALL指令，知道EAX是装有我们的伪CODE的地址005E9F40，则可以找到在内存中的数据如下：可以看到，我们输入的123456就在内存中。 3.3.4 消息先打开注册页面，输入注册信息，不要点击确认，在OD里按下快捷菜单中的W，便可以看到注册框中的消息：在Vaildate My Codes字段上右击，选择消息断点，进入以下页面选择202左键触发 然后开启RUN跟踪 RUN跟踪是干什么的?简单的说，RUN跟踪就是把被调试程序执行过的指令保存下来，让你可以查看被调试程序运行期间干了哪些事。RUN跟踪会把地址、寄存器的内容、消息以及已知的操作数记录到RUN跟踪缓冲区中，你可以通过查看RUN跟踪的记录来了解程序执行了那些指令。在这还要注意一个缓冲区大小的问题，如果执行的指令太多，缓冲区满了的话，就会自动丢弃前面老的记录。 我们可以在调试选项-&gt;跟踪中设置:然后设置：效果如下：（灰条） 现在回到软件点击Vaildate My Codes，便可以直达断点：然后一步步走，会有刚输入的字符串放在堆栈和内存里的。 现在可以呼出内存映射页面M，并在CODE代码处下断点：然后回到反汇编页面，运行，直达页面：还可以查看RUN跟踪，选择统计（profile）：这样就可以看到那些指令被执行过双击后便可以直达指令处：","categories":[],"tags":[{"name":"课程","slug":"课程","permalink":"https://jeffup.github.io/tags/%E8%AF%BE%E7%A8%8B/"},{"name":"工具","slug":"工具","permalink":"https://jeffup.github.io/tags/%E5%B7%A5%E5%85%B7/"}]},{"title":"汇编语言(入门学习)","slug":"汇编语言-入门学习","date":"2019-11-10T06:57:39.000Z","updated":"2019-11-27T01:50:06.589Z","comments":true,"path":"2019/11/10/汇编语言-入门学习/","link":"","permalink":"https://jeffup.github.io/2019/11/10/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80-%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0/","excerpt":"简介：本篇旨在对汇编的基础知识进行汇总，汇总的都是要点（简明扼要），目前还在更新中。","text":"简介：本篇旨在对汇编的基础知识进行汇总，汇总的都是要点（简明扼要），目前还在更新中。 第一章 基础知识1.1 存储单元一个存储单元存储的信息量以bit为单位（最小）。而转换关系中8 bit=1 bytes(B)。而一个字=两个字节在微型计算机存储器的存储单元中，一个单元可以存1 B（即8个进制位）。而一个存储器有128个单元，则可以存储128 B。 1.2 CPU对存储器的读写要读写，则应该与三类信息进行交互： 地址信息 控制信息 数据信息 而逻辑上又分为3类总线，分别传输信息： 地址总线（指出内存中的信息放在那里(自下而上读01)） 控制总线（若要传输的数据多于一次性传输的宽度，则分开来多传几次） 数据总线 1.2.1 影响性能的因素：宽度（线的条数）：它决定了部件的能力（速度，控制能力等）。8086为16条，8088为8条 若CPU的寻址能力为8KB，则总线宽度：8*1024/1 = $2^13$ (注意单位是B,13则为总线宽度) 第二章 寄存器2.1 通用寄存器有AX BX CX DX四种，它们分为高位和低位以兼容以前的程序，如（AX = AH(高) + AL(低)）要注意的是：若只用AL进行运算，若超出其范围，超出的数据不会到AH当中！ 2.2 CPU给出物理地址的方法 段地址(SA)：只是为了内存的管理，并不是真分段。16位地址分段，一段64KB偏移地址(EA)：16位地址最多64KB公式：物理地址=段地址*16+偏移地址 2.3 段寄存器有CS DS SS ES四种。CS常存储段地址。它们提供了一下功能： CS：CPU要执行指令的地址。相当于命令指针 DS：读取内存的地址（返回数据）。相当于数据指针 SS：存储内存中的栈的顶。相当于栈顶指针 2.3.1 CS和IPIP是存储基于CS的偏移量。修改的流程： 一般流程：读取指令 -&gt; 修改 IP+=命令长度 -&gt; 执行指令(可能会涉及修改CS:IP) -&gt; 读取指令…8086PC启动时在FFFF0H单元中读取指令执行 2.4 疑问1. 为什么偏移地址只能在64Kb内？一个16位的CPU，只能有1111 1111 1111 1111，代表了4个16进制数，所以能表示2**16 bit的数据，恰好，就是64Kb。 2.暂留第三章 寄存器（内存访问）3.1 内存中字的存储 字单元的概念：即存放一个字型数据的内存单元，由两个地址连续的内存单元（一个8位）组成。高放高位，低放低位。 这里解释一下： 若有单元[0]-&gt;2e，[1]-&gt;33，那么我们读[0]的字型数据为：332eH（高放高位） 3.2 DS和[address] “[…]”表示一个内存单元，表示在段地址下的偏移量。如10000H = 1000:0 = [0] 在masm汇编编辑器中，如果单纯写mov ax,[0]，那么他会把[0]当做0来解释，即指令变成：mov ax,0而若用bx作为中转，那是可以的！如： 12mov bx,0mov ax,[bx] 这个是可以把[bx]当成段地址，返回ds:bx下的数据的！而如果偏要用[idata]的话，那么就必须加上ds:前缀，如： 1mov ax,ds:[0] 而对于Debug编译器的话，ds是自动加上的，用 1mov ax,[0] 即可，如果使用[]的话，而且他（段寄存器）是不能直接用mov命令改变的，必须通过其他的寄存器中转才能改变。 3.3 字的传送（mov指令）在传送字之后， DS和[address]也会跟着变，如1000:0，若传入一个fffeH，则address会从0-&gt;2，此时，[0]存有feH，[1]存有ffH,[2]为空。 3.4 mov、add、sub指令主要是说说置零问题，与机械码长度问题，稍微提一下，以后会细讲。举例子： 12sub bx, bxmov bx, 0 两个都是可以将bx寄存器置零的指令，但是sub的机械码长度为2，而mov为3，用sub更好。另外说说jmp指令，他是转移指令，具有一个操作对象的指令，而上面的具有两个。 3.5 栈他是一个FILO结构（先入后出），而且是从大变小（地址）。 3.5.1 push和pop 执行push ax命令，会把ax中的数据传入ss:sp指向的地址空间。此时sp-=2执行pop ax命令，会把ss:sp指向的地址空间中的数据传给ax。此时sp+=2 执行之后的指针变化： push先令sp-=2，然后将ax中的数据放进去。称为出栈。 pop是先取出数据放到ax中，再sp+=2。称为入栈。 3.5.2 数据传输如8086cpu的入栈和出栈都是以字为单位进行的。 3.5.3 栈指针上面已经用到了：段寄存器:寄存器存储(ss:sp)sp是指偏移地址，ss:sp始终指向栈顶。 3.6 栈顶越界问题栈溢出问题都是大问题，如果栈顶越界了，那么执行push和pop会受影响吗？当然不会！直接刚，写！写！写！出！出！出！管你呢。所以就会有可能读了其他程序的数据，或者修改了（覆盖）其他程序的数据（直接崩溃的说）执行情况（取自《汇编语言第二版》王爽著） 3.7 问题1.程序与数据有区别吗？可以说有，也可以说没有。由于指令都是0和1组成的，只是用不同功能的段地址读出来的不一样，如,CS和DS都指向10000H，那么，CS会将里头的数据转化为机械码，执行指令，而DS就直接读数据，作为单纯的数据使用。 2.空栈如（10000H~1000FH）此时ss=1000H，那么sp是多少？因为是自下而上（自大到小），所以sp=0010H。换一种方式看，若存储了一个数据，则一个存到000EH，一个存到000FH，此时的栈指针在栈顶，当然指向000EH了，此时是已经让sp-=2了，那么回溯一下，不就有sp=0010H了。 好了，问题来了，如果将（10000H~1FFFFH）作为空间呢？答案：sp=0000H，因为，不能变成10000H(笑) 3.栈会溢出，那么，为什么不设置栈大小emmm，可惜8086cpu就是没有，所以变成自己注意。 4.只有mov可以完成传输数据吗？push也可以哦，只要把sp定位为ds:[address]那就好了哦。直接写进去。 第四章 第一个程序4.1 一个源程序从写出到执行的过程执行过程包括：写程序-&gt;编译连接成可执行文件-&gt;执行。 可执行文件文件中包括以下两部分： 程序和数据 相关的描述：程序多大，占用多少运行空间 4.2 源程序4.2.1 伪指令也就是只能被编译器识别的指令，如assume、segment、end等，这是没有机械码的。一般的伪指令使用如下： 12345assume cs:code #声明（假设）cs:段名（标号）code segment #段名 segment_指令_code ends #对应segment，表示一个段结束end #对应assume，表示程序结束 4.2.2 程序返回现在考虑，如何让上一个程序把CPU控制权交给写一个程序，这时候就要使用程序返回其代码如下： 12mov ax, 4c00Hint 21H 4.3 程序生成流程编程 -&gt; 1.asm -&gt; 编译 -&gt; 1.obj -&gt; 连接 -&gt; 1.exe -&gt; 加载 -&gt; 内存中的程序 -&gt; 运行注：加载就是将程序加载到内存，执行就是在内存中执行程序的指令 4.4 怎么装载程序？操作系统是一个模块组成庞大的系统。任何通用的系统都要提供一个称为shell的程序，用户使用这个程序来操作计算机系统进行工作。 如DOS中有一个程序command.com，这个程序称为：命令解释器，也就是DOS中的SHELL（其实跟我们的cmd.exe差不多） 先运行shell，然后在加载1.exe可执行程序的时候，cmd会自动把cpu的控制权交给1.exe，执行完成再返回cmd。 4.4 展示EXE的加载过程 第五章 [BX]和loop指令5.1 [BX]这个之前就讲过：其实就是把BX中的值作为ds的偏移地址EA，然后可以用这个来访问特定地址下的数据。如ds:1000H，bx=0001H，那么[BX]就是指ds*16+bx下的值。 5.2 loop直接上程序： 12345678assume cs:eloopeloop segment mov ax,128 mov cx,36 s:add ax,ax loop seloop endsend 解释： loop是按照cx当中的值进行对有标号的s下的命令进行循环的。当cx不等于0，则执行循环，这个程序实际上是实现128*36的程序。 s实际上是IP值，指向s标记的地址，所以loop s实际上是给IP赋值：IP=s，然后就可以通过cs:ip来执行指令了 注意：汇编程序中，数据不能以字母开头，所以要在前面加个0。比如：9138h可以写成9138h，而A000h就必须写成0A000h 5.3 loop和[bx]的联合运用例如来一个如同C++语言中的： 123456int dx = 0;int ds[12] = &#123;1, 2, ...&#125;;for(int i=0; i &lt; 12; i++)&#123; dx += ds[i];&#125; 那么汇编语言就有： 123456789101112131415161718192021assume cs:codecode segment: mov ax, 0ffffh ;因为ds寄存器不能直接赋值，所以用ax作为中间变量 mov ds,ax mov bx,0 ;初始化ds:bx指向ffff:0 mov dx,0 ;初始化**累加寄存器**dx，让值为0 mov cx,12 ;初始化循环计数寄存器cx，令值为12，指循环12次 s: mov al,[bx] ;以下两步执行ax的赋值操作 mov ah,0 ; add dx,ax ;执行加法 inc bx ;ds:bx指向下一个单元，因为bx的值增加了1，相当于C++代码中的*i++* loop s ;loop完成一次，则cx=cx-1，然后判断cx是否等于0，如果等于则退出循环 mov ax,4c00h int 21hcode endsend 好了，现在来说说这段代码里面有什么需要注意的点： cx寄存器一般用作loop循环的判断条件，即循环的粗次数。 ax寄存器的初始化有两步，是，因为一个字符型数据是8位这样的话转化为16位就得让高8位的值赋为0。 dx寄存器是常用的累加寄存器。 inc指令是让后面的值加一的指令，相当于C++语言中的‘++’自增。 int指令： 由int 指令引发的中断是一种重要的内中断。格式： int n //相当于引发一个n号中断的过程,最终功能和call指令相似，都是调用一段程序。 取中断类型码n 标志寄存器入栈，并IF=0,TF=0 //TF=0使得避免中断程序执行过程中引发单步中断 CS,IP寄存器入栈 IP=(n*4) , CS=(n*4 + 2)原文链接 5.4 段前缀与其使用 能够显示地指令内存单元的段地址的，如：”ds:”、”cs:”、”ss:”、”es:”。这就是段前缀。 默认的[x]是指：(dx*16)+x，而如果要用其他的段寄存器，则需要加上它的段前缀。 第六章 包含多个段的程序 由于软件是由数据和程序组成的，数据当然也是程序里面必不可少的部分，所以会将代码分为多段进行，如数据段、代码段等。 6.1 在代码段中使用数据 汇编程序若没有特殊的说明（或者注明在哪里开始），则默认从头开始！所以，一旦你的程序头部有数据，则将会把头部的数据翻译为机器码执行。(冤) 那么解决方式是：在开始执行代码的地方加上 start: 123456789101112131415assume cs:codecode segment dw 0123h,0456h,0789h ;这里是数据部分 dw意思是定义字符型数据 start: mov bx,0 ;注意，从这开始，标识为start! mov ax,0 mov cx,8 s: add ax,cs:[bx] ;用cs作为段地址，取数据！ add bx,2 loop s mov ax,4c00h int 2hcode endsend start ;注意end后面要加上end开始的名称！ 6.2 将数据、代码、栈放入不同的段上面说了，代码从哪里开始就在哪里加上start，结束就用end start（其他标识也行）好，记住，那是代码，别把接下来说的混淆了。 不同的段可以放不同的东西，例如数据，代码等等。只要记住将段名end了再定义其他段。也只有定义了，才能使用这个段 123456789101112131415161718192021222324252627282930313233assume cs:b,ds:a,ss:ca segment dw 0123h, 0456h, 0789h, 0abch, 0de fh, Ofedh, 0cbah, 0987ha endsc segment dw 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0c endsb segmentd: mov ax,c ;使用段c中的数据 mov ss,ax mov sp, 20h ;希望用c段当作栈空间，设置ss:sp指向c:20 mov ax,a ;使用段a mov ds,ax ;希望用ds:bx访问a段中的数据，ds指向a段 mov bx,0 ;ds:bx指向a段中的第一一个单元 mov Cx,8s: push [bx] add bx,2 1oop s ;以上将a段中的0~15单元中的8个字型数据依次入栈 mov bx,0 mov cx, Bs0: pop [bx] add bx,2 1oop s0 ;以上依次出栈8个字型数据到a段的0~15单元中 mov ax, 4c00hint 21hb endsend d ;d处是要执行的第一- 条指令，即程序的入口 第七章 更灵活的定位内存地址的方法之前的[0]和[bx]均可以起到定位的作用，现在有更灵活的定位方式： 7.1 and和or指令 and是有零变零，而or是有一变一也可以想象成and是乘法，or是加法 7.2 以字符型给出数据凡是以’…’形式给出数据的，都被译为是字符型数据，这样，编译器会将里面的数据变成ASCII码值。具体实例： 12db &apos;unIX&apos;mov al,&apos;a&apos; 这里被译为 12db 75H,6EH,49H,58Hmov al,61H 而大小写转换的方法有两种： 基于比较的，在ASCII码中，大写字母+20H=小写字母 基于二进制数的，在ASCII表达字符时，若第五位为0，则为大写字母；若第五位为1则为小写字母（这里可以用or或者and来进行转换） 7.3 以[bx+idata]的方式寻址现在以例题进行解析，将第一组字符串变成大写，第二组变成小写 123456789assume cs:codesg,ds:datasgdatasg segment db &apos;BaSiC&apos; db &apos;MinIX&apos;datasg endscodesg segmentstart: ;代码段codesg endsend start 原来的思想：取[bx]中的字符，再对其进行and 11011111b操作，再放回去，然后将bx自增，再重新···，而变成小写就or 00100000b。（这里要执行两次循环啊，一个变大写，一个变小写） 然而我们可以使用以下思想，更加便捷，就是[bx+idata]：思想和前面的一样，但是，不用执行两次循环，只要一次就够了：12345678910111213 mov ax,datasg mov ds, ax mov bx,0 mov cx,5s:mov al,[bx] ;定位第一个字符串的第bx个字符 and al,11011111b ;执行完变大工作 mov [bx],al ;放回去 mov al[5+bx] ;定位第二个字符串的第bx个字符（因为一个字符串只有5个字符） or al,00100000b ;执行变小工作 mov [5+bx],al ;放回去 inc bx ;自增 loop s 这个其实，学过高级语言都知道这方法，只不过，没想到汇编也能做吧，汇编语言也不是那么死板的。 7.4 si与di寄存器和多重循环这个只要知道是16位寄存器，功能和bx差不多，可以用作[bx+si+idata]和[bx+di+idata]就可以了。其中，idata是常量，其他的为变量。这个结构可以执行二重循环，相当于处理二维数组。需要注意的是二重循环的实现： 问题一：cx寄存器是用作循环的判定条件的，那么二重循环对于没有两个cx的我们来说，如何是好？将之前的cx用其他寄存器保存起来啊！ 问题二：二重循环可以那样做，那么多重循环呢！？你只有有限个寄存器。利用内存空间！开辟一段dw 0，让后指向它，放进去就完事了。 问题三：那这个方法的前提是我得知道有多少个循环，很麻烦啊，换个简单的。 在需要暂存数据的时候我们都应该使用栈* 在需要暂存数据的时候我们都应该使用栈* 在需要暂存数据的时候我们都应该使用栈*按顺序push，然后逆向按顺序pop 第八章 数据处理的两个基本问题这两个问题是： 处理的数据在什么地方 要处理的数据有多长 8.1 bx、si、di和bp这几个都用过，主要说说bp:这个只要在[…]里使用了它，没有段地址声明，那么默认是ss 8.2 机器指令处理的数据在什么地方在指令执行前，所要处理的数据可以在三个地方： CPU内部 内存 端口下面举例子：上图还表明了汇编语言中数据位置的表达 立即数（idata）：如上图的最后一个例子，是直接赋值的 寄存器：如上图的第二个例子，使用寄存器名。 段地址：如果是[bx]则默认段地址是ds，如果是[bp]则默认段地址为ss，当然可以显性给出。 8.3 指令处理的数据长度这个得看具体例子。 如果是ax,bx，那么这个就是字操作 如说是al,bl，那么就是字节操作 在没有寄存器名存在的情况下，用操作符X ptr指明内存单元的长度，X在汇编中可以为word或byte（且必须显式声明）。 12mov word ptr ds:[0],1 ;字mov byte ptr ds:[0],1 ;字节 有些指令默认了访问的是字还是字节，如push默认进行字操作，而用[…]的是字单元操作(一个8位)。 8.4 div指令div是除法指令，使用div做除法的时候应注意以下问题. 除数:有8位和16位两种，在一个reg或内存单元中。 被除数:默认放在AX或DX和AX中 如果除数为8位，被除数则为16位，默认在AX中存放； 如果除数为16位，被除数则为32位，在DX和AX中存放，DX存放高16位，AX存放低16位。 结果: 如果除数为8位，则AL存储除法操作的商，AH存储除法操作的余数: 如果除数为16位，则AX存储除法操作的商，DX存储除法操作的余数。 格式如下： 12345div regdiv 内存单元div byte ptr ds:[0]含义：(al)=(ax)/((ds)*16+0)的商 (ah)=(ax)/((ds)*16+0)的余数 8.5 实例利用除法指令计算100001/100分析： 由于100001大于整数最大值（16位）65535，不能用ax寄存器存放，所以只能用dx和ax两个寄存器联合存放，共32位 而出书100小于255（8位），但是因为被除数是32位，所以除数应该用16位的来存放除数100所以有程序： 1234mov dx,1mov ax,86A1H ;(dx)*10000H+(ax)=100001 100001=186A1Hmov bx,100div bx 执行后，(ax)=03E8H(即10000)，(dx)=1(余数为1)。 8.6 伪指令dd之前有学过用db和dw定义字节型数据和字型数据。dd是用来定义dword（double word，双字）型数据的。 db 占1个字节 dw 占1个字（即两个字节） db 占2个字（即四个字节） 8.7 dupdup是一个操作符，在汇编语言中与dw,db,dd一样，都是由编译器识别处理的符号，且与它们一同配合使用，用来进行数据重复。如： 123456789db 3 dup (0)定义了3个字节，它们的值都是0，相当于执行了 db 0,0,0。db 3 dup (1,2,3)定义了3\\*3=9个字节，它们是0、1、2、0、1、2、0、1、2，相当于db 0,1,2,0,1,2,0,1,2。字符型也适用。总结：d？ 重复的次数 dup (重复的(字节/字/双字型)数据） 第九章 转移指令的原理可以修改IP 或同事修改CS和IP的指令统称为转移指令统称为转移指令。如jmp、jno等，即可以控制CPU指令内存中某处代码的指令。具体分类有： 无条件转移指令（jmp） 条件转移指令（jno） 循环指令（loop） 过程 中断 还有其他的分类： 只修改IP：段内转移（jmp ax） 同时修改CS和IP：段间转移（jmp 1000:0） 短转移 近转移 9.1 操作符offsetoffset是编译器处理符号，功能：取得标号的额编译地址。如： 12start: mov ax, offset start ;相当于mov ax,0 s: mov ax, offset s ;相当于mov ax,3 解析：第一条指令mov … 是三个字节，所以s段的offset为3 9.2 jmp指令和依据译为进行转移的jmp指令9.2.1 jmp short 标号(转移到标号出执行指令)1. short标号下，它属于段内短转移，对IP的修改范围为-128~127。9.2.2 立即数在机器码中的表示在一般的汇编指令当中，汇编指令的idata（立即数），不论他是表示一个数据还是内存单元的偏移地址，都会在相应的机器指令中出现，因为CPU执行的是机器指令，他必须处理这些数据或地址。 123mov ax,0123h B8 23 01mov ax,ds:[0123h] A1 23 01push ds:[0123h] FF 36 23 01 9.2.3 jmp转移的机制（是怎么实现转移的）12345start: mov ax,0 mov bx,0 jmp short s add ax,1 s: inc ax 首先我们应该知道，jmp指令是2个字节，如代码中的jmp机械码是：EB 03 。这样的机械码，没有包含s段的地址！所以将jmp指令写入内存之后，IP=IP+2=0008h。 但是，执行完jmp后，IP=000Bh。因为执行JMP，就是执行IP=IP+(EB之后的偏移量)=IP+3=000Bh。 所以jmp执行的是给IP加偏移地址！。 所以 jmp short 标号 的功能为：(ip)=(ip)+8位位移 9.2.4 继续上面的，8位位移是怎么得出来的？ 8位位移=标号处的地址 - jmp指令后的第一个字节的地址. short指明此处的位移为8位位移; 8位位移的范围为-128-127，用补码表示 8位位移由编译程序在编译时算出。 还有一种和”jmp short标号”功能相近的指令格式:jmp near ptr标号它实现的是段内近转移。功能为:(IP)=(LP)+16位位移。(1) 16位位移=标号处的地址 - jmp指令后的第一个字节的地址:(2) near ptr指明此处的位移为16位位移，进行的是段内近转移:(3) 16位位移的范围为一32768~32767，用补码表示:(4) 16位位移由编译程序在编译时算出。 9.2.5 jmp far ptr 标号（段间转移/远转移）是不是所有的jmp机械码都没有段数据呢？当然不是！小标题就说到了：far ptr，这个指令用标号的段地址和偏移地址修改CS和IP如：解释：“OB 01 BD 0B”是目的地之在指令中的存储顺序：高地址：“BD 0B”是段地址 0BBDH ；低地址：“0B 01”是偏移地址 010BH ； 9.2.6 转移地址在寄存器的jmp指令(这就相当于总结了，上面废话有点多) 若只是一个字，则只是偏移地址（直接EB ??完事） 若是两个字，那么一个是段，一个是偏移地址。 9.3 jcxz指令该指令为有条件转移指令，所有的有条件转移指令都是短指令，即上面9.2.6说的1个字，只有位移（偏移地址），对ip的修改范围是：-128~127. 指令格式：jcxz 标号如果(cx)=0，则转移到标号这 9.4 loop指令也是短转移指令，pass 9.5 编译器对转移位移超界的检测编译的时候就会出错！因为，这超界，编译器可识别不了。这不存在的玩意儿。 第十章 CALL和RET指令10.1 ret和retf它们都是用栈中的指令，而ret是改变ip，而retf是改变cs:ip，实现远转移。而正是因为它们是取栈中的指令，所以要和push 和pop结合起来，而ret或者retf执行完后，相当于执行了指令pop如： 123456mov ax stack ;在前面声明的stack数据段，共16Bmov ss ax ;栈段地址mov sp 16 ;将值（Base）设置为16，往上加。（栈的特性）push cxpush ipretf 这里就相当于执行了刚放进去的机器码。 10.2 call指令 将打那个钱的IP或CS:IP压入栈中 转移 注意：call指令不能执行短转移，其实现方法与jmp指令相同 10.2.1 依据位移进行转移的call指令 call 标号(将当期那的ip压入栈后，转到标号处执行指令) 指令执行时会带有以下操作： 1231. (sp)=(sp)-2 ;压栈 ((ss)*16+(sp))=(IP)2. (IP)=(IP)+16位位移 这个位移之前也说过了，不多讲。看到上面的代码我们也能联想到jmp的执行了，相当于： 12push IPjmp near ptr 标号 举个例子！ 12345内存地址 机器码 汇编指令 1000:0 b8 00 00 mov ax,0 1000:3 e8 01 00 call s 1000:6 40 inc ax 1000:7 58 s:pop ax 也许你会想到：我没有push哪来的pop!? 在call之时已经有了push ip，此时的ip=提取call s之后指向下一个执行机器码（inc ax）的ip指针，也就是ip=6。 而当call转移到s，ip就变为call之后的ip。 此时再pop ax，也就是ax=6。 因为执行完s，没有回调指令pop ip。。。所以不会执行inc ax 10.2.2 转移地址在指令中的call指令这个也就是段间转移了，是相对于上头说的段内转移 1call far ptr 标号 此时会执行cs和ip双压栈 12345678910111. (sp)=(sp)-2 ;压栈 ((ss)*16+(sp))=(CS)(sp)=(sp)-2 ;压栈 ((ss)*16+(sp))=(IP)2. (CS)=标号所在的段地址(IP)=标号在段中的偏移地址即：push CSpush IPjmp far ptr 标号 举个例子： 12345671000:0 b8 00 00 mov ax,01000:3 9a 09 00 00 10 call far ptr s1000:8 40 inc ax1000:9 58 s: pop ax add ax,ax pop bx add ax,bx ax是多少呢？ call指令执行之后，stack中有cs和ip两个数据，CS在底部,IP在顶部。所以第一次pop ax，ax=ip=8 执行add后ax=16即10H 再执行pop，bx=1000H add指令执行后ax=ax+bx=1010H 10.2.3 转移指令在寄存器中的call指令call 16位reg功能： 12push IPjmp 16位reg ;IP=(reg) 这个跟10.2.1是不是很像？段内转移。例子：call ax（当ax=6,则转到cs:6处执行） 10.2.4 转移指令在内存中的call指令call word ptr 内存单元地址功能： 12push IPjmp word ptr 内存单元地址 其实跟10.2.3没啥两样。 但是还有一种双字型： call dword ptr 内存单元地址功能： 123push CSpush IPjmp dword ptr 内存单元地址 举个例子就明白了 12345mov sp,10hmov ax,0123hmov ds:[0],axmov word ptr ds:[2]，0call dword ptr ds:[0] 执行后：(CS)=0, (IP)=0123H, (sp)=0CH. 10.3 call与ret的配合使用（敲黑板！） call之时压ip到栈中! call完之后，执行转移后的指令 通过ret取出栈中的地址，执行转移操作！即回调作用！ 回调完成就可以执行call之后的代码了！分析例子：12345678910111213assume cs:codecode segment start: mov ax,1 mov cx,3 call s mov bx,ax ;(b)=? mov ax,4c00h int 21h s: add ax,ax loop s retcode endsend start 我们来看一下CPU执行这个程序的主要过程。 (1)CPU将call s指令的机器码读入，IP指向了call s后的指令mov bx,ax.然后CPU执行call s指令，将当前的IP值(指令mov bx,ax的偏移地址)压栈，并将IP的值改变为标号s处的偏移地址: (2) CPU从标号s处开始执行指令，loop循环完毕后，(ax)=8; (3) CPU将ret指令的机器码读入，IP指向了ret指令后的内存单元，然后CPU执行ret指令，从栈中弹出一个值(即call s先前压入的mov bx,ax指令的偏移地址)送入IP中。则CS:IP指向指令mov bx,ax; (4) CPU从mov bx,ax开始执行指令，直至完成。 10.4 mul乘法指令之前说了div除法指令，现在说乘法指令。 10.4.1 乘法规则这里跟div的除数和被除数不一样的是，乘法的两个数，要么都是8位要么都是16位！ 乘法的两个数 如果是8位，一个放在AL中，一个放在8位的reg或内存字节单元中。 如果是16位，一个放在AX中，一个放在16位的reg或内存字节单元中。 乘法的结果 如果是8位乘法，结果放在AX中 如果是16位乘法，高位放DX，低位放AX 10.4.2 指令格式：12mul regmul 内存单元 格式说明：因为有一个放在了al(以8位为例) 123mov al 1mov byte ptr ds:[0] 2mul ds:[0] 这个就是用2*1了~结果是ax=2（当然，我赋值的是十进制嘛） 10.4.3 用mul寻址 mul byte ptr ds:[0]含义：ax=al(ds16+0) mul word ptr [bx+si+8]含义：dx= 10.5 模块化程序设计10.5.1 参数和结果的传递问题也就是说，传进来的参数是啥，返回值是个啥。 传入的参数：这个有很多，有用栈传递的，也有直接用内存单元或者寄存器。 返回值：这个可以存在寄存器中返回跟传入参数的方法很像 而模块化设计，其实就是相当于c语言中的函数，把一个段中的代码当做一个函数执行。 10.5.2 寄存器冲突问题冲突问题是什么呢？例如如果上面的模块使用的loop，即使用了寄存器cx，而call的模块也适用了loop，即也使用了cx，那么两者就将共用cx，肯定会出错！解决办法有： 让别的调用者调用其他寄存器（这个很难实现，你也不知道他会用到什么寄存器） 不要使用会冲突的寄存器（这个不可能实现，只是说说理想罢了） 用栈，压进去，保存，call完在出栈！（这个OK哦） 10.6 课后下面的程序执行后，ax和bx中的数值为多少？12345678910111213141516171819202122assume cs:codesgstack segment dw 8 dup(0)stack endscodesg segmentstart: mov ax,stack mov ss,ax mov sp,10h mov word ptr ss:[0],offset s ;(ss:[0])=1ah mov ss:[2],cs ;(ss:[2])=cs call dword ptr ss:[0] ;cs入栈,ip=19h入栈,转到cs:1ah处执行指令 ;(ss:[4])=cs,(ss:[6])=ip nops: mov ax,offset s ;ax=1ah sub ax,ss:[0ch] ;ax=1ah-(ss:[0ch])=1ah-19h=1 mov bx,cs ;bx=cs＝0c5bh sub bx,ss:[0eh] ;bx=cs-cs=0 mov ax,4c00h int 21hcodesg endsend start 实验10-1 编写子程序 之 显示字符串在这次实验中，我们将要编写3个子程序，通过它们来认识几个常见的问题和掌握解决这些问题的方法.同前面的所有实验一样，这个实验是必须独立完成的，在后面的课程中，将要用到这个实验中编写的3个子程序。 显示字符串问题显示字符串是现实工作中经常要用到的功能，应该编写一个通用的子程序来实现这个功能.我们应该提供灵活的调用接口，使调用者可以决定显示的位置(行、列)、内容和颜色。 子程序描述名称:show str功能:在指定的位置，用指定的颜色，显示一个用0结束的字符串。参数:(dh)=行号(取值范围。-24), (dl)=列号(取值范围0-79), (cl)=颜色，ds:si指向字符串的首地址返回:无应用举例:在屏幕的8行3列，用绿色显示data段中的字符串。 提示 子程序的入口参数是屏幕上的行号和列号，注意在子程序内部要将它们转化为显存中的地址，首先要分析一下屏幕上的行列位置和显存地址的对应关系: 注意保存子程序中用到的相关寄存器: 这个子程序的内部处理和显存的结构密切相关.但是向外提供了与显存结构无关的接口。通过调用这个子程序，进行字符串的显示时可以不必了解显存的结构，为编程提供了方便。在实验中，注意体会这种设计思想。 其实这玩意，就是抢占了本来应该在屏幕中输出的系统信息。那么设置行列号的，就是占的信息的位置。 点击查看参考代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061assume cs:code,ds:datadata segment db &apos;Welcome to masm!&apos;,0data endscode segmentstart: mov dh,8 ;行号 mov dl,3 ;列号 mov cl,07h ;白色字 mov ax,data mov ds,ax mov si,0 ;循环加入字 call show_str mov ax,4c00h int 21hshow_str: push cx ;保存用到的寄存器 push si push es push di push bx mov ax,0b800h mov es,ax mov al,0a0h ;一行的总列数160字节 dec dh ;行号减1，因为是从0开始的 mul dh ;计算行开始偏移地址 mov bx,ax mov al,2 mul dl ;计算列 sub ax,2 ;列也是从0开始，而且一个字符占两个字节 add bx,ax ;求出开始位置 mov di,0 mov al,cl mov ch,0 ;高8位为0s: mov cl,ds:[si] ;判断是否到了字符结束 jcxz ok mov es:[bx+di],cl mov es:[bx+di+1],al inc si add di,2 jmp short sok: pop bx pop di pop es pop si pop cx retcode endsend start 解决除法溢出问题问题：其实就是如果商超过了应该存储商的寄存器的大小，应该怎么办。emmm可以用大一点的，用dword 第十一章 标志寄存器这是一种特殊的寄存器，一共16位： 用来存储相关指令的执行结果 用来为CPU执行相关指令提供行为依据 用来控制CPU的相关工作方式其分布如下： 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0 * * * * OF DF IF TF SF ZF * AF * PF * CF 其中*表示都没用：1 3 5 12 13 14 15在8086CPU中都没有使用。注意：对标志位有影响的指令有：add,sub,mul,div,inc,or,and等，而没有影响的有：mov,push,pop等，它们大多数为传送指令。 11.1 标志表 名称 代号 作用 备注 零标志 ZF 判断结果是否为零 若为0则ZF=1，否则ZF=0 奇偶标志 PF 判断结果中1的个数是奇是偶 若1的个数为奇数则PF=0，否则为1 符号标志 SF 判断结果是正是负 若为正数则SF=0，否则为1 进位标志位 CF 在进行无符号运算时记录是否有向最高位进位或者借位 那是假想的最高位 溢出标志 OF 判断是否超过容器所能装的最大数 如al=98+99=197，197&gt;127溢出，实际结果：-59 方向标志 DF 控制每次操作后si、di的增减 df=0 每次si,di增加；df=1 每次si,di减少。经常用作字符串的传送 11.2 与标志有关的指令11.2.1 与CF相关的：adc,sdd指令 adc：带进位加法。如：adc al,8h == al+8h+CF sdd：带借位减法。如：sdd al,8h == al-8h-CF 11.2.2 与CF和ZF有关的：cmp指令（比较指令）指令格式：cmp s1,s2举个例子：cmp ax,bx比对结果如下： 情况 结果分析 结果 (ax)=(bx) 则(ax)-(bx)=0 zf=1; (ax)≠(bx) 则(ax)-(bx)≠0 zf=0; (ax)&lt;(bx) 则(ax卜(bx)将产生借位 cf=1; (ax)≥(bx) 则(ax)-(bx)不必借位 cf=0; (ax)&gt;(bx) 则(ax)-(bx)既不必借位，结果又不为0 cf=0并且zf=0; (ax)≤(bx) 则(ax)-(bx)既可能借位，结果可能为0 cf=1或zf=1. 11.2.3 与CMP有关的比较结果条件转移指令 指令 含义 简记 符号 监测的相关标志位 je 等于则转移 equal = zf=1 jne 不等于则转移 not equal ≠ zf=0 jb 低于则转移 below ＜ cf=1 jnb 不低于则转移 not below ≥ cf=0 ja 高于则转移 above ＞ cf=0且zf=0 jna 不高于则转移 not above ≤ cf=1或zf=1 注意，这个一般是与cmp配合使用，如同call和ret一样，但是没有说一定要配合使用。 11.2.4 与DF有关指令 指令 功能 解释 movsb mov es:[di],byte ptr ds:[si] 从ds中取字符放到es指定的位置中，单位为字节，会令di和si同时±1 movsw mov es:[di],word ptr ds:[si] 从ds中取字符放到es指定的位置中，单位为字，会令di和si同时±2 cld 设置df=0，正向 令di，si向增方向 std 设置df=1，逆向 令di，si向减方向 rep 重复指令，根据CX当中的值，与LOOP相似 配合movsb使用 例子： 1234567891011121314151617181920212223242526我们来看下面的两个程序。(1)编程，用串传送指令，将data段中的第一个字符串复制到它后面的空间中。data segmentdb &apos;Welcome to masm!.db 16 dup (0)data ends我们分析一下，使用串传送指令进行数据的传送，需要给它提供一些必要的信息它们是:1. 传送的原始位置:ds:si:2. 传送的目的位置:es:di;3. 传送的长度:CX;4. 传送的方向:df.在这个问题中，这些信息如下。1. 传送的原始位置:data:O;2. 传送的目的位置:data:0010;3. 传送的长度:16;4. 传送的方向:因为正向传送(每次串传送指令执行后，Si和di递增此较方便，所以设置df=o好了，明确了这些信息之后，我们来编写程序:mov ax,datamov ds,axmov si,0 ;ds:si指向data: 0mov es,axmov di,16 ;es.di于行向data:0010mov cx,16 ;(cx)-16, rep循环1‘次cld ;设置df=0，正向传送rep movsb 11.3 标志位有关的问题11.3.1 单纯就符号标志位就可以判断结果的正负吗？（即判断相减的两个数的大小）当然不是！ 当1-2=-1&lt;0，则SF为1，表示负数，则前一个数比后一个数大当34-(-96)=82H时，82H是-126的补码，所以SF=1，但是前一个数比后一个数大？当然不。 为什么呢？因为发生了溢出。 也就是说，保存结果的寄存器不足以表示那么大的数。 而34-(-96)=130明显超过127（假设保存结果的是ah）。 那么结果就会表示为-126（130-127=3，-128+3-1=-126） 而此时，SF=1，同时，OF=1。 所以要看结果的正负，要结合SF和OF的值. 总结： 标志 结果 备注 SF=1,OF=0 负 略 SF=1,OF=1 正 因为溢出导致实际结果为负，那么逻辑上必定为正 SF=0,OF=1 负 因为溢出导致实际结果为正，那么逻辑上必定为负 SF=0,OF=0 正 略 11.4 pushf和popf因为标志寄存器共16位，所以pushf就直接将16位当做寄存器放入栈中，popf是出栈。注意，它们不需要加对象参数，入栈和出栈的对象都是标志寄存器！ 第十二章 内中断也就是CPU不再往下执行下去。而CPU内部的四种中断信息是： 除法错误，如div指令产生的除法溢出（中断类型码：0） 单步执行（中断类型码：1） 执行into指令（中断类型码：4） 执行int指令（指令格式：int n，其中n是中断类型码，是字节型立即数） 12.1 中断一条龙（中断程序，中断向量表，中断过程）中断过程： 取得中断类型码（即中断向量表中的中断程序位置） 标志位入栈（因为执行中断过程要改变标志寄存器的值） 设置寄存器的TF和IF的值为0 CS内容入栈 IP内容入栈（结束中断程序回调的时候用，和call差不多） 从内存地址为中断类型码*4和中断类型码*4+2的两个字单元中读取中断处理程序的入口地址设置IP和CS。（用来取得中断程序在内存中的位置） 其实就是： get N pushf TF=0, IF=0 push CS push IP (IP)=(N*4), (CS)=(N/4+2) 执行程序！ 12.2 中断处理程序，安装，中断向量等这个只是稍微述说，额，因为我不太能用到这个，作为了解而已。中断处理程序就如同除法溢出程序一样（输出‘…overflow’），如何处理后续的事物做中断处理，然后返回系统程序。而如果想要自己编一个中断处理程序，首先 把中断码想好，把程序要放的地方想好，*放入中断向量表 编程序，安装（写到相应位置） 测试 这里当然要用到之前学的几乎所有内容（包括ret,movsb等） 12.3 单步中断和TF,DF标志说到这里，你看标题就知道，TF肯定与单步中断有关，具体有什么关系呢？首先说说单步中断，也就是不停止（退出）运行的程序，却能返回其实时的寄存器信息（也就是还在运行，只不过暂时停止了）。而TF就是实现单步中断的重要标志，当TF=1时将引发单步中断，所以要想中断就先置TF=1。这就是为什么中断执行（刚开始）就要把TF置0，就是为了防止步步中断！ 12.4 int指令int指令引发的内中断很重要。虽然其过程与12.1所说的别无二致。接下来就深入理解理解int、iret和栈： 12.4.1 int、iret和栈第十三章 汇编语言重点知识总结13.1寄存器与存储器 寄存器功能 寄存器的一般用途和专用用途 CS:IP 控制程序执行流程 SS:SP 提供堆栈栈顶单元地址 DS:BX(SI,DI) 提供数据段内单元地址 SS:BP 提供堆栈内单元地址 ES:BX(SI,DI) 提供附加段内单元地址 AX,CX,BX 和CX 寄存器多用于运算和暂存中间计算结果,但又专用于某些指令(查阅指令表)。 PSW 程序状态字寄存器只能通过专用指令（LAHF, SAHF)和堆栈(PUSHF,POPF)进行存取。 存储器分段管理 解决了16 位寄存器构成20 位地址的问题 便于程序重定位 20 位物理地址=段地址* 16 + 偏移地址 程序分段组织: 一般由代码段,堆栈段,数据段和附加段组成,不设置堆栈段时则使用系统内部的堆栈。 堆栈 堆栈是一种先进后出的数据结构, 数据的存取在栈顶进行, 数据入栈使堆栈向地址减小的方向扩展。 堆栈常用于保存子程序调用和中断响应时的断点以及暂存数据或中间计算结果。 堆栈总是以字为单位存取 13.2 指令系统与寻址方式 指令系统 计算机提供给用户使用的机器指令集称为指令系统,大多数指令为双操作数指令。执行指令后,一般源操作数不变,目的操作数被计算结果替代。 机器指令由CPU 执行,完成某种运算或操作,8086/8088 指令系统中的指令分为6 类: 数据传送,算术运算,逻辑运算,串操作,控制转移和处理机控制。 寻址方式 寻址方式确定执行指令时获得操作数地址的方法 分为与数据有关的寻址方式(7 种)和与转移地址有关的寻址方式(4)种。 与数据有关的寻址方式的一般用途: (1) 立即数寻址方式–将常量赋给寄存器或存储单元(2) 直接寻址方式–存取单个变量(3) 寄存器寻址方式–访问寄存器的速度快于访问存储单元的速度(4) 寄存器间接寻址方式–访问数组元素(5) 变址寻址方式(6) 基址变址寻址方式(7) 相对基址变址寻址方式(5),(6),(7)都便于处理数组元素 . 与数据有关的寻址方式中,提供地址的寄存器只能是BX,SI,DI 或BP. 与转移地址有关的寻址方式的一般用途: (1) 段内直接寻址–段内直接转移或子程序调用(2) 段内间接寻址–段内间接转移或子程序调用(3) 段间直接寻址–段间直接转移或子程序调用(4) 段间间接寻址–段间间接转移或子程序调用 13.3 汇编程序和汇编语言 汇编程序 汇编程序是将汇编语言源程序翻译成二进制代码程序的语言处理程序,翻译的过程称为汇编。 汇编语言 汇编语言是用指令助记符,各种标识变量,地址,过程等的标识符书写程序的语言, 汇编语言指令与机器指令一一对应。 伪指令,宏指令不是由CPU 执行的指令,而是由汇编程序在汇编期间处理的指令。 伪指令指示汇编程序如何完成数据定义,存储空间分配,组织段等工作。 宏指令可简化程序并减少程序书写量。 条件汇编伪指令的功能是确定是否汇编某段源程序,而不是实现程序分支,对未汇编的程序将不产生相应的目标代码。 结构作为一种数据结构可将一组类型不同但有逻辑关联的数据组织在一起,便于整体处理数据。 记录可用于提高存储单元的利用率,将若干不足一个字节或字且有逻辑关联的信息压缩存放在一个字节或字中。 指令中的表达式在汇编期间计算,并且只能对常量或地址进行计算。 13.4 程序设计基础 分支程序设计 程序分支由条件转移指令或无条件转移指令实现 存放若干目的转移地址或跳转指令的跳转表常用于实现多路分支 条件转移指令只能实现偏移量为-128 至+127 字节范围的转移 无条件转移指令根据寻址方式可实现短转移(偏移量为-128 至+127 字节),段内转移,段间转移。 循环程序设计 可由循环控制指令或条件转移指令组织循环结构 内层循环结构必须完全包含在外层循环结构内,并不能发生从循环结构外向循环结构内的转移。 子程序设计 子程序中应保护寄存器内容,并正确使用堆栈, 成对执行PUSH 和POP 指令，保证执行RET指令时堆栈栈顶为返回地址。 主程序可通过寄存器,参数表,或堆栈传递参数给子程序 EXE 文件和COM 文件 二者都是可执行文件 COM 文件源程序的特点是: 第一条可执行指令的起始存放地址必须是100H,不能分段,不用定义堆栈,所有过程为NEAR 类型,直接用INT 20H 指令返回DOS。 DOS 功能调用与BIOS 中断调用 二者都是完成DOS 系统提供给用户的输入/输出等常用功能,通过执行软中断指令完成一次软中断服务。 DOS 功能调用的中断服务程序是操作系统的一部分,存于RAM 中; 而BIOS 中断调用的中断服务程序存放在ROM 中。 13.5 输入/输出与中断系统 输入/输出的方式 程序直接I/O 方式: 用IN 和OUT 指令直接在端口级上进行I/O 操作,数据传送方式分为无条件传送方式和查询传送方式。 中断传送方式: 由CPU 响应中断请求完成中断服务。 DMA 传送方式: 直接在存储器与外设之间传送数据。 有关中断的概念 中断、中断源、中断请求、中断服务、中断向量、中断向量表、中断响应过程、中断指令、开中断、关中断、内部中断、外部中断、可屏蔽中断、非屏蔽中断。 键盘I/O、显示器I/O 操作 键盘的输入操作用BIOS 的16H 中断调用控制,也可直接访问60H 端口(数据端口), 61H 端口(状态端口)检测键盘的按键操作。 对于特殊键（如Shift , Ctrl , Alt , NumLock , ScrollLock 等键）的按动情况，可以直接从来40:17H 单元取得有关信息。 显示器的图形显示可以用BIOS 的10H 中断调用实现,另一种速度更快的方法是直接读写视频缓冲区。 打印机I/O 操作由INT 17H 中断调用实现， 串行通讯口操作由INT 14H 中断调用实现。CLD Clear the direction flag (set to forward direction)将方向标志置0，使si 和di 增量，串处理从低地址向高地址处理 13.6 8088 汇编速查手册13.6.1 数据传输指令它们在存贮器和寄存器、寄存器和输入输出端口之间传送数据. 通用数据传送指令. 指令 描述 MOV 传送字或字节. MOVSX 先符号扩展,再传送. MOVZX 先零扩展,再传送. PUSH 把字压入堆栈. POP 把字弹出堆栈. PUSHA 把AX,CX,DX,BX,SP,BP,SI,DI 依次压入堆栈. POPA 把DI,SI,BP,SP,BX,DX,CX,AX 依次弹出堆栈. PUSHAD 把EAX,ECX,EDX, EBX,ESP,EBP,ESI,EDI 依次压入堆栈. POPAD 把EDI,ESI,EBP,ESP,EBX,EDX, ECX,EAX 依次弹出堆栈. BSWAP 交换32 位寄存器里字节的顺序 XCHG 交换字或字节.( 至少有一个操作数为寄存器,段寄存器不可作为操作数) CMPXCHG 比较并交换操作数.( 第二个操作数必须为累加器AL/AX/EAX ) XADD 先交换再累加.( 结果在第一个操作数里) XLAT 字节查表转换.── BX 指向一张256 字节的表的起点, AL 为表的索引值(0-255,即0-FFH); 返回AL 为查表结果. ( [BX+AL]-&gt;AL ) 输入输出端口传送指令. 指令 描述 IN I/O 端口输入. ( 语法: IN 累加器, {端口号│DX} ) OUT I/O 端口输出. ( 语法: OUT {端口号│DX},累加器) 输入输出端口由立即方式指定时, 其范围是0-255; 由寄存器DX 指定时,其范 围是0-65535. 目的地址传送指令. 指令 描述 例子 LEA 装入有效地址. 例: LEA DX,string ;把偏移地址存到DX. LDS 传送目标指针,把指针内容装入DS. 例: LDS SI,string ;把段地址:偏移地址存到DS:SI. LES 传送目标指针,把指针内容装入ES. 例: LES DI,string ;把段地址:偏移地址存到ES:DI. LFS 传送目标指针,把指针内容装入FS. 例: LFS DI,string ;把段地址:偏移地址存到FS:DI. LGS 传送目标指针,把指针内容装入GS. 例: LGS DI,string ;把段地址:偏移地址存到GS:DI. LSS 传送目标指针,把指针内容装入SS. 例: LSS DI,string ;把段地址:偏移地址存到SS:DI. 标志传送指令. 指令 描述 LAHF 标志寄存器传送,把标志装入AH. SAHF 标志寄存器传送,把AH 内容装入标志寄存器. PUSHF 标志入栈. POPF 标志出栈. PUSHD 32 位标志入栈. POPD 32 位标志出栈. 13.6.2 算术运算指令 指令 描述 ADD 加法. ADC 带进位加法. INC 加1. AAA 加法的ASCII 码调整. DAA 加法的十进制调整. SUB 减法. SBB 带借位减法. DEC 减1. NEC 求反(以0 减之). CMP 比较.(两操作数作减法,仅修改标志位,不回送结果). AAS 减法的ASCII 码调整. DAS 减法的十进制调整. MUL 无符号乘法. IMUL 整数乘法.以上两条,结果回送AH 和AL(字节运算),或DX 和AX(字运算), AAM 乘法的ASCII 码调整. DIV 无符号除法. IDIV 整数除法.以上两条,结果回送:商回送AL,余数回送AH, (字节运算);或商回送AX,余数回送DX, (字运算). AAD 除法的ASCII 码调整. CBW 字节转换为字. (把AL 中字节的符号扩展到AH 中去) CWD 字转换为双字. (把AX 中的字的符号扩展到DX 中去) CWDE 字转换为双字. (把AX 中的字符号扩展到EAX 中去) CDQ 双字扩展. (把EAX 中的字的符号扩展到EDX 中去) 13.6.3 逻辑运算指令 指令 描述 AND 与运算. OR 或运算. XOR 异或运算. NOT 取反. TEST 测试.(两操作数作与运算,仅修改标志位,不回送结果). SHL 逻辑左移. SAL 算术左移.(=SHL) SHR 逻辑右移. SAR 算术右移.(=SHR) ROL 循环左移. ROR 循环右移. RCL 通过进位的循环左移. RCR 通过进位的循环右移. 以上八种移位指令,其移位次数可达255 次.移位一次时, 可直接用操作码. 如SHL AX,1.移位&gt;1 次时, 则由寄存器CL 给出移位次数.如MOV CL,04SHL AX,CL 13.6.4 串指令 指令 描述 DS:SI 源串段寄存器:源串变址. ES:DI 目标串段寄存器:目标串变址. CX 重复次数计数器. AL/AX 扫描值. D 标志0 表示重复操作中SI 和DI 应自动增量; 1 表示应自动减量. Z 标志用来控制扫描或比较操作的结束. MOVS 串传送.( MOVSB 传送字符. MOVSW 传送字. MOVSD 传送双字. ) CMPS 串比较.( CMPSB 比较字符. CMPSW 比较字. ) SCAS 串扫描.把AL 或AX 的内容与目标串作比较,比较结果反映在标志位. LODS 装入串.把源串中的元素(字或字节)逐一装入AL 或AX 中.( LODSB 传送字符. LODSW 传送字. LODSD 传送双字. ) STOS 保存串. 是LODS 的逆过程. REP 当CX/ECX&lt;&gt;0 时重复. REPE/REPZ 当ZF=1 或比较结果相等,且CX/ECX&lt;&gt;0 时重复. REPNE/REPNZ 当ZF=0 或比较结果不相等,且CX/ECX&lt;&gt;0 时重复. REPC 当CF=1 且CX/ECX&lt; &gt;0 时重复. REPNC 当CF=0 且CX/ECX&lt;&gt;0 时重复. 13.6.5 程序转移指令 无条件转移指令(长转移) 指令 描述 JMP 无条件转移指令 CALL 过程调用 RET/RETF 过程返回. 条件转移指令(短转移,-128 到+127 的距离内)( 当且仅当(SF XOR OF)=1 时,OP1&lt;OP2 ) 指令 描述 JA/JNBE 不小于或不等于时转移. JAE/JNB 大于或等于转移. JB/JNAE 小于转移. JBE/JNA 小于或等于转移.以上四条,测试无符号整数运算的结果(标志C 和Z). JG/JNLE 大于转移. JGE/JNL 大于或等于转移. JL/JNGE 小于转移. JLE/JNG 小于或等于转移.以上四条,测试带符号整数运算的结果(标志S,O 和Z). JE/JZ 等于转移. JNE/JNZ 不等于时转移. JC 有进位时转移. JNC 无进位时转移. JNO 不溢出时转移. JNP/JPO 奇偶性为奇数时转移. JNS 符号位为”0” 时转移. JO 溢出转移. JP/JPE 奇偶性为偶数时转移. JS 符号位为”1” 时转移. 循环控制指令(短转移) 指令 描述 LOOP CX 不为零时循环. LOOPE/LOOPZ CX 不为零且标志Z=1 时循环. LOOPNE/LOOPNZ CX 不为零且标志Z=0 时循环. JCXZ CX 为零时转移. JECXZ ECX 为零时转移. 中断指令 指令 描述 INT 中断指令 INTO 溢出中断 IRET 中断返回 处理器控制指令 指令 描述 HLT 处理器暂停, 直到出现中断或复位信号才继续. WAIT 当芯片引线TEST 为高电平时使CPU 进入等待状态. ESC 转换到外处理器. LOCK 封锁总线. NOP 空操作. STC 置进位标志位. CLC 清进位标志位. CMC 进位标志取反. STD 置方向标志位. CLD 清方向标志位. STI 置中断允许位. CLI 清中断允许位. 13.6.6 伪指令 指令 描述 DW 定义字(2 字节). PROC 定义过程. ENDP 过程结束. SEGMENT 定义段. ASSUME 建立段寄存器寻址. ENDS 段结束. END 程序结束.","categories":[{"name":"理论","slug":"理论","permalink":"https://jeffup.github.io/categories/%E7%90%86%E8%AE%BA/"},{"name":"代码编程","slug":"理论/代码编程","permalink":"https://jeffup.github.io/categories/%E7%90%86%E8%AE%BA/%E4%BB%A3%E7%A0%81%E7%BC%96%E7%A8%8B/"}],"tags":[{"name":"汇编","slug":"汇编","permalink":"https://jeffup.github.io/tags/%E6%B1%87%E7%BC%96/"},{"name":"二进制","slug":"二进制","permalink":"https://jeffup.github.io/tags/%E4%BA%8C%E8%BF%9B%E5%88%B6/"}]},{"title":"网络流量分析（nogotofail））","slug":"网络流量分析-nogotofail","date":"2019-11-10T06:50:53.000Z","updated":"2019-11-17T01:25:52.050Z","comments":true,"path":"2019/11/10/网络流量分析-nogotofail/","link":"","permalink":"https://jeffup.github.io/2019/11/10/%E7%BD%91%E7%BB%9C%E6%B5%81%E9%87%8F%E5%88%86%E6%9E%90-nogotofail/","excerpt":"应用范围它包括对常见的SSL证书验证问题(HTTPS和TLS/SSL)的测试库bug、SSL和STARTTLS剥离问题、明文问题等等。","text":"应用范围它包括对常见的SSL证书验证问题(HTTPS和TLS/SSL)的测试库bug、SSL和STARTTLS剥离问题、明文问题等等。 应用到的库：psutil模块psutil是一个跨平台库能够轻松实现获取系统运行的进程和系统利用率（包括CPU、内存、磁盘、网络等）信息。它主要用来做系统监控，性能分析，进程管理。它实现了同等命令行工具提供的功能，如ps、top、lsof、netstat、ifconfig、who、df、kill、free、nice、ionice、iostat、iotop、uptime、pidof、tty、taskset、pmap等。目前支持32位和64位的Linux、Windows、OS X、FreeBSD和Sun Solaris等操作系统. 安装install psutil```123### 基本使用#### 获取CPU时间 psutil.cpu_times()scputimes(user=650613.02, nice=22.14, system=154916.5, idle=16702285.26, iowait=68894.55, irq=3.38, softirq=7075.65, steal=0.0, guest=0.0) ``` psutil.process_iter()遍历所有进程 psutil.version_info[] psutil.net_connections寻找连接(用户)的个数，在OSX中需要root权限 psutil.NoSuchProcess, psutil.AccessDenied 参考文章 https://www.cnblogs.com/lfs2640666960/p/9330735.html 介绍的不错 bash: 未预期的符号 `newline’ 附近有语法错误:将&lt;&gt;换成’’ 关于elk 安装yum install -y elasticsearch安装在/usr/share/elasticsearch当中，启动在bin当中的elasticsearch。用./Bin…来启动 测试运行：curl ‘http://localhost:9200/?pretty&#39; 会得到 Elasticsearch 的实例。 而一个 集群 是一组拥有相同 cluster.name 的节点， 他们能一起工作并共享数据，还提供容错与可伸缩性。(当然，一个单独的节点也可以组成一个集群) 你可以在 elasticsearch.yml 配置文件中 修改 cluster.name ，该文件会在节点启动时加载 (译者注：这个重启服务后才会生效)。 而elasticsearch中的.yml在/etc/elasticsearch当中 设置：logstash，netflow，配置 可以用端口9200，web客户端，甚至curl进行交互 curl -X ‘://:/?‘ -d ‘‘ 使用参考 会遇到问题：Exception in thread “main” org.elasticsearch.bootstrap.BootstrapException: java.nio.file.NoSuchFileException: /usr/share/elasticsearch/configLikely root cause: java.nio.file.NoSuchFileException: /usr/share/elasticsearch/config …解决方法其实就是： cp -r /etc/elasticsearch /usr/share/elasticsearch/config➜ ~ groupadd elsearch➜ ~ useradd elsearch -g elsearch -p elsearch➜ ~ cd /usr/share➜ chown -R elsearch:elsearch elasticsearch➜ su elsearch这是因为elasticsearch需要读写配置文件，我们需要给予config文件夹权限，上面新建了elsearch用户，elsearch用户不具备读写权限，因此还是会报错，解决方法是切换到管理员账户，赋予权限即可：sudo -ichmod -R 775 config这篇讲的很全 安装sense其实这个是Kibana的一个应用安装：yum install -y kibana测试运行也是一样的路径 http://localhost:5601/app/sense这个是emmm，测试？ 关于javaAPI交互节点客户端（Node client） 节点客户端作为一个非数据节点加入到本地集群中。换句话说，它本身不保存任何数据，但是它知道数据在集群中的哪个节点中，并且可以把请求转发到正确的节点。传输客户端（Transport client） 轻量级的传输客户端可以将请求发送到远程集群。它本身不加入集群，但是它可以将请求转发到集群中的一个节点上。两个 Java 客户端都是通过 9300 端口并使用 Elasticsearch 的原生 传输 协议和集群交互。集群中的节点通过端口 9300 彼此通信。如果这个端口没有打开，节点将无法形成一个集群。 安装elasticsearch-head遇到的问题 warning: notsup SKIPPING OPTIONAL DEPENDENCY: Unsupported platform for fsevents@1.2.4: wanted {“os”这个证明已经安装成功了 npm WARN elasticsearch-head@0.0.0 license should be a valid SPDX license expression这个说你的license不对口，得去找找spdx licence是个啥玩意：既然知道spdx是个啥，就不难解决问题了；让我打开正确的姿势：打开elasticsearch-head目录下的package.json文件，找到license位置，修改为上面这个网站上存在Identifier，就可以了。如图所示，把原来的Apache内容修改为Apache-2.0。具体修改后的内容参考官网上的Identifier数值（防止后续更新，授之于渔了）。 成功！ 妈的，又不成功：This account is currently not available（用户当前不可用）安装完elasticsearch之后系统会自动创建一个elasticsearch用户，在启动elasticsearch的时候需要切换该用户启动，但是在我切换到elasticsearch用户的时候显示This account is currently not available。 查资料发现是因为该用户的shell不可用，查看/etc/passwd文件发现此用户的shell是/sbin/nologin需修改成/bin/bash elasticsearch-head中cluster health: not connected修改elasticsearch安装目录中 config/elasticsearch.ymlhttp.cors.enabled: truehttp.cors.allow-origin: “*”修改elasticsearch-head下Gruntfile.jsconnect: {server: {options: {hostname: ‘0.0.0.0’,port: 9100,base: ‘.’,keepalive: true}}}原文链接","categories":[{"name":"理论","slug":"理论","permalink":"https://jeffup.github.io/categories/%E7%90%86%E8%AE%BA/"}],"tags":[{"name":"python","slug":"python","permalink":"https://jeffup.github.io/tags/python/"},{"name":"网络流量","slug":"网络流量","permalink":"https://jeffup.github.io/tags/%E7%BD%91%E7%BB%9C%E6%B5%81%E9%87%8F/"}]},{"title":"算法实验","slug":"算法实验","date":"2019-11-10T03:05:40.000Z","updated":"2019-11-20T01:26:41.435Z","comments":true,"path":"2019/11/10/算法实验/","link":"","permalink":"https://jeffup.github.io/2019/11/10/%E7%AE%97%E6%B3%95%E5%AE%9E%E9%AA%8C/","excerpt":"简介：包括线性时间算法，最长递增子序列，以斐波那契堆实现迪杰斯特拉算法","text":"简介：包括线性时间算法，最长递增子序列，以斐波那契堆实现迪杰斯特拉算法 1. 线性时间选择（序数问题） 问题描述：已知n个数，找出排序后第k小的数。要求平均时间复杂度为O(n)。 解决思路：使用快速排序的思想解决查找问题，用随机数（舍伍德算法）解决基准问题，用分治策略搭建整体的算法结构。 步骤分析：(1) 使用舍伍德算法选择基准r（第r个数）(2) 用快速排序算法进行下面的操作：将大于基准的数值放于基准后，将小于基准的数值放于基准前，刷新数组的排序。(3) 若想要查找的第k个数值的k比基准r大，则取数组的右边再重复进行以上操作，若小于，则选择左边的，若等于，则输出。 示例： 示例分析：输入10个数，分别为5 2 7 8 9 0 1 3 4 6，第5小的元素为4，验证成功。 2. 最长递增子序列问题 问题描述：寻找最长递增的序列。 解决思路：利用矩阵记录之前的结果，用动态规划法完成寻找 算法步骤：(1) 设置变量有：存储当前最长序列的值的数组tempmax，存储最长序列长度maxlen存储最长序列的最大值下标maxindex(2) 从下标为1的值开始遍历(3) 若i下标下的值比前一个值大，则更新tempmax[i]=tempmax[i-1]+1，即增加长度1，若此时的tempmaxp[i]比maxlen大，则更新maxlen，且更新maxindex=1 示例：示例分析： 输入10个数分别为1 3 2 4 5 3 7 8 9 6，其最长递增子序列为3 7 8 9，长度为4，验证成功。 3. 斐波那契堆实现最短路径算法（迪杰斯特拉） 问题描述：用斐波那契堆取最小路径辅助迪杰斯特拉算法实现最小路径算法 解决思路：1. 使用贪心算法实现迪杰斯特拉最短路径算法，使用斐波那契堆建立最小堆，方便取最小‘结点’以完成接下来的操作 算法思想： 迪杰斯特拉伪代码： 123456789DIJKSTRA(G, w, s)INITIALIZE - SINGLE - SOURCE(G, s)S ← ØQ ← V[G] //第3行，INSERT操作，O（1）构造堆while Q ≠ Ø do u ← EXTRACT - MIN(Q) //第5行，从堆中取出最小点 S ← S ∪&#123; u &#125; for each vertex v ∈ Adj[u] do RELAX(u, v, w) //第8行，RELAX操作，对堆进行降级工作 其中在第5行的EXTRACT-MIN操作用斐波那契堆实现，斐波那契堆结构如下: 斐波那契堆是由一组最小堆有序树构成的。每个节点的度数为其子节点的数目。树的度数为其根节点的度数。 斐波那契堆中的树都是有根的但是无序。每个节点x包含指向父节点的指针p[x]和指向任意一个子结点的child[x]。x的所有子节点都用双向循环链表链接起来，叫做x的子链表。子链表中的每一个节点y都有指向它的左兄弟的left[y]和右兄弟的right[y]。如果节点y是x仅有的子节点，则left[y]=right[y]=y。 斐波那契堆中所有树的根节点也用一个双向循环链表链接起来。使用一个指针指向斐波那契堆中最小元素。 用稀疏矩阵表示图，定义为weight 具体实现示例分析： 其矩阵如： {0,4,NoEdge,2,NoEdge}, {4,0,4,1,NoEdge}, {NoEdge,4,0,1,3}, {2,1,1,0,7},{NoEdge,NoEdge,3,7,0}最终应该得到结果：a-&gt;a=0a-&gt;d-&gt;b=3a-&gt;d-&gt;c=3a-&gt;d=2a-&gt;d-&gt;c-&gt;e=6 测试成功！","categories":[{"name":"代码编程","slug":"代码编程","permalink":"https://jeffup.github.io/categories/%E4%BB%A3%E7%A0%81%E7%BC%96%E7%A8%8B/"}],"tags":[{"name":"课程","slug":"课程","permalink":"https://jeffup.github.io/tags/%E8%AF%BE%E7%A8%8B/"},{"name":"算法","slug":"算法","permalink":"https://jeffup.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"C++","slug":"C","permalink":"https://jeffup.github.io/tags/C/"}]},{"title":"Hello World","slug":"hello-world","date":"2019-11-10T02:19:20.246Z","updated":"2019-11-11T06:13:02.844Z","comments":true,"path":"2019/11/10/hello-world/","link":"","permalink":"https://jeffup.github.io/2019/11/10/hello-world/","excerpt":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. HEXO常用：新建文章1$ hexo new \"My New Post\" More info: Writing 启动本地镜像服务1$ hexo server More info: Server 生成静态文件1$ hexo generate More info: Generating 上传文件（同步）12$ hexo deploy$ hexo d 也可 More info: Deployment 常要注意的玩意：hexo图片问题hexo阅读更多1npm install hexo-generator-index2 --save 12345678# index2 generator是否包含官方的hexo-generator-index，默认true（包含）index2_include_index: trueindex2_generator: per_page: 8 order_by: -date # 按发布时间排序 exclude: - tag hide # 不包含标签为hide的文章 - category hide # 不包含分类为hide的文章 然后 博客设置问题：头像&amp;图标：在主题目录下配置文件中.头像： 12345author: name: DuK work: Study,0-1 location: China avatar_url: /images/avatar.png 而其图标： 1favicon: /images/favicon.ico 网站：图标制作 侧边栏目（标签，归档）得先进行 1hexo new page tags 然后才会有，这里tags还要加上： 12345---title: tagsdate: 2019-11-10 11:36:27layout: tags---","categories":[],"tags":[{"name":"配置","slug":"配置","permalink":"https://jeffup.github.io/tags/%E9%85%8D%E7%BD%AE/"},{"name":"博客","slug":"博客","permalink":"https://jeffup.github.io/tags/%E5%8D%9A%E5%AE%A2/"},{"name":"指令","slug":"指令","permalink":"https://jeffup.github.io/tags/%E6%8C%87%E4%BB%A4/"}]}]}