{"meta":{"title":"DuK_Blogs","subtitle":"","description":"","author":"DuK","url":"https://jeffup.github.io","root":"/"},"pages":[{"title":"about","date":"2019-11-10T03:36:04.000Z","updated":"2019-11-10T03:36:04.773Z","comments":true,"path":"about/index.html","permalink":"https://jeffup.github.io/about/index.html","excerpt":"","text":""},{"title":"archives","date":"2019-11-10T03:36:47.000Z","updated":"2019-11-10T03:36:47.668Z","comments":true,"path":"archives/index.html","permalink":"https://jeffup.github.io/archives/index.html","excerpt":"","text":""},{"title":"tags","date":"2019-11-10T03:36:27.000Z","updated":"2019-11-10T05:41:08.515Z","comments":true,"path":"tags/index.html","permalink":"https://jeffup.github.io/tags/index.html","excerpt":"","text":""},{"title":"search","date":"2019-11-10T04:00:01.000Z","updated":"2019-11-10T04:00:01.331Z","comments":true,"path":"search/index.html","permalink":"https://jeffup.github.io/search/index.html","excerpt":"","text":""}],"posts":[{"title":"工具OllyDbg的使用","slug":"工具OllyDbg的使用","date":"2019-11-10T08:08:12.000Z","updated":"2019-11-10T08:08:12.507Z","comments":true,"path":"2019/11/10/工具OllyDbg的使用/","link":"","permalink":"https://jeffup.github.io/2019/11/10/%E5%B7%A5%E5%85%B7OllyDbg%E7%9A%84%E4%BD%BF%E7%94%A8/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"汇编语言(入门学习)","slug":"汇编语言-入门学习","date":"2019-11-10T06:57:39.000Z","updated":"2019-11-14T12:23:04.239Z","comments":true,"path":"2019/11/10/汇编语言-入门学习/","link":"","permalink":"https://jeffup.github.io/2019/11/10/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80-%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0/","excerpt":"简介：本篇旨在对汇编的基础知识进行汇总，汇总的都是要点（简明扼要），目前还在更新中。","text":"简介：本篇旨在对汇编的基础知识进行汇总，汇总的都是要点（简明扼要），目前还在更新中。 第一章 基础知识1.1 存储单元一个存储单元存储的信息量以bit为单位（最小）。而转换关系中8 bit=1 bytes(B)。而一个字=两个字节在微型计算机存储器的存储单元中，一个单元可以存1 B（即8个进制位）。而一个存储器有128个单元，则可以存储128 B。 1.2 CPU对存储器的读写要读写，则应该与三类信息进行交互： 地址信息 控制信息 数据信息 而逻辑上又分为3类总线，分别传输信息： 地址总线（指出内存中的信息放在那里(自下而上读01)） 控制总线（若要传输的数据多于一次性传输的宽度，则分开来多传几次） 数据总线 1.2.1 影响性能的因素：宽度（线的条数）：它决定了部件的能力（速度，控制能力等）。8086为16条，8088为8条 若CPU的寻址能力为8KB，则总线宽度：8*1024/1 = 2**13 (注意单位是B,13则为总线宽度) 第二章 寄存器2.1 通用寄存器有AX BX CX DX四种，它们分为高位和低位以兼容以前的程序，如（AX = AH(高) + AL(低)）要注意的是：若只用AL进行运算，若超出其范围，超出的数据不会到AH当中！ 2.2 CPU给出物理地址的方法 段地址(SA)：只是为了内存的管理，并不是真分段。16位地址分段，一段64KB偏移地址(EA)：16位地址最多64KB公式：物理地址=段地址*16+偏移地址 2.2 段寄存器有CS DS SS ES四种。CS常存储段地址。它们提供了一下功能： CS：CPU要执行指令的地址。相当于命令指针 DS：读取内存的地址（返回数据）。相当于数据指针 SS：存储内存中的栈的顶。相当于栈顶指针 2.2.1 CS和IPIP是存储基于CS的偏移量。修改的流程： 一般流程：读取指令 -&gt; 修改 IP+=命令长度 -&gt; 执行指令(可能会涉及修改CS:IP) -&gt; 读取指令…8086PC启动时在FFFF0H单元中读取指令执行 2.3 疑问1. 为什么偏移地址只能在64Kb内？一个16位的CPU，只能有1111 1111 1111 1111，代表了4个16进制数，所以能表示2**16 bit的数据，恰好，就是64Kb。 2.暂留第三章 寄存器（内存访问）3.1 内存中字的存储 字单元的概念：即存放一个字型数据的内存单元，由两个地址连续的内存单元（一个8位）组成。高放高位，低放低位。 这里解释一下： 若有单元[0]-&gt;2e，[1]-&gt;33，那么我们读[0]的字型数据为：332eH（高放高位） 3.2 DS和[address] “[…]”表示一个内存单元，表示在段地址下的偏移量。如10000H = 1000:0 = [0] 在masm汇编编辑器中，如果单纯写mov ax,[0]，那么他会把[0]当做0来解释，即指令变成：mov ax,0而若用bx作为中转，那是可以的！如： 12mov bx,0mov ax,[bx] 这个是可以把[bx]当成段地址，返回ds:bx下的数据的！而如果偏要用[idata]的话，那么就必须加上ds:前缀，如： 1mov ax,ds:[0] 而对于Debug编译器的话，ds是自动加上的，用 1mov ax,[0] 即可，如果使用[]的话，而且他（段寄存器）是不能直接用mov命令改变的，必须通过其他的寄存器中转才能改变。 3.3 字的传送（mov指令）在传送字之后， DS和[address]也会跟着变，如1000:0，若传入一个fffeH，则address会从0-&gt;2，此时，[0]存有feH，[1]存有ffH,[2]为空。 3.4 mov、add、sub指令主要是说说置零问题，与机械码长度问题，稍微提一下，以后会细讲。举例子： 12sub bx, bxmov bx, 0 两个都是可以将bx寄存器置零的指令，但是sub的机械码长度为2，而mov为3，用sub更好。另外说说jmp指令，他是转移指令，具有一个操作对象的指令，而上面的具有两个。 3.5 栈他是一个FILO结构（先入后出），而且是从大变小（地址）。 3.5.1 push和pop 执行push ax命令，会把ax中的数据传入ss:sp指向的地址空间。此时sp-=2执行pop ax命令，会把ss:sp指向的地址空间中的数据传给ax。此时sp+=2 执行之后的指针变化： push先令sp-=2，然后将ax中的数据放进去。称为出栈。 pop是先取出数据放到ax中，再sp+=2。称为入栈。 3.5.2 数据传输如8086cpu的入栈和出栈都是以字为单位进行的。 3.5.3 栈指针上面已经用到了：段寄存器:寄存器存储(ss:sp)sp是指偏移地址，ss:sp始终指向栈顶。 3.6 栈顶越界问题栈溢出问题都是大问题，如果栈顶越界了，那么执行push和pop会受影响吗？当然不会！直接刚，写！写！写！出！出！出！管你呢。所以就会有可能读了其他程序的数据，或者修改了（覆盖）其他程序的数据（直接崩溃的说）执行情况（取自《汇编语言第二版》王爽著） 3.7 问题1.程序与数据有区别吗？可以说有，也可以说没有。由于指令都是0和1组成的，只是用不同功能的段地址读出来的不一样，如,CS和DS都指向10000H，那么，CS会将里头的数据转化为机械码，执行指令，而DS就直接读数据，作为单纯的数据使用。 2.空栈如（10000H~1000FH）此时ss=1000H，那么sp是多少？因为是自下而上（自大到小），所以sp=0010H。换一种方式看，若存储了一个数据，则一个存到000EH，一个存到000FH，此时的栈指针在栈顶，当然指向000EH了，此时是已经让sp-=2了，那么回溯一下，不就有sp=0010H了。 好了，问题来了，如果将（10000H~1FFFFH）作为空间呢？答案：sp=0000H，因为，不能变成10000H(笑) 3.栈会溢出，那么，为什么不设置栈大小emmm，可惜8086cpu就是没有，所以变成自己注意。 4.只有mov可以完成传输数据吗？push也可以哦，只要把sp定位为ds:[address]那就好了哦。直接写进去。 第四章 第一个程序4.1 一个源程序从写出到执行的过程如图：执行过程包括：写程序-&gt;编译连接成可执行文件-&gt;执行。 可执行文件文件中包括以下两部分： 程序和数据 相关的描述：程序多大，占用多少运行空间 4.2 源程序4.2.1 伪指令也就是只能被编译器识别的指令，如assume、segment、end等，这是没有机械码的。一般的伪指令使用如下： 12345assume cs:code #声明（假设）cs:段名（标号）code segment #段名 segment_指令_code ends #对应segment，表示一个段结束end #对应assume，表示程序结束 4.2.2 程序返回现在考虑，如何让上一个程序把CPU控制权交给写一个程序，这时候就要使用程序返回其代码如下： 12mov ax, 4c00Hint 21H 4.3 程序生成流程编程 -&gt; 1.asm -&gt; 编译 -&gt; 1.obj -&gt; 连接 -&gt; 1.exe -&gt; 加载 -&gt; 内存中的程序 -&gt; 运行注：加载就是将程序加载到内存，执行就是在内存中执行程序的指令 4.4 怎么装载程序？操作系统是一个模块组成庞大的系统。任何通用的系统都要提供一个称为shell的程序，用户使用这个程序来操作计算机系统进行工作。 如DOS中有一个程序command.com，这个程序称为：命令解释器，也就是DOS中的SHELL（其实跟我们的cmd.exe差不多） 先运行shell，然后在加载1.exe可执行程序的时候，cmd会自动把cpu的控制权交给1.exe，执行完成再返回cmd。 4.4 展示EXE的加载过程 第五章 [BX]和loop指令5.1 [BX]这个之前就讲过：其实就是把BX中的值作为ds的偏移地址EA，然后可以用这个来访问特定地址下的数据。如ds:1000H，bx=0001H，那么[BX]就是指ds*16+bx下的值。 5.2 loop直接上程序： 12345678assume cs:eloopeloop segment mov ax,128 mov cx,36 s:add ax,ax loop seloop endsend 解释： loop是按照cx当中的值进行对有标号的s下的命令进行循环的。当cx不等于0，则执行循环，这个程序实际上是实现128*36的程序。 s实际上是IP值，指向s标记的地址，所以loop s实际上是给IP赋值：IP=s，然后就可以通过cs:ip来执行指令了 注意：汇编程序中，数据不能以字母开头，所以要在前面加个0。比如：9138h可以写成9138h，而A000h就必须写成0A000h 5.3 loop和[bx]的联合运用例如来一个如同C++语言中的： 123456int dx = 0;int ds[12] = &#123;1, 2, ...&#125;;for(int i=0; i &lt; 12; i++)&#123; dx += ds[i];&#125; 那么汇编语言就有： 123456789101112131415161718192021assume cs:codecode segment: mov ax, 0ffffh ;因为ds寄存器不能直接赋值，所以用ax作为中间变量 mov ds,ax mov bx,0 ;初始化ds:bx指向ffff:0 mov dx,0 ;初始化**累加寄存器**dx，让值为0 mov cx,12 ;初始化循环计数寄存器cx，令值为12，指循环12次 s: mov al,[bx] ;以下两步执行ax的赋值操作 mov ah,0 ; add dx,ax ;执行加法 inc bx ;ds:bx指向下一个单元，因为bx的值增加了1，相当于C++代码中的*i++* loop s ;loop完成一次，则cx=cx-1，然后判断cx是否等于0，如果等于则退出循环 mov ax,4c00h int 21hcode endsend 好了，现在来说说这段代码里面有什么需要注意的点： cx寄存器一般用作loop循环的判断条件，即循环的粗次数。 ax寄存器的初始化有两步，是，因为一个字符型数据是8位这样的话转化为16位就得让高8位的值赋为0。 dx寄存器是常用的累加寄存器。 inc指令是让后面的值加一的指令，相当于C++语言中的‘++’自增。 int指令： 由int 指令引发的中断是一种重要的内中断。格式： int n //相当于引发一个n号中断的过程,最终功能和call指令相似，都是调用一段程序。 取中断类型码n 标志寄存器入栈，并IF=0,TF=0 //TF=0使得避免中断程序执行过程中引发单步中断 CS,IP寄存器入栈 IP=(n4) , CS=(n4 + 2)原文链接 5.4 段前缀与其使用 能够显示地指令内存单元的段地址的，如：”ds:”、”cs:”、”ss:”、”es:”。这就是段前缀。 默认的[x]是指：(dx*16)+x，而如果要用其他的段寄存器，则需要加上它的段前缀。 第六章 包含多个段的程序 由于软件是由数据和程序组成的，数据当然也是程序里面必不可少的部分，所以会将代码分为多段进行，如数据段、代码段等。 6.1 在代码段中使用数据 汇编程序若没有特殊的说明（或者注明在哪里开始），则默认从头开始！所以，一旦你的程序头部有数据，则将会把头部的数据翻译为机器码执行。(冤) 那么解决方式是：在开始执行代码的地方加上 start: 1234567891011121314151617181920212223assume cs:codecode segment dw 0123h,0456h,0789h ;这里是数据部分 dw意思是定义字符型数据 start: mov bx,0 ;注意，从这开始，标识为start! mov ax,0 mov cx,8 s: add ax,cs:[bx] ;用cs作为段地址，取数据！ add bx,2 loop s mov ax,4c00h int 2hcode endsend start ;注意end后面要加上end开始的名称！``` ## 6.2 将数据、代码、栈放入不同的段上面说了，代码从哪里开始就在哪里加上**start**，结束就用**end start**（其他标识也行）好，记住，那是代码，别把接下来说的混淆了。不同的段可以放不同的东西，例如数据，代码等等。只要记住将段名end了再定义其他段。也只有定义了，才能使用这个段 assume cs:b,ds:a,ss:c a segment dw 0123h, 0456h, 0789h, 0abch, 0de fh, Ofedh, 0cbah, 0987h a ends c segment dw 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 c ends b segment d: mov ax,c ;使用段c中的数据 mov ss,ax mov sp, 20h ;希望用c段当作栈空间，设置ss:sp指向c:20 mov ax,a ;使用段a mov ds,ax ;希望用ds:bx访问a段中的数据，ds指向a段 mov bx,0 ;ds:bx指向a段中的第一一个单元 mov Cx,8 s: push [bx] add bx,2 1oop s ;以上将a段中的0~15单元中的8个字型数据依次入栈 mov bx,0 mov cx, B s0: pop [bx] add bx,2 1oop s0 ;以上依次出栈8个字型数据到a段的0~15单元中 mov ax, 4c00hint 21h b ends end d ;d处是要执行的第一- 条指令，即程序的入口``` 第七章 更灵活的定位内存地址的方法","categories":[{"name":"理论","slug":"理论","permalink":"https://jeffup.github.io/categories/%E7%90%86%E8%AE%BA/"},{"name":"代码编程","slug":"理论/代码编程","permalink":"https://jeffup.github.io/categories/%E7%90%86%E8%AE%BA/%E4%BB%A3%E7%A0%81%E7%BC%96%E7%A8%8B/"}],"tags":[{"name":"汇编","slug":"汇编","permalink":"https://jeffup.github.io/tags/%E6%B1%87%E7%BC%96/"},{"name":"二进制","slug":"二进制","permalink":"https://jeffup.github.io/tags/%E4%BA%8C%E8%BF%9B%E5%88%B6/"}]},{"title":"网络流量分析（nogotofail））","slug":"网络流量分析-nogotofail","date":"2019-11-10T06:50:53.000Z","updated":"2019-11-11T07:34:14.989Z","comments":true,"path":"2019/11/10/网络流量分析-nogotofail/","link":"","permalink":"https://jeffup.github.io/2019/11/10/%E7%BD%91%E7%BB%9C%E6%B5%81%E9%87%8F%E5%88%86%E6%9E%90-nogotofail/","excerpt":"应用范围它包括对常见的SSL证书验证问题(HTTPS和TLS/SSL)的测试库bug、SSL和STARTTLS剥离问题、明文问题等等。","text":"应用范围它包括对常见的SSL证书验证问题(HTTPS和TLS/SSL)的测试库bug、SSL和STARTTLS剥离问题、明文问题等等。 应用到的库：psutil模块psutil是一个跨平台库能够轻松实现获取系统运行的进程和系统利用率（包括CPU、内存、磁盘、网络等）信息。它主要用来做系统监控，性能分析，进程管理。它实现了同等命令行工具提供的功能，如ps、top、lsof、netstat、ifconfig、who、df、kill、free、nice、ionice、iostat、iotop、uptime、pidof、tty、taskset、pmap等。目前支持32位和64位的Linux、Windows、OS X、FreeBSD和Sun Solaris等操作系统. 安装install psutil```123### 基本使用#### 获取CPU时间 psutil.cpu_times()scputimes(user=650613.02, nice=22.14, system=154916.5, idle=16702285.26, iowait=68894.55, irq=3.38, softirq=7075.65, steal=0.0, guest=0.0) ``` psutil.process_iter()遍历所有进程 psutil.version_info[] psutil.net_connections寻找连接(用户)的个数，在OSX中需要root权限 psutil.NoSuchProcess, psutil.AccessDenied 参考文章","categories":[{"name":"理论","slug":"理论","permalink":"https://jeffup.github.io/categories/%E7%90%86%E8%AE%BA/"}],"tags":[{"name":"网络流量","slug":"网络流量","permalink":"https://jeffup.github.io/tags/%E7%BD%91%E7%BB%9C%E6%B5%81%E9%87%8F/"},{"name":"python","slug":"python","permalink":"https://jeffup.github.io/tags/python/"}]},{"title":"算法实验","slug":"算法实验","date":"2019-11-10T03:05:40.000Z","updated":"2019-11-11T06:15:04.604Z","comments":true,"path":"2019/11/10/算法实验/","link":"","permalink":"https://jeffup.github.io/2019/11/10/%E7%AE%97%E6%B3%95%E5%AE%9E%E9%AA%8C/","excerpt":"简介：包括线性时间算法，最长递增子序列，以斐波那契堆实现迪杰斯特拉算法","text":"简介：包括线性时间算法，最长递增子序列，以斐波那契堆实现迪杰斯特拉算法 1. 线性时间选择（序数问题） 问题描述：已知n个数，找出排序后第k小的数。要求平均时间复杂度为O(n)。 解决思路：使用快速排序的思想解决查找问题，用随机数（舍伍德算法）解决基准问题，用分治策略搭建整体的算法结构。 步骤分析：(1) 使用舍伍德算法选择基准r（第r个数）(2) 用快速排序算法进行下面的操作：将大于基准的数值放于基准后，将小于基准的数值放于基准前，刷新数组的排序。(3) 若想要查找的第k个数值的k比基准r大，则取数组的右边再重复进行以上操作，若小于，则选择左边的，若等于，则输出。 示例： 示例分析：输入10个数，分别为5 2 7 8 9 0 1 3 4 6，第5小的元素为4，验证成功。 2. 最长递增子序列问题 问题描述：寻找最长递增的序列。 解决思路：利用矩阵记录之前的结果，用动态规划法完成寻找 算法步骤：(1) 设置变量有：存储当前最长序列的值的数组tempmax，存储最长序列长度maxlen存储最长序列的最大值下标maxindex(2) 从下标为1的值开始遍历(3) 若i下标下的值比前一个值大，则更新tempmax[i]=tempmax[i-1]+1，即增加长度1，若此时的tempmaxp[i]比maxlen大，则更新maxlen，且更新maxindex=1 示例：示例分析： 输入10个数分别为1 3 2 4 5 3 7 8 9 6，其最长递增子序列为3 7 8 9，长度为4，验证成功。 3. 斐波那契堆实现最短路径算法（迪杰斯特拉） 问题描述：用斐波那契堆取最小路径辅助迪杰斯特拉算法实现最小路径算法 解决思路：1. 使用贪心算法实现迪杰斯特拉最短路径算法，使用斐波那契堆建立最小堆，方便取最小‘结点’以完成接下来的操作 算法思想： 迪杰斯特拉伪代码： 123456789DIJKSTRA(G, w, s)INITIALIZE - SINGLE - SOURCE(G, s)S ← ØQ ← V[G] //第3行，INSERT操作，O（1）构造堆while Q ≠ Ø do u ← EXTRACT - MIN(Q) //第5行，从堆中取出最小点 S ← S ∪&#123; u &#125; for each vertex v ∈ Adj[u] do RELAX(u, v, w) //第8行，RELAX操作，对堆进行降级工作 其中在第5行的EXTRACT-MIN操作用斐波那契堆实现，斐波那契堆结构如下: 斐波那契堆是由一组最小堆有序树构成的。每个节点的度数为其子节点的数目。树的度数为其根节点的度数。 斐波那契堆中的树都是有根的但是无序。每个节点x包含指向父节点的指针p[x]和指向任意一个子结点的child[x]。x的所有子节点都用双向循环链表链接起来，叫做x的子链表。子链表中的每一个节点y都有指向它的左兄弟的left[y]和右兄弟的right[y]。如果节点y是x仅有的子节点，则left[y]=right[y]=y。 斐波那契堆中所有树的根节点也用一个双向循环链表链接起来。使用一个指针指向斐波那契堆中最小元素。 用稀疏矩阵表示图，定义为weight 具体实现示例分析： 其矩阵如： {0,4,NoEdge,2,NoEdge}, {4,0,4,1,NoEdge}, {NoEdge,4,0,1,3}, {2,1,1,0,7},{NoEdge,NoEdge,3,7,0}最终应该得到结果：a-&gt;a=0a-&gt;d-&gt;b=3a-&gt;d-&gt;c=3a-&gt;d=2a-&gt;d-&gt;c-&gt;e=6 测试成功！","categories":[{"name":"代码编程","slug":"代码编程","permalink":"https://jeffup.github.io/categories/%E4%BB%A3%E7%A0%81%E7%BC%96%E7%A8%8B/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://jeffup.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"C++","slug":"C","permalink":"https://jeffup.github.io/tags/C/"}]},{"title":"Hello World","slug":"hello-world","date":"2019-11-10T02:19:20.246Z","updated":"2019-11-11T06:13:02.844Z","comments":true,"path":"2019/11/10/hello-world/","link":"","permalink":"https://jeffup.github.io/2019/11/10/hello-world/","excerpt":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. HEXO常用：新建文章1$ hexo new \"My New Post\" More info: Writing 启动本地镜像服务1$ hexo server More info: Server 生成静态文件1$ hexo generate More info: Generating 上传文件（同步）12$ hexo deploy$ hexo d 也可 More info: Deployment 常要注意的玩意：hexo图片问题hexo阅读更多1npm install hexo-generator-index2 --save 12345678# index2 generator是否包含官方的hexo-generator-index，默认true（包含）index2_include_index: trueindex2_generator: per_page: 8 order_by: -date # 按发布时间排序 exclude: - tag hide # 不包含标签为hide的文章 - category hide # 不包含分类为hide的文章 然后 博客设置问题：头像&amp;图标：在主题目录下配置文件中.头像： 12345author: name: DuK work: Study,0-1 location: China avatar_url: /images/avatar.png 而其图标： 1favicon: /images/favicon.ico 网站：图标制作 侧边栏目（标签，归档）得先进行 1hexo new page tags 然后才会有，这里tags还要加上： 12345---title: tagsdate: 2019-11-10 11:36:27layout: tags---","categories":[],"tags":[{"name":"配置","slug":"配置","permalink":"https://jeffup.github.io/tags/%E9%85%8D%E7%BD%AE/"},{"name":"博客","slug":"博客","permalink":"https://jeffup.github.io/tags/%E5%8D%9A%E5%AE%A2/"},{"name":"指令","slug":"指令","permalink":"https://jeffup.github.io/tags/%E6%8C%87%E4%BB%A4/"}]}]}