{"meta":{"title":"DuK_Blogs","subtitle":"","description":"","author":"DuK","url":"https://jeffup.github.io","root":"/"},"pages":[{"title":"about","date":"2019-11-10T03:36:04.000Z","updated":"2019-11-10T03:36:04.773Z","comments":true,"path":"about/index.html","permalink":"https://jeffup.github.io/about/index.html","excerpt":"","text":""},{"title":"search","date":"2019-11-10T04:00:01.000Z","updated":"2019-11-10T04:00:01.331Z","comments":true,"path":"search/index.html","permalink":"https://jeffup.github.io/search/index.html","excerpt":"","text":""},{"title":"tags","date":"2019-11-10T03:36:27.000Z","updated":"2019-11-10T05:41:08.515Z","comments":true,"path":"tags/index.html","permalink":"https://jeffup.github.io/tags/index.html","excerpt":"","text":""},{"title":"archives","date":"2019-11-10T03:36:47.000Z","updated":"2019-11-10T03:36:47.668Z","comments":true,"path":"archives/index.html","permalink":"https://jeffup.github.io/archives/index.html","excerpt":"","text":""}],"posts":[{"title":"JavaScript基础知识","slug":"JavaScript基础知识","date":"2019-11-24T12:04:49.000Z","updated":"2019-11-24T12:08:01.465Z","comments":true,"path":"2019/11/24/JavaScript基础知识/","link":"","permalink":"https://jeffup.github.io/2019/11/24/JavaScript%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/","excerpt":"JavaScript的基本知识一、在html中的使用","text":"JavaScript的基本知识一、在html中的使用 1.1 在页面中直接嵌入JavaScript1234567891011&lt;!doctype html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=\"utf-8\"&gt;&lt;script language=\"javascript\"&gt; alert(1)&lt;/script&gt;&lt;/head&gt;&lt;/html&gt; 执行后会直接弹出框。 1.2 script标签常用的属性和说明 属性 说明 language 设置所使用的的脚本语言及版本 src 设置一个外部文件的路径位置 type 设置所使用的脚本语言，此属性已经代替language defer 此属性表示当html文档加载完毕之后再执行脚本语言 1.3 外部调用 使用src调用js文件（外部js文件不需要用括起来） 使用函数调用本文档中的script函数如：1&lt;input onclick=&quot;myjsFun()&quot; /&gt; 二、基础2.1 变量2.1.1 变量类型有很多，基本的都有，如果想表达十六进制，则在数据之前加上0x即可。然而JavaScript是无类型语言，所以，声明变量直接用var即可 2.1.2 未定义值和空值 空值（null）不是0也不是空的字符串 一个值是空值表示已经赋过值，而未定义（undefined）表示没有赋值，两者不一样。 2.2 运算符和表达式2.2.1 比较运算符只挑一些讲 运算符 描述 示例 == 等于，只涉及表面值的判断，不涉及数据类型 “17”==17 return true === 绝对等于，同时涉及表面值和数据类型的判断 “17”==17 return false 注：这个在php中也适用。而不等于分别是!= 和!== 2.2.2 条件运算符 操作数？结果1：结果2 这个跟C++一样啊？这里来个九九乘法表练习！ 1234567891011121314151617181920212223&lt;!doctype html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=\"utf-8\"&gt;&lt;script language=\"javascript\"&gt; document.write(\"&lt;table&gt;\"); var str = \"javascript 9*9\"; document.write(\"&lt;h1&gt;\"+str+\"&lt;/h1&gt;\"); for(var i = 1;i&lt;10;i++) &#123; document.write(\"&lt;tr&gt;\"); for(var j = 1;j&lt;=i;j++) &#123; document.write(i!=j?\"&lt;th&gt;\":\"&lt;th bgcolor='#FF0000'&gt;\"); document.write(i+\"*\"+j+\"=\"+i*j); document.write(\"&lt;/th&gt;\"); &#125; document.write(\"&lt;/tr&gt;\"); &#125;&lt;/script&gt;&lt;/head&gt;&lt;/html&gt; 三、函数格式如下： function 自定义函数名（形参1，形参2…）｛ 函数体｝ 函数要在script标签中定义，使用的话，直接在html中调用函数名和参数即可，如onclick=”myFun()”。 几种特殊内置的函数： 函数 说明 eval() 求字符串中表达式的值 isFinite() 判断一个数值是否是无穷大 isNaN() 判断一个数值时都是NaN parseInt() 将字符型转化为整型 parseFloat() 将字符型转化为浮点型 encodeURI() 将字符串转化为有效的URL encodeURIComponent() 将字符串转化为有效的URL组件 decodeURI() 对encodeURI()编码的文本进行解码 decodeURIComponent() encodeURIComponent()编码的文本进行解码 四、对象编程4.1 Window对象4.1.1 属性 属性 描述 document 对话框中显示的当前文档 location 指定当前文档的url name 对话框名字 navigator 表示浏览器对象，用于获取与浏览器相关的信息 这个可以直接调用，如document.write() document.getelementById(‘test’) 4.1.2 方法 方法 描述 prompt 弹出一个提示对话框（有输入框） alert 弹出一个确认框 open 打开URL路径下的文件 close 关闭被引用的对话框 navigate(URL) 在对话框中显示URL下的文件内容 4.2 对话框 prompt（带输入的）对话框 alert直接提示对话框（仅仅是提示） confirm（带确认的）对话框 4.3 history4.3.1 属性 属性 描述 length 历史列表长度 current 当前文档URL（这个在火狐没有！？） next 列表中下个URL previous 前一个URL 4.3.2 方法 方法 描述 back 回到上一个URL forward 去后一个（下一页）URL go 进入指定页面(go(-1)==back()) 4.4 Document文档对象常用方法及实现： 方法 描述 close 文档的输出流 open 打开一个文档并接收write和writen方法的创建页面内容 write 可以在文档中写入HTML语句或者JavaScript语句 writeln 与write一样，但是以换行符结束 createElement 创建一个HTML标记 getElementById 获取指定id的HTML标记（如果内容多则以元组形式保存，需要用[*]访问） 4.5 DOM（文档对象模型）4.5.1 DOM分层如： 1234&lt;tr&gt; &lt;th&gt;&lt;/th&gt; &lt;input ... /&gt;&lt;tr&gt; 这里面tr是th和input的parentNode，而返过来，input和th是tr的childNode。而th和input是兄弟节点。 4.5.2 节点属性如下： 属性 说明 nodeName 节点名称 nodeType 节点的类型 nodeValue 节点的值，通常只应用于文本节点 parentNode 返回当前节点的额父节点 childNodes 子节点列表 firstChild 返回第一个子节点 lastChild 返回最后一个子节点 previousSibling 返回当前节点的前一个兄弟节点 nextSibling …后一个兄弟节点 attributes 元素的属性列表 4.5.3 节点操作 操作 方法 创建 appendChild 插入追加 insertBefore(new,ref) new新节点，ref指定在哪个节点后面添加 拷贝 clone(bool) true深拷贝，false浅拷贝 删除 removeChild 替换 replaceChild 4.5.4 DHTML与相应的DOM innerText 返回除去标签的文本内容 innerHTML 返回带有HTML标签的文本内容 五、事件处理注：如同onclick这种事件我就不多讲啦！ 5.1 DOM事件模型","categories":[{"name":"理论","slug":"理论","permalink":"https://jeffup.github.io/categories/%E7%90%86%E8%AE%BA/"},{"name":"代码编程","slug":"理论/代码编程","permalink":"https://jeffup.github.io/categories/%E7%90%86%E8%AE%BA/%E4%BB%A3%E7%A0%81%E7%BC%96%E7%A8%8B/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://jeffup.github.io/tags/JavaScript/"},{"name":"HTML","slug":"HTML","permalink":"https://jeffup.github.io/tags/HTML/"}]},{"title":"工具OllyDbg的使用","slug":"工具OllyDbg的使用","date":"2019-11-10T08:08:12.000Z","updated":"2019-11-24T12:08:02.478Z","comments":true,"path":"2019/11/10/工具OllyDbg的使用/","link":"","permalink":"https://jeffup.github.io/2019/11/10/%E5%B7%A5%E5%85%B7OllyDbg%E7%9A%84%E4%BD%BF%E7%94%A8/","excerpt":"一、前言OllyDbg简称OD，是一款具有可视化界面的用户模式调试器，","text":"一、前言OllyDbg简称OD，是一款具有可视化界面的用户模式调试器，结合了动态调试和静态分析，具有强大的反汇编引擎，能够识别数千个被C和Windows所使用的函数，并能将其参数注释出，能自动分析函数过程，循环语句，代码中的字符串等，非常容易上手，并且对异常的跟踪处理相当灵活，这些特性使得OllyDbg成为调试ring3级程序的首选工具，爱好者不断地修改，扩充OllyDbg，脚本执行能力和开发插件接口使得其变得越来越强大。 二、界面构成2.1 开始页面开始页面如图： 2.2 实验准备现在我编译一个很简单的C++程序（normal.exe）： 1234567891011121314151617#include &lt;iostream&gt;using namespace std;int main()&#123; int flag = 1; if(flag) &#123; cout &lt;&lt; \"hello world!\" &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; \"you have cracked it!\" &lt;&lt; endl; &#125; system(\"pause\"); return 0;&#125; 其正常输出如下： 2.3 载入程序，解释界面单击“File”-&gt;“open”选项，打开一个EXE文件，这次打开的是之前编译过的C++程序。 载入程序后的界面如下：下面解释各个部分的功能含义： 标题栏显示当前线程（main）和当前运行的程序名（normal） 菜单栏 快捷入口里面集成了许多系统工具，如文本编辑器(notepad)，计算器(calc)等 调试快捷键 (1) 打开新的可执行文件[快捷键F3](2) 重新载入程序[快捷键Ctrl+F2](3) 关闭程序 [快捷键Alt+F2](4) 运行程序[快捷键F9](5) 暂停执行程序 [快捷键F12](6) 单步步入[快捷键F7](7) 单步步过[快捷键F8](8) 跟踪步入[快捷键Ctrl+F11](9) 跟踪步过[快捷键Ctrl+F12](10) 执行到返回[快捷键Ctrl+F9](11) 转到反汇编窗中口的地址(转到表达式)[快捷键Ctrl+G] 窗口快捷键使用OD打开目标程序后，OD会打开多个子窗口，单击各个标签按钮可以在各个子窗口之间切换，这些按钮依次对应Log窗口，Executable modules窗口，Memory窗口，Threads窗口，Windows窗口，Handles窗口，CPU窗口，Patches窗口，Call stack窗口，Breakpoints窗口，References窗口，Run trace窗口，Source窗口。 反汇编面板窗口 Address列：显示被双击行地址的相对地址，再次双击返回标准地址模式 Hex dump列:设置或取消无条件断点，对应的快捷键是“F2”键。 Disassembly列:调用汇编器，可直接修改汇编代码，对应的快捷键是空格键。 Comment列:允许增加或编辑注释，对应的快捷键是“；”键。 寄存器面板窗口寄存器面板窗口（ Registers window）显示CP各寄存器的值，支持浮点、MM和3DNow寄存器。可以单击右键或窗口标题切换显示寄存器的方式。 信息面板窗口在进行动态跟踪时，信息面板窗口（Information window）将显示与指令相关的各寄存器的值、API函数调用提示和跳转提示等信息。 数据面板窗口数据面板窗口（ Dump window）以十六进制和字符方式显示文件在内存中的数据。要显示指定内存地址的数据，可单击右键快捷菜单中的Go to expression命令或按“Ctrl+G”快捷键，打开地址窗口，输入地址。 栈面板窗口栈面板窗口（Stack window）显示栈的内容，即ESP指向地址的内容。将数据放入栈的操作称为入栈（push），从栈中取出数据的操作称为出栈（pop）栈窗口非常重要，各API函数和子程序都利用它传递参数和变量等。 三、实战：运用OD","categories":[],"tags":[{"name":"课程","slug":"课程","permalink":"https://jeffup.github.io/tags/%E8%AF%BE%E7%A8%8B/"},{"name":"工具","slug":"工具","permalink":"https://jeffup.github.io/tags/%E5%B7%A5%E5%85%B7/"}]},{"title":"汇编语言(入门学习)","slug":"汇编语言-入门学习","date":"2019-11-10T06:57:39.000Z","updated":"2019-11-20T01:22:01.756Z","comments":true,"path":"2019/11/10/汇编语言-入门学习/","link":"","permalink":"https://jeffup.github.io/2019/11/10/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80-%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0/","excerpt":"简介：本篇旨在对汇编的基础知识进行汇总，汇总的都是要点（简明扼要），目前还在更新中。","text":"简介：本篇旨在对汇编的基础知识进行汇总，汇总的都是要点（简明扼要），目前还在更新中。 第一章 基础知识1.1 存储单元一个存储单元存储的信息量以bit为单位（最小）。而转换关系中8 bit=1 bytes(B)。而一个字=两个字节在微型计算机存储器的存储单元中，一个单元可以存1 B（即8个进制位）。而一个存储器有128个单元，则可以存储128 B。 1.2 CPU对存储器的读写要读写，则应该与三类信息进行交互： 地址信息 控制信息 数据信息 而逻辑上又分为3类总线，分别传输信息： 地址总线（指出内存中的信息放在那里(自下而上读01)） 控制总线（若要传输的数据多于一次性传输的宽度，则分开来多传几次） 数据总线 1.2.1 影响性能的因素：宽度（线的条数）：它决定了部件的能力（速度，控制能力等）。8086为16条，8088为8条 若CPU的寻址能力为8KB，则总线宽度：8*1024/1 = $2^13$ (注意单位是B,13则为总线宽度) 第二章 寄存器2.1 通用寄存器有AX BX CX DX四种，它们分为高位和低位以兼容以前的程序，如（AX = AH(高) + AL(低)）要注意的是：若只用AL进行运算，若超出其范围，超出的数据不会到AH当中！ 2.2 CPU给出物理地址的方法 段地址(SA)：只是为了内存的管理，并不是真分段。16位地址分段，一段64KB偏移地址(EA)：16位地址最多64KB公式：物理地址=段地址*16+偏移地址 2.3 段寄存器有CS DS SS ES四种。CS常存储段地址。它们提供了一下功能： CS：CPU要执行指令的地址。相当于命令指针 DS：读取内存的地址（返回数据）。相当于数据指针 SS：存储内存中的栈的顶。相当于栈顶指针 2.3.1 CS和IPIP是存储基于CS的偏移量。修改的流程： 一般流程：读取指令 -&gt; 修改 IP+=命令长度 -&gt; 执行指令(可能会涉及修改CS:IP) -&gt; 读取指令…8086PC启动时在FFFF0H单元中读取指令执行 2.4 疑问1. 为什么偏移地址只能在64Kb内？一个16位的CPU，只能有1111 1111 1111 1111，代表了4个16进制数，所以能表示2**16 bit的数据，恰好，就是64Kb。 2.暂留第三章 寄存器（内存访问）3.1 内存中字的存储 字单元的概念：即存放一个字型数据的内存单元，由两个地址连续的内存单元（一个8位）组成。高放高位，低放低位。 这里解释一下： 若有单元[0]-&gt;2e，[1]-&gt;33，那么我们读[0]的字型数据为：332eH（高放高位） 3.2 DS和[address] “[…]”表示一个内存单元，表示在段地址下的偏移量。如10000H = 1000:0 = [0] 在masm汇编编辑器中，如果单纯写mov ax,[0]，那么他会把[0]当做0来解释，即指令变成：mov ax,0而若用bx作为中转，那是可以的！如： 12mov bx,0mov ax,[bx] 这个是可以把[bx]当成段地址，返回ds:bx下的数据的！而如果偏要用[idata]的话，那么就必须加上ds:前缀，如： 1mov ax,ds:[0] 而对于Debug编译器的话，ds是自动加上的，用 1mov ax,[0] 即可，如果使用[]的话，而且他（段寄存器）是不能直接用mov命令改变的，必须通过其他的寄存器中转才能改变。 3.3 字的传送（mov指令）在传送字之后， DS和[address]也会跟着变，如1000:0，若传入一个fffeH，则address会从0-&gt;2，此时，[0]存有feH，[1]存有ffH,[2]为空。 3.4 mov、add、sub指令主要是说说置零问题，与机械码长度问题，稍微提一下，以后会细讲。举例子： 12sub bx, bxmov bx, 0 两个都是可以将bx寄存器置零的指令，但是sub的机械码长度为2，而mov为3，用sub更好。另外说说jmp指令，他是转移指令，具有一个操作对象的指令，而上面的具有两个。 3.5 栈他是一个FILO结构（先入后出），而且是从大变小（地址）。 3.5.1 push和pop 执行push ax命令，会把ax中的数据传入ss:sp指向的地址空间。此时sp-=2执行pop ax命令，会把ss:sp指向的地址空间中的数据传给ax。此时sp+=2 执行之后的指针变化： push先令sp-=2，然后将ax中的数据放进去。称为出栈。 pop是先取出数据放到ax中，再sp+=2。称为入栈。 3.5.2 数据传输如8086cpu的入栈和出栈都是以字为单位进行的。 3.5.3 栈指针上面已经用到了：段寄存器:寄存器存储(ss:sp)sp是指偏移地址，ss:sp始终指向栈顶。 3.6 栈顶越界问题栈溢出问题都是大问题，如果栈顶越界了，那么执行push和pop会受影响吗？当然不会！直接刚，写！写！写！出！出！出！管你呢。所以就会有可能读了其他程序的数据，或者修改了（覆盖）其他程序的数据（直接崩溃的说）执行情况（取自《汇编语言第二版》王爽著） 3.7 问题1.程序与数据有区别吗？可以说有，也可以说没有。由于指令都是0和1组成的，只是用不同功能的段地址读出来的不一样，如,CS和DS都指向10000H，那么，CS会将里头的数据转化为机械码，执行指令，而DS就直接读数据，作为单纯的数据使用。 2.空栈如（10000H~1000FH）此时ss=1000H，那么sp是多少？因为是自下而上（自大到小），所以sp=0010H。换一种方式看，若存储了一个数据，则一个存到000EH，一个存到000FH，此时的栈指针在栈顶，当然指向000EH了，此时是已经让sp-=2了，那么回溯一下，不就有sp=0010H了。 好了，问题来了，如果将（10000H~1FFFFH）作为空间呢？答案：sp=0000H，因为，不能变成10000H(笑) 3.栈会溢出，那么，为什么不设置栈大小emmm，可惜8086cpu就是没有，所以变成自己注意。 4.只有mov可以完成传输数据吗？push也可以哦，只要把sp定位为ds:[address]那就好了哦。直接写进去。 第四章 第一个程序4.1 一个源程序从写出到执行的过程执行过程包括：写程序-&gt;编译连接成可执行文件-&gt;执行。 可执行文件文件中包括以下两部分： 程序和数据 相关的描述：程序多大，占用多少运行空间 4.2 源程序4.2.1 伪指令也就是只能被编译器识别的指令，如assume、segment、end等，这是没有机械码的。一般的伪指令使用如下： 12345assume cs:code #声明（假设）cs:段名（标号）code segment #段名 segment_指令_code ends #对应segment，表示一个段结束end #对应assume，表示程序结束 4.2.2 程序返回现在考虑，如何让上一个程序把CPU控制权交给写一个程序，这时候就要使用程序返回其代码如下： 12mov ax, 4c00Hint 21H 4.3 程序生成流程编程 -&gt; 1.asm -&gt; 编译 -&gt; 1.obj -&gt; 连接 -&gt; 1.exe -&gt; 加载 -&gt; 内存中的程序 -&gt; 运行注：加载就是将程序加载到内存，执行就是在内存中执行程序的指令 4.4 怎么装载程序？操作系统是一个模块组成庞大的系统。任何通用的系统都要提供一个称为shell的程序，用户使用这个程序来操作计算机系统进行工作。 如DOS中有一个程序command.com，这个程序称为：命令解释器，也就是DOS中的SHELL（其实跟我们的cmd.exe差不多） 先运行shell，然后在加载1.exe可执行程序的时候，cmd会自动把cpu的控制权交给1.exe，执行完成再返回cmd。 4.4 展示EXE的加载过程 第五章 [BX]和loop指令5.1 [BX]这个之前就讲过：其实就是把BX中的值作为ds的偏移地址EA，然后可以用这个来访问特定地址下的数据。如ds:1000H，bx=0001H，那么[BX]就是指ds*16+bx下的值。 5.2 loop直接上程序： 12345678assume cs:eloopeloop segment mov ax,128 mov cx,36 s:add ax,ax loop seloop endsend 解释： loop是按照cx当中的值进行对有标号的s下的命令进行循环的。当cx不等于0，则执行循环，这个程序实际上是实现128*36的程序。 s实际上是IP值，指向s标记的地址，所以loop s实际上是给IP赋值：IP=s，然后就可以通过cs:ip来执行指令了 注意：汇编程序中，数据不能以字母开头，所以要在前面加个0。比如：9138h可以写成9138h，而A000h就必须写成0A000h 5.3 loop和[bx]的联合运用例如来一个如同C++语言中的： 123456int dx = 0;int ds[12] = &#123;1, 2, ...&#125;;for(int i=0; i &lt; 12; i++)&#123; dx += ds[i];&#125; 那么汇编语言就有： 123456789101112131415161718192021assume cs:codecode segment: mov ax, 0ffffh ;因为ds寄存器不能直接赋值，所以用ax作为中间变量 mov ds,ax mov bx,0 ;初始化ds:bx指向ffff:0 mov dx,0 ;初始化**累加寄存器**dx，让值为0 mov cx,12 ;初始化循环计数寄存器cx，令值为12，指循环12次 s: mov al,[bx] ;以下两步执行ax的赋值操作 mov ah,0 ; add dx,ax ;执行加法 inc bx ;ds:bx指向下一个单元，因为bx的值增加了1，相当于C++代码中的*i++* loop s ;loop完成一次，则cx=cx-1，然后判断cx是否等于0，如果等于则退出循环 mov ax,4c00h int 21hcode endsend 好了，现在来说说这段代码里面有什么需要注意的点： cx寄存器一般用作loop循环的判断条件，即循环的粗次数。 ax寄存器的初始化有两步，是，因为一个字符型数据是8位这样的话转化为16位就得让高8位的值赋为0。 dx寄存器是常用的累加寄存器。 inc指令是让后面的值加一的指令，相当于C++语言中的‘++’自增。 int指令： 由int 指令引发的中断是一种重要的内中断。格式： int n //相当于引发一个n号中断的过程,最终功能和call指令相似，都是调用一段程序。 取中断类型码n 标志寄存器入栈，并IF=0,TF=0 //TF=0使得避免中断程序执行过程中引发单步中断 CS,IP寄存器入栈 IP=(n*4) , CS=(n*4 + 2)原文链接 5.4 段前缀与其使用 能够显示地指令内存单元的段地址的，如：”ds:”、”cs:”、”ss:”、”es:”。这就是段前缀。 默认的[x]是指：(dx*16)+x，而如果要用其他的段寄存器，则需要加上它的段前缀。 第六章 包含多个段的程序 由于软件是由数据和程序组成的，数据当然也是程序里面必不可少的部分，所以会将代码分为多段进行，如数据段、代码段等。 6.1 在代码段中使用数据 汇编程序若没有特殊的说明（或者注明在哪里开始），则默认从头开始！所以，一旦你的程序头部有数据，则将会把头部的数据翻译为机器码执行。(冤) 那么解决方式是：在开始执行代码的地方加上 start: 123456789101112131415assume cs:codecode segment dw 0123h,0456h,0789h ;这里是数据部分 dw意思是定义字符型数据 start: mov bx,0 ;注意，从这开始，标识为start! mov ax,0 mov cx,8 s: add ax,cs:[bx] ;用cs作为段地址，取数据！ add bx,2 loop s mov ax,4c00h int 2hcode endsend start ;注意end后面要加上end开始的名称！ 6.2 将数据、代码、栈放入不同的段上面说了，代码从哪里开始就在哪里加上start，结束就用end start（其他标识也行）好，记住，那是代码，别把接下来说的混淆了。 不同的段可以放不同的东西，例如数据，代码等等。只要记住将段名end了再定义其他段。也只有定义了，才能使用这个段 123456789101112131415161718192021222324252627282930313233assume cs:b,ds:a,ss:ca segment dw 0123h, 0456h, 0789h, 0abch, 0de fh, Ofedh, 0cbah, 0987ha endsc segment dw 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0c endsb segmentd: mov ax,c ;使用段c中的数据 mov ss,ax mov sp, 20h ;希望用c段当作栈空间，设置ss:sp指向c:20 mov ax,a ;使用段a mov ds,ax ;希望用ds:bx访问a段中的数据，ds指向a段 mov bx,0 ;ds:bx指向a段中的第一一个单元 mov Cx,8s: push [bx] add bx,2 1oop s ;以上将a段中的0~15单元中的8个字型数据依次入栈 mov bx,0 mov cx, Bs0: pop [bx] add bx,2 1oop s0 ;以上依次出栈8个字型数据到a段的0~15单元中 mov ax, 4c00hint 21hb endsend d ;d处是要执行的第一- 条指令，即程序的入口 第七章 更灵活的定位内存地址的方法之前的[0]和[bx]均可以起到定位的作用，现在有更灵活的定位方式： 7.1 and和or指令 and是有零变零，而or是有一变一也可以想象成and是乘法，or是加法 7.2 以字符型给出数据凡是以’…’形式给出数据的，都被译为是字符型数据，这样，编译器会将里面的数据变成ASCII码值。具体实例： 12db &apos;unIX&apos;mov al,&apos;a&apos; 这里被译为 12db 75H,6EH,49H,58Hmov al,61H 而大小写转换的方法有两种： 基于比较的，在ASCII码中，大写字母+20H=小写字母 基于二进制数的，在ASCII表达字符时，若第五位为0，则为大写字母；若第五位为1则为小写字母（这里可以用or或者and来进行转换） 7.3 以[bx+idata]的方式寻址现在以例题进行解析，将第一组字符串变成大写，第二组变成小写 123456789assume cs:codesg,ds:datasgdatasg segment db &apos;BaSiC&apos; db &apos;MinIX&apos;datasg endscodesg segmentstart: ;代码段codesg endsend start 原来的思想：取[bx]中的字符，再对其进行and 11011111b操作，再放回去，然后将bx自增，再重新···，而变成小写就or 00100000b。（这里要执行两次循环啊，一个变大写，一个变小写） 然而我们可以使用以下思想，更加便捷，就是[bx+idata]：思想和前面的一样，但是，不用执行两次循环，只要一次就够了：12345678910111213 mov ax,datasg mov ds, ax mov bx,0 mov cx,5s:mov al,[bx] ;定位第一个字符串的第bx个字符 and al,11011111b ;执行完变大工作 mov [bx],al ;放回去 mov al[5+bx] ;定位第二个字符串的第bx个字符（因为一个字符串只有5个字符） or al,00100000b ;执行变小工作 mov [5+bx],al ;放回去 inc bx ;自增 loop s 这个其实，学过高级语言都知道这方法，只不过，没想到汇编也能做吧，汇编语言也不是那么死板的。 7.4 si与di寄存器和多重循环这个只要知道是16位寄存器，功能和bx差不多，可以用作[bx+si+idata]和[bx+di+idata]就可以了。其中，idata是常量，其他的为变量。这个结构可以执行二重循环，相当于处理二维数组。需要注意的是二重循环的实现： 问题一：cx寄存器是用作循环的判定条件的，那么二重循环对于没有两个cx的我们来说，如何是好？将之前的cx用其他寄存器保存起来啊！ 问题二：二重循环可以那样做，那么多重循环呢！？你只有有限个寄存器。利用内存空间！开辟一段dw 0，让后指向它，放进去就完事了。 问题三：那这个方法的前提是我得知道有多少个循环，很麻烦啊，换个简单的。 在需要暂存数据的时候我们都应该使用栈* 在需要暂存数据的时候我们都应该使用栈* 在需要暂存数据的时候我们都应该使用栈*按顺序push，然后逆向按顺序pop 第八章 数据处理的两个基本问题这两个问题是： 处理的数据在什么地方 要处理的数据有多长 8.1 bx、si、di和bp这几个都用过，主要说说bp:这个只要在[…]里使用了它，没有段地址声明，那么默认是ss 8.2 机器指令处理的数据在什么地方在指令执行前，所要处理的数据可以在三个地方： CPU内部 内存 端口下面举例子：上图还表明了汇编语言中数据位置的表达 立即数（idata）：如上图的最后一个例子，是直接赋值的 寄存器：如上图的第二个例子，使用寄存器名。 段地址：如果是[bx]则默认段地址是ds，如果是[bp]则默认段地址为ss，当然可以显性给出。 8.3 指令处理的数据长度这个得看具体例子。 如果是ax,bx，那么这个就是字操作 如说是al,bl，那么就是字节操作 在没有寄存器名存在的情况下，用操作符X ptr指明内存单元的长度，X在汇编中可以为word或byte（且必须显式声明）。 12mov word ptr ds:[0],1 ;字mov byte ptr ds:[0],1 ;字节 有些指令默认了访问的是字还是字节，如push默认进行字操作，而用[…]的是字单元操作(一个8位)。 8.4 div指令div是除法指令，使用div做除法的时候应注意以下问题. 除数:有8位和16位两种，在一个reg或内存单元中。 被除数:默认放在AX或DX和AX中 如果除数为8位，被除数则为16位，默认在AX中存放； 如果除数为16位，被除数则为32位，在DX和AX中存放，DX存放高16位，AX存放低16位。 结果: 如果除数为8位，则AL存储除法操作的商，AH存储除法操作的余数: 如果除数为16位，则AX存储除法操作的商，DX存储除法操作的余数。 格式如下： 12345div regdiv 内存单元div byte ptr ds:[0]含义：(al)=(ax)/((ds)*16+0)的商 (ah)=(ax)/((ds)*16+0)的余数 8.5 实例利用除法指令计算100001/100分析： 由于100001大于整数最大值（16位）65535，不能用ax寄存器存放，所以只能用dx和ax两个寄存器联合存放，共32位 而出书100小于255（8位），但是因为被除数是32位，所以除数应该用16位的来存放除数100所以有程序： 1234mov dx,1mov ax,86A1H ;(dx)*10000H+(ax)=100001 100001=186A1Hmov bx,100div bx 执行后，(ax)=03E8H(即10000)，(dx)=1(余数为1)。 8.6 伪指令dd之前有学过用db和dw定义字节型数据和字型数据。dd是用来定义dword（double word，双字）型数据的。 db 占1个字节 dw 占1个字（即两个字节） db 占2个字（即四个字节） 8.7 dupdup是一个操作符，在汇编语言中与dw,db,dd一样，都是由编译器识别处理的符号，且与它们一同配合使用，用来进行数据重复。如： 123456789db 3 dup (0)定义了3个字节，它们的值都是0，相当于执行了 db 0,0,0。db 3 dup (1,2,3)定义了3\\*3=9个字节，它们是0、1、2、0、1、2、0、1、2，相当于db 0,1,2,0,1,2,0,1,2。字符型也适用。总结：d？ 重复的次数 dup (重复的(字节/字/双字型)数据） 第九章 转移指令的原理可以修改IP 或同事修改CS和IP的指令统称为转移指令统称为转移指令。如jmp、jno等，即可以控制CPU指令内存中某处代码的指令。具体分类有： 无条件转移指令（jmp） 条件转移指令（jno） 循环指令（loop） 过程 中断 还有其他的分类： 只修改IP：段内转移（jmp ax） 同时修改CS和IP：段间转移（jmp 1000:0） 短转移 近转移 9.1 操作符offsetoffset是编译器处理符号，功能：取得标号的额编译地址。如： 12start: mov ax, offset start ;相当于mov ax,0 s: mov ax, offset s ;相当于mov ax,3 解析：第一条指令mov … 是三个字节，所以s段的offset为3 9.2 jmp指令和依据译为进行转移的jmp指令9.2.1 jmp short 标号(转移到标号出执行指令)1. short标号下，它属于段内短转移，对IP的修改范围为-128~127。9.2.2 立即数在机器码中的表示在一般的汇编指令当中，汇编指令的idata（立即数），不论他是表示一个数据还是内存单元的偏移地址，都会在相应的机器指令中出现，因为CPU执行的是机器指令，他必须处理这些数据或地址。 123mov ax,0123h B8 23 01mov ax,ds:[0123h] A1 23 01push ds:[0123h] FF 36 23 01 9.2.3 jmp转移的机制（是怎么实现转移的）12345start: mov ax,0 mov bx,0 jmp short s add ax,1 s: inc ax 首先我们应该知道，jmp指令是2个字节，如代码中的jmp机械码是：EB 03 。这样的机械码，没有包含s段的地址！所以将jmp指令写入内存之后，IP=IP+2=0008h。 但是，执行完jmp后，IP=000Bh。因为执行JMP，就是执行IP=IP+(EB之后的偏移量)=IP+3=000Bh。 所以jmp执行的是给IP加偏移地址！。 所以 jmp short 标号 的功能为：(ip)=(ip)+8位位移 9.2.4 继续上面的，8位位移是怎么得出来的？ 8位位移=标号处的地址 - jmp指令后的第一个字节的地址. short指明此处的位移为8位位移; 8位位移的范围为-128-127，用补码表示 8位位移由编译程序在编译时算出。 还有一种和”jmp short标号”功能相近的指令格式:jmp near ptr标号它实现的是段内近转移。功能为:(IP)=(LP)+16位位移。(1) 16位位移=标号处的地址 - jmp指令后的第一个字节的地址:(2) near ptr指明此处的位移为16位位移，进行的是段内近转移:(3) 16位位移的范围为一32768~32767，用补码表示:(4) 16位位移由编译程序在编译时算出。 9.2.5 jmp far ptr 标号（段间转移/远转移）是不是所有的jmp机械码都没有段数据呢？当然不是！小标题就说到了：far ptr，这个指令用标号的段地址和偏移地址修改CS和IP如：解释：“OB 01 BD 0B”是目的地之在指令中的存储顺序：高地址：“BD 0B”是段地址 0BBDH ；低地址：“0B 01”是偏移地址 010BH ； 9.2.6 转移地址在寄存器的jmp指令(这就相当于总结了，上面废话有点多) 若只是一个字，则只是偏移地址（直接EB ??完事） 若是两个字，那么一个是段，一个是偏移地址。 9.3 jcxz指令该指令为有条件转移指令，所有的有条件转移指令都是短指令，即上面9.2.6说的1个字，只有位移（偏移地址），对ip的修改范围是：-128~127. 指令格式：jcxz 标号如果(cx)=0，则转移到标号这 9.4 loop指令也是短转移指令，pass 9.5 编译器对转移位移超界的检测编译的时候就会出错！因为，这超界，编译器可识别不了。这不存在的玩意儿。 第十章 CALL和RET指令10.1 ret和retf它们都是用栈中的指令，而ret是改变ip，而retf是改变cs:ip，实现远转移。而正是因为它们是取栈中的指令，所以要和push 和pop结合起来，而ret或者retf执行完后，相当于执行了指令pop如： 123456mov ax stack ;在前面声明的stack数据段，共16Bmov ss ax ;栈段地址mov sp 16 ;将值（Base）设置为16，往上加。（栈的特性）push cxpush ipretf 这里就相当于执行了刚放进去的机器码。 10.2 call指令 将打那个钱的IP或CS:IP压入栈中 转移 注意：call指令不能执行短转移，其实现方法与jmp指令相同 10.2.1 依据位移进行转移的call指令 call 标号(将当期那的ip压入栈后，转到标号处执行指令) 指令执行时会带有以下操作： 1231. (sp)=(sp)-2 ;压栈 ((ss)*16+(sp))=(IP)2. (IP)=(IP)+16位位移 这个位移之前也说过了，不多讲。看到上面的代码我们也能联想到jmp的执行了，相当于： 12push IPjmp near ptr 标号 举个例子！ 12345内存地址 机器码 汇编指令 1000:0 b8 00 00 mov ax,0 1000:3 e8 01 00 call s 1000:6 40 inc ax 1000:7 58 s:pop ax 也许你会想到：我没有push哪来的pop!? 在call之时已经有了push ip，此时的ip=提取call s之后指向下一个执行机器码（inc ax）的ip指针，也就是ip=6。 而当call转移到s，ip就变为call之后的ip。 此时再pop ax，也就是ax=6。 因为执行完s，没有回调指令pop ip。。。所以不会执行inc ax 10.2.2 转移地址在指令中的call指令这个也就是段间转移了，是相对于上头说的段内转移 1call far ptr 标号 此时会执行cs和ip双压栈 12345678910111. (sp)=(sp)-2 ;压栈 ((ss)*16+(sp))=(CS)(sp)=(sp)-2 ;压栈 ((ss)*16+(sp))=(IP)2. (CS)=标号所在的段地址(IP)=标号在段中的偏移地址即：push CSpush IPjmp far ptr 标号 举个例子： 12345671000:0 b8 00 00 mov ax,01000:3 9a 09 00 00 10 call far ptr s1000:8 40 inc ax1000:9 58 s: pop ax add ax,ax pop bx add ax,bx ax是多少呢？ call指令执行之后，stack中有cs和ip两个数据，CS在底部,IP在顶部。所以第一次pop ax，ax=ip=8 执行add后ax=16即10H 再执行pop，bx=1000H add指令执行后ax=ax+bx=1010H 10.2.3 转移指令在寄存器中的call指令call 16位reg功能： 12push IPjmp 16位reg ;IP=(reg) 这个跟10.2.1是不是很像？段内转移。例子：call ax（当ax=6,则转到cs:6处执行） 10.2.4 转移指令在内存中的call指令call word ptr 内存单元地址功能： 12push IPjmp word ptr 内存单元地址 其实跟10.2.3没啥两样。 但是还有一种双字型： call dword ptr 内存单元地址功能： 123push CSpush IPjmp dword ptr 内存单元地址 举个例子就明白了 12345mov sp,10hmov ax,0123hmov ds:[0],axmov word ptr ds:[2]，0call dword ptr ds:[0] 执行后：(CS)=0, (IP)=0123H, (sp)=0CH. 10.3 call与ret的配合使用（敲黑板！） call之时压ip到栈中! call完之后，执行转移后的指令 通过ret取出栈中的地址，执行转移操作！即回调作用！ 回调完成就可以执行call之后的代码了！分析例子：12345678910111213assume cs:codecode segment start: mov ax,1 mov cx,3 call s mov bx,ax ;(b)=? mov ax,4c00h int 21h s: add ax,ax loop s retcode endsend start 我们来看一下CPU执行这个程序的主要过程。 (1)CPU将call s指令的机器码读入，IP指向了call s后的指令mov bx,ax.然后CPU执行call s指令，将当前的IP值(指令mov bx,ax的偏移地址)压栈，并将IP的值改变为标号s处的偏移地址: (2) CPU从标号s处开始执行指令，loop循环完毕后，(ax)=8; (3) CPU将ret指令的机器码读入，IP指向了ret指令后的内存单元，然后CPU执行ret指令，从栈中弹出一个值(即call s先前压入的mov bx,ax指令的偏移地址)送入IP中。则CS:IP指向指令mov bx,ax; (4) CPU从mov bx,ax开始执行指令，直至完成。 10.4 mul乘法指令之前说了div除法指令，现在说乘法指令。 10.4.1 乘法规则这里跟div的除数和被除数不一样的是，乘法的两个数，要么都是8位要么都是16位！ 乘法的两个数 如果是8位，一个放在AL中，一个放在8位的reg或内存字节单元中。 如果是16位，一个放在AX中，一个放在16位的reg或内存字节单元中。 乘法的结果 如果是8位乘法，结果放在AX中 如果是16位乘法，高位放DX，低位放AX 10.4.2 指令格式：12mul regmul 内存单元 格式说明：因为有一个放在了al(以8位为例) 123mov al 1mov byte ptr ds:[0] 2mul ds:[0] 这个就是用2*1了~结果是ax=2（当然，我赋值的是十进制嘛） 10.4.3 用mul寻址 mul byte ptr ds:[0]含义：ax=al(ds16+0) mul word ptr [bx+si+8]含义：dx= 10.5 模块化程序设计10.5.1 参数和结果的传递问题也就是说，传进来的参数是啥，返回值是个啥。 传入的参数：这个有很多，有用栈传递的，也有直接用内存单元或者寄存器。 返回值：这个可以存在寄存器中返回跟传入参数的方法很像 而模块化设计，其实就是相当于c语言中的函数，把一个段中的代码当做一个函数执行。 10.5.2 寄存器冲突问题冲突问题是什么呢？例如如果上面的模块使用的loop，即使用了寄存器cx，而call的模块也适用了loop，即也使用了cx，那么两者就将共用cx，肯定会出错！解决办法有： 让别的调用者调用其他寄存器（这个很难实现，你也不知道他会用到什么寄存器） 不要使用会冲突的寄存器（这个不可能实现，只是说说理想罢了） 用栈，压进去，保存，call完在出栈！（这个OK哦） 10.6 课后下面的程序执行后，ax和bx中的数值为多少？12345678910111213141516171819202122assume cs:codesgstack segment dw 8 dup(0)stack endscodesg segmentstart: mov ax,stack mov ss,ax mov sp,10h mov word ptr ss:[0],offset s ;(ss:[0])=1ah mov ss:[2],cs ;(ss:[2])=cs call dword ptr ss:[0] ;cs入栈,ip=19h入栈,转到cs:1ah处执行指令 ;(ss:[4])=cs,(ss:[6])=ip nops: mov ax,offset s ;ax=1ah sub ax,ss:[0ch] ;ax=1ah-(ss:[0ch])=1ah-19h=1 mov bx,cs ;bx=cs＝0c5bh sub bx,ss:[0eh] ;bx=cs-cs=0 mov ax,4c00h int 21hcodesg endsend start 实验10-1 编写子程序 之 显示字符串在这次实验中，我们将要编写3个子程序，通过它们来认识几个常见的问题和掌握解决这些问题的方法.同前面的所有实验一样，这个实验是必须独立完成的，在后面的课程中，将要用到这个实验中编写的3个子程序。 显示字符串问题显示字符串是现实工作中经常要用到的功能，应该编写一个通用的子程序来实现这个功能.我们应该提供灵活的调用接口，使调用者可以决定显示的位置(行、列)、内容和颜色。 子程序描述名称:show str功能:在指定的位置，用指定的颜色，显示一个用0结束的字符串。参数:(dh)=行号(取值范围。-24), (dl)=列号(取值范围0-79), (cl)=颜色，ds:si指向字符串的首地址返回:无应用举例:在屏幕的8行3列，用绿色显示data段中的字符串。 提示 子程序的入口参数是屏幕上的行号和列号，注意在子程序内部要将它们转化为显存中的地址，首先要分析一下屏幕上的行列位置和显存地址的对应关系: 注意保存子程序中用到的相关寄存器: 这个子程序的内部处理和显存的结构密切相关.但是向外提供了与显存结构无关的接口。通过调用这个子程序，进行字符串的显示时可以不必了解显存的结构，为编程提供了方便。在实验中，注意体会这种设计思想。 其实这玩意，就是抢占了本来应该在屏幕中输出的系统信息。那么设置行列号的，就是占的信息的位置。 点击查看参考代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061assume cs:code,ds:datadata segment db &apos;Welcome to masm!&apos;,0data endscode segmentstart: mov dh,8 ;行号 mov dl,3 ;列号 mov cl,07h ;白色字 mov ax,data mov ds,ax mov si,0 ;循环加入字 call show_str mov ax,4c00h int 21hshow_str: push cx ;保存用到的寄存器 push si push es push di push bx mov ax,0b800h mov es,ax mov al,0a0h ;一行的总列数160字节 dec dh ;行号减1，因为是从0开始的 mul dh ;计算行开始偏移地址 mov bx,ax mov al,2 mul dl ;计算列 sub ax,2 ;列也是从0开始，而且一个字符占两个字节 add bx,ax ;求出开始位置 mov di,0 mov al,cl mov ch,0 ;高8位为0s: mov cl,ds:[si] ;判断是否到了字符结束 jcxz ok mov es:[bx+di],cl mov es:[bx+di+1],al inc si add di,2 jmp short sok: pop bx pop di pop es pop si pop cx retcode endsend start 解决除法溢出问题问题：其实就是如果商超过了应该存储商的寄存器的大小，应该怎么办。emmm可以用大一点的，用dword 第十一章 标志寄存器这是一种特殊的寄存器，一共16位： 用来存储相关指令的执行结果 用来为CPU执行相关指令提供行为依据 用来控制CPU的相关工作方式其分布如下： 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0 * * * * OF DF IF TF SF ZF * AF * PF * CF 其中*表示都没用：1 3 5 12 13 14 15在8086CPU中都没有使用。注意：对标志位有影响的指令有：add,sub,mul,div,inc,or,and等，而没有影响的有：mov,push,pop等，它们大多数为传送指令。 11.1 标志表 名称 代号 作用 备注 零标志 ZF 判断结果是否为零 若为0则ZF=1，否则ZF=0 奇偶标志 PF 判断结果中1的个数是奇是偶 若1的个数为奇数则PF=0，否则为1 符号标志 SF 判断结果是正是负 若为正数则SF=0，否则为1 进位标志位 CF 在进行无符号运算时记录是否有向最高位进位或者借位 那是假想的最高位 溢出标志 OF 判断是否超过容器所能装的最大数 如al=98+99=197，197&gt;127溢出，实际结果：-59 方向标志 DF 控制每次操作后si、di的增减 df=0 每次si,di增加；df=1 每次si,di减少。经常用作字符串的传送 11.2 与标志有关的指令11.2.1 与CF相关的：adc,sdd指令 adc：带进位加法。如：adc al,8h == al+8h+CF sdd：带借位减法。如：sdd al,8h == al-8h-CF 11.2.2 与CF和ZF有关的：cmp指令（比较指令）指令格式：cmp s1,s2举个例子：cmp ax,bx比对结果如下： 情况 结果分析 结果 (ax)=(bx) 则(ax)-(bx)=0 zf=1; (ax)≠(bx) 则(ax)-(bx)≠0 zf=0; (ax)&lt;(bx) 则(ax卜(bx)将产生借位 cf=1; (ax)≥(bx) 则(ax)-(bx)不必借位 cf=0; (ax)&gt;(bx) 则(ax)-(bx)既不必借位，结果又不为0 cf=0并且zf=0; (ax)≤(bx) 则(ax)-(bx)既可能借位，结果可能为0 cf=1或zf=1. 11.2.3 与CMP有关的比较结果条件转移指令 指令 含义 简记 符号 监测的相关标志位 je 等于则转移 equal = zf=1 jne 不等于则转移 not equal ≠ zf=0 jb 低于则转移 below ＜ cf=1 jnb 不低于则转移 not below ≥ cf=0 ja 高于则转移 above ＞ cf=0且zf=0 jna 不高于则转移 not above ≤ cf=1或zf=1 注意，这个一般是与cmp配合使用，如同call和ret一样，但是没有说一定要配合使用。 11.2.4 与DF有关指令 指令 功能 解释 movsb mov es:[di],byte ptr ds:[si] 从ds中取字符放到es指定的位置中，单位为字节，会令di和si同时±1 movsw mov es:[di],word ptr ds:[si] 从ds中取字符放到es指定的位置中，单位为字，会令di和si同时±2 cld 设置df=0，正向 令di，si向增方向 std 设置df=1，逆向 令di，si向减方向 rep 重复指令，根据CX当中的值，与LOOP相似 配合movsb使用 例子： 1234567891011121314151617181920212223242526我们来看下面的两个程序。(1)编程，用串传送指令，将data段中的第一个字符串复制到它后面的空间中。data segmentdb &apos;Welcome to masm!.db 16 dup (0)data ends我们分析一下，使用串传送指令进行数据的传送，需要给它提供一些必要的信息它们是:1. 传送的原始位置:ds:si:2. 传送的目的位置:es:di;3. 传送的长度:CX;4. 传送的方向:df.在这个问题中，这些信息如下。1. 传送的原始位置:data:O;2. 传送的目的位置:data:0010;3. 传送的长度:16;4. 传送的方向:因为正向传送(每次串传送指令执行后，Si和di递增此较方便，所以设置df=o好了，明确了这些信息之后，我们来编写程序:mov ax,datamov ds,axmov si,0 ;ds:si指向data: 0mov es,axmov di,16 ;es.di于行向data:0010mov cx,16 ;(cx)-16, rep循环1‘次cld ;设置df=0，正向传送rep movsb 11.3 标志位有关的问题11.3.1 单纯就符号标志位就可以判断结果的正负吗？（即判断相减的两个数的大小）当然不是！ 当1-2=-1&lt;0，则SF为1，表示负数，则前一个数比后一个数大当34-(-96)=82H时，82H是-126的补码，所以SF=1，但是前一个数比后一个数大？当然不。 为什么呢？因为发生了溢出。 也就是说，保存结果的寄存器不足以表示那么大的数。 而34-(-96)=130明显超过127（假设保存结果的是ah）。 那么结果就会表示为-126（130-127=3，-128+3-1=-126） 而此时，SF=1，同时，OF=1。 所以要看结果的正负，要结合SF和OF的值. 总结： 标志 结果 备注 SF=1,OF=0 负 略 SF=1,OF=1 正 因为溢出导致实际结果为负，那么逻辑上必定为正 SF=0,OF=1 负 因为溢出导致实际结果为正，那么逻辑上必定为负 SF=0,OF=0 正 略 11.4 pushf和popf因为标志寄存器共16位，所以pushf就直接将16位当做寄存器放入栈中，popf是出栈。注意，它们不需要加对象参数，入栈和出栈的对象都是标志寄存器！ 第十二章 内中断也就是CPU不再往下执行下去。而CPU内部的四种中断信息是： 除法错误，如div指令产生的除法溢出（中断类型码：0） 单步执行（中断类型码：1） 执行into指令（中断类型码：4） 执行int指令（指令格式：int n，其中n是中断类型码，是字节型立即数） 12.1 中断一条龙（中断程序，中断向量表，中断过程）中断过程： 取得中断类型码（即中断向量表中的中断程序位置） 标志位入栈（因为执行中断过程要改变标志寄存器的值） 设置寄存器的TF和IF的值为0 CS内容入栈 IP内容入栈（结束中断程序回调的时候用，和call差不多） 从内存地址为中断类型码*4和中断类型码*4+2的两个字单元中读取中断处理程序的入口地址设置IP和CS。（用来取得中断程序在内存中的位置） 其实就是： get N pushf TF=0, IF=0 push CS push IP (IP)=(N*4), (CS)=(N/4+2) 执行程序！ 12.2 中断处理程序，安装，中断向量等这个只是稍微述说，额，因为我不太能用到这个，作为了解而已。中断处理程序就如同除法溢出程序一样（输出‘…overflow’），如何处理后续的事物做中断处理，然后返回系统程序。而如果想要自己编一个中断处理程序，首先 把中断码想好，把程序要放的地方想好，*放入中断向量表 编程序，安装（写到相应位置） 测试 这里当然要用到之前学的几乎所有内容（包括ret,movsb等） 12.3 单步中断和TF,DF标志说到这里，你看标题就知道，TF肯定与单步中断有关，具体有什么关系呢？首先说说单步中断，也就是不停止（退出）运行的程序，却能返回其实时的寄存器信息（也就是还在运行，只不过暂时停止了）。而TF就是实现单步中断的重要标志，当TF=1时将引发单步中断，所以要想中断就先置TF=1。这就是为什么中断执行（刚开始）就要把TF置0，就是为了防止步步中断！ 12.4 int指令int指令引发的内中断很重要。虽然其过程与12.1所说的别无二致。接下来就深入理解理解int、iret和栈： 12.4.1 int、iret和栈暂时停更2019/11/20 9:21:47","categories":[{"name":"理论","slug":"理论","permalink":"https://jeffup.github.io/categories/%E7%90%86%E8%AE%BA/"},{"name":"代码编程","slug":"理论/代码编程","permalink":"https://jeffup.github.io/categories/%E7%90%86%E8%AE%BA/%E4%BB%A3%E7%A0%81%E7%BC%96%E7%A8%8B/"}],"tags":[{"name":"汇编","slug":"汇编","permalink":"https://jeffup.github.io/tags/%E6%B1%87%E7%BC%96/"},{"name":"二进制","slug":"二进制","permalink":"https://jeffup.github.io/tags/%E4%BA%8C%E8%BF%9B%E5%88%B6/"}]},{"title":"网络流量分析（nogotofail））","slug":"网络流量分析-nogotofail","date":"2019-11-10T06:50:53.000Z","updated":"2019-11-17T01:25:52.050Z","comments":true,"path":"2019/11/10/网络流量分析-nogotofail/","link":"","permalink":"https://jeffup.github.io/2019/11/10/%E7%BD%91%E7%BB%9C%E6%B5%81%E9%87%8F%E5%88%86%E6%9E%90-nogotofail/","excerpt":"应用范围它包括对常见的SSL证书验证问题(HTTPS和TLS/SSL)的测试库bug、SSL和STARTTLS剥离问题、明文问题等等。","text":"应用范围它包括对常见的SSL证书验证问题(HTTPS和TLS/SSL)的测试库bug、SSL和STARTTLS剥离问题、明文问题等等。 应用到的库：psutil模块psutil是一个跨平台库能够轻松实现获取系统运行的进程和系统利用率（包括CPU、内存、磁盘、网络等）信息。它主要用来做系统监控，性能分析，进程管理。它实现了同等命令行工具提供的功能，如ps、top、lsof、netstat、ifconfig、who、df、kill、free、nice、ionice、iostat、iotop、uptime、pidof、tty、taskset、pmap等。目前支持32位和64位的Linux、Windows、OS X、FreeBSD和Sun Solaris等操作系统. 安装install psutil```123### 基本使用#### 获取CPU时间 psutil.cpu_times()scputimes(user=650613.02, nice=22.14, system=154916.5, idle=16702285.26, iowait=68894.55, irq=3.38, softirq=7075.65, steal=0.0, guest=0.0) ``` psutil.process_iter()遍历所有进程 psutil.version_info[] psutil.net_connections寻找连接(用户)的个数，在OSX中需要root权限 psutil.NoSuchProcess, psutil.AccessDenied 参考文章 https://www.cnblogs.com/lfs2640666960/p/9330735.html 介绍的不错 bash: 未预期的符号 `newline’ 附近有语法错误:将&lt;&gt;换成’’ 关于elk 安装yum install -y elasticsearch安装在/usr/share/elasticsearch当中，启动在bin当中的elasticsearch。用./Bin…来启动 测试运行：curl ‘http://localhost:9200/?pretty&#39; 会得到 Elasticsearch 的实例。 而一个 集群 是一组拥有相同 cluster.name 的节点， 他们能一起工作并共享数据，还提供容错与可伸缩性。(当然，一个单独的节点也可以组成一个集群) 你可以在 elasticsearch.yml 配置文件中 修改 cluster.name ，该文件会在节点启动时加载 (译者注：这个重启服务后才会生效)。 而elasticsearch中的.yml在/etc/elasticsearch当中 设置：logstash，netflow，配置 可以用端口9200，web客户端，甚至curl进行交互 curl -X ‘://:/?‘ -d ‘‘ 使用参考 会遇到问题：Exception in thread “main” org.elasticsearch.bootstrap.BootstrapException: java.nio.file.NoSuchFileException: /usr/share/elasticsearch/configLikely root cause: java.nio.file.NoSuchFileException: /usr/share/elasticsearch/config …解决方法其实就是： cp -r /etc/elasticsearch /usr/share/elasticsearch/config➜ ~ groupadd elsearch➜ ~ useradd elsearch -g elsearch -p elsearch➜ ~ cd /usr/share➜ chown -R elsearch:elsearch elasticsearch➜ su elsearch这是因为elasticsearch需要读写配置文件，我们需要给予config文件夹权限，上面新建了elsearch用户，elsearch用户不具备读写权限，因此还是会报错，解决方法是切换到管理员账户，赋予权限即可：sudo -ichmod -R 775 config这篇讲的很全 安装sense其实这个是Kibana的一个应用安装：yum install -y kibana测试运行也是一样的路径 http://localhost:5601/app/sense这个是emmm，测试？ 关于javaAPI交互节点客户端（Node client） 节点客户端作为一个非数据节点加入到本地集群中。换句话说，它本身不保存任何数据，但是它知道数据在集群中的哪个节点中，并且可以把请求转发到正确的节点。传输客户端（Transport client） 轻量级的传输客户端可以将请求发送到远程集群。它本身不加入集群，但是它可以将请求转发到集群中的一个节点上。两个 Java 客户端都是通过 9300 端口并使用 Elasticsearch 的原生 传输 协议和集群交互。集群中的节点通过端口 9300 彼此通信。如果这个端口没有打开，节点将无法形成一个集群。 安装elasticsearch-head遇到的问题 warning: notsup SKIPPING OPTIONAL DEPENDENCY: Unsupported platform for fsevents@1.2.4: wanted {“os”这个证明已经安装成功了 npm WARN elasticsearch-head@0.0.0 license should be a valid SPDX license expression这个说你的license不对口，得去找找spdx licence是个啥玩意：既然知道spdx是个啥，就不难解决问题了；让我打开正确的姿势：打开elasticsearch-head目录下的package.json文件，找到license位置，修改为上面这个网站上存在Identifier，就可以了。如图所示，把原来的Apache内容修改为Apache-2.0。具体修改后的内容参考官网上的Identifier数值（防止后续更新，授之于渔了）。 成功！ 妈的，又不成功：This account is currently not available（用户当前不可用）安装完elasticsearch之后系统会自动创建一个elasticsearch用户，在启动elasticsearch的时候需要切换该用户启动，但是在我切换到elasticsearch用户的时候显示This account is currently not available。 查资料发现是因为该用户的shell不可用，查看/etc/passwd文件发现此用户的shell是/sbin/nologin需修改成/bin/bash elasticsearch-head中cluster health: not connected修改elasticsearch安装目录中 config/elasticsearch.ymlhttp.cors.enabled: truehttp.cors.allow-origin: “*”修改elasticsearch-head下Gruntfile.jsconnect: {server: {options: {hostname: ‘0.0.0.0’,port: 9100,base: ‘.’,keepalive: true}}}原文链接","categories":[{"name":"理论","slug":"理论","permalink":"https://jeffup.github.io/categories/%E7%90%86%E8%AE%BA/"}],"tags":[{"name":"网络流量","slug":"网络流量","permalink":"https://jeffup.github.io/tags/%E7%BD%91%E7%BB%9C%E6%B5%81%E9%87%8F/"},{"name":"python","slug":"python","permalink":"https://jeffup.github.io/tags/python/"}]},{"title":"算法实验","slug":"算法实验","date":"2019-11-10T03:05:40.000Z","updated":"2019-11-20T01:26:41.435Z","comments":true,"path":"2019/11/10/算法实验/","link":"","permalink":"https://jeffup.github.io/2019/11/10/%E7%AE%97%E6%B3%95%E5%AE%9E%E9%AA%8C/","excerpt":"简介：包括线性时间算法，最长递增子序列，以斐波那契堆实现迪杰斯特拉算法","text":"简介：包括线性时间算法，最长递增子序列，以斐波那契堆实现迪杰斯特拉算法 1. 线性时间选择（序数问题） 问题描述：已知n个数，找出排序后第k小的数。要求平均时间复杂度为O(n)。 解决思路：使用快速排序的思想解决查找问题，用随机数（舍伍德算法）解决基准问题，用分治策略搭建整体的算法结构。 步骤分析：(1) 使用舍伍德算法选择基准r（第r个数）(2) 用快速排序算法进行下面的操作：将大于基准的数值放于基准后，将小于基准的数值放于基准前，刷新数组的排序。(3) 若想要查找的第k个数值的k比基准r大，则取数组的右边再重复进行以上操作，若小于，则选择左边的，若等于，则输出。 示例： 示例分析：输入10个数，分别为5 2 7 8 9 0 1 3 4 6，第5小的元素为4，验证成功。 2. 最长递增子序列问题 问题描述：寻找最长递增的序列。 解决思路：利用矩阵记录之前的结果，用动态规划法完成寻找 算法步骤：(1) 设置变量有：存储当前最长序列的值的数组tempmax，存储最长序列长度maxlen存储最长序列的最大值下标maxindex(2) 从下标为1的值开始遍历(3) 若i下标下的值比前一个值大，则更新tempmax[i]=tempmax[i-1]+1，即增加长度1，若此时的tempmaxp[i]比maxlen大，则更新maxlen，且更新maxindex=1 示例：示例分析： 输入10个数分别为1 3 2 4 5 3 7 8 9 6，其最长递增子序列为3 7 8 9，长度为4，验证成功。 3. 斐波那契堆实现最短路径算法（迪杰斯特拉） 问题描述：用斐波那契堆取最小路径辅助迪杰斯特拉算法实现最小路径算法 解决思路：1. 使用贪心算法实现迪杰斯特拉最短路径算法，使用斐波那契堆建立最小堆，方便取最小‘结点’以完成接下来的操作 算法思想： 迪杰斯特拉伪代码： 123456789DIJKSTRA(G, w, s)INITIALIZE - SINGLE - SOURCE(G, s)S ← ØQ ← V[G] //第3行，INSERT操作，O（1）构造堆while Q ≠ Ø do u ← EXTRACT - MIN(Q) //第5行，从堆中取出最小点 S ← S ∪&#123; u &#125; for each vertex v ∈ Adj[u] do RELAX(u, v, w) //第8行，RELAX操作，对堆进行降级工作 其中在第5行的EXTRACT-MIN操作用斐波那契堆实现，斐波那契堆结构如下: 斐波那契堆是由一组最小堆有序树构成的。每个节点的度数为其子节点的数目。树的度数为其根节点的度数。 斐波那契堆中的树都是有根的但是无序。每个节点x包含指向父节点的指针p[x]和指向任意一个子结点的child[x]。x的所有子节点都用双向循环链表链接起来，叫做x的子链表。子链表中的每一个节点y都有指向它的左兄弟的left[y]和右兄弟的right[y]。如果节点y是x仅有的子节点，则left[y]=right[y]=y。 斐波那契堆中所有树的根节点也用一个双向循环链表链接起来。使用一个指针指向斐波那契堆中最小元素。 用稀疏矩阵表示图，定义为weight 具体实现示例分析： 其矩阵如： {0,4,NoEdge,2,NoEdge}, {4,0,4,1,NoEdge}, {NoEdge,4,0,1,3}, {2,1,1,0,7},{NoEdge,NoEdge,3,7,0}最终应该得到结果：a-&gt;a=0a-&gt;d-&gt;b=3a-&gt;d-&gt;c=3a-&gt;d=2a-&gt;d-&gt;c-&gt;e=6 测试成功！","categories":[{"name":"代码编程","slug":"代码编程","permalink":"https://jeffup.github.io/categories/%E4%BB%A3%E7%A0%81%E7%BC%96%E7%A8%8B/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://jeffup.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"C++","slug":"C","permalink":"https://jeffup.github.io/tags/C/"},{"name":"课程","slug":"课程","permalink":"https://jeffup.github.io/tags/%E8%AF%BE%E7%A8%8B/"}]},{"title":"Hello World","slug":"hello-world","date":"2019-11-10T02:19:20.246Z","updated":"2019-11-11T06:13:02.844Z","comments":true,"path":"2019/11/10/hello-world/","link":"","permalink":"https://jeffup.github.io/2019/11/10/hello-world/","excerpt":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. HEXO常用：新建文章1$ hexo new \"My New Post\" More info: Writing 启动本地镜像服务1$ hexo server More info: Server 生成静态文件1$ hexo generate More info: Generating 上传文件（同步）12$ hexo deploy$ hexo d 也可 More info: Deployment 常要注意的玩意：hexo图片问题hexo阅读更多1npm install hexo-generator-index2 --save 12345678# index2 generator是否包含官方的hexo-generator-index，默认true（包含）index2_include_index: trueindex2_generator: per_page: 8 order_by: -date # 按发布时间排序 exclude: - tag hide # 不包含标签为hide的文章 - category hide # 不包含分类为hide的文章 然后 博客设置问题：头像&amp;图标：在主题目录下配置文件中.头像： 12345author: name: DuK work: Study,0-1 location: China avatar_url: /images/avatar.png 而其图标： 1favicon: /images/favicon.ico 网站：图标制作 侧边栏目（标签，归档）得先进行 1hexo new page tags 然后才会有，这里tags还要加上： 12345---title: tagsdate: 2019-11-10 11:36:27layout: tags---","categories":[],"tags":[{"name":"配置","slug":"配置","permalink":"https://jeffup.github.io/tags/%E9%85%8D%E7%BD%AE/"},{"name":"博客","slug":"博客","permalink":"https://jeffup.github.io/tags/%E5%8D%9A%E5%AE%A2/"},{"name":"指令","slug":"指令","permalink":"https://jeffup.github.io/tags/%E6%8C%87%E4%BB%A4/"}]}]}