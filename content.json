{"meta":{"title":"DuK_Blogs","subtitle":"","description":"","author":"DuK","url":"https://jeffup.github.io","root":"/"},"pages":[{"title":"about","date":"2019-11-10T03:36:04.000Z","updated":"2019-11-10T03:36:04.773Z","comments":true,"path":"about/index.html","permalink":"https://jeffup.github.io/about/index.html","excerpt":"","text":""},{"title":"search","date":"2019-11-10T04:00:01.000Z","updated":"2019-11-10T04:00:01.331Z","comments":true,"path":"search/index.html","permalink":"https://jeffup.github.io/search/index.html","excerpt":"","text":""},{"title":"tags","date":"2019-11-10T03:36:27.000Z","updated":"2019-11-10T05:41:08.515Z","comments":true,"path":"tags/index.html","permalink":"https://jeffup.github.io/tags/index.html","excerpt":"","text":""},{"title":"archives","date":"2019-11-10T03:36:47.000Z","updated":"2019-11-10T03:36:47.668Z","comments":true,"path":"archives/index.html","permalink":"https://jeffup.github.io/archives/index.html","excerpt":"","text":""}],"posts":[{"title":"工具OllyDbg的使用","slug":"工具OllyDbg的使用","date":"2019-11-10T08:08:12.000Z","updated":"2019-11-10T08:08:12.507Z","comments":true,"path":"2019/11/10/工具OllyDbg的使用/","link":"","permalink":"https://jeffup.github.io/2019/11/10/%E5%B7%A5%E5%85%B7OllyDbg%E7%9A%84%E4%BD%BF%E7%94%A8/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"汇编语言(入门学习)","slug":"汇编语言-入门学习","date":"2019-11-10T06:57:39.000Z","updated":"2019-11-16T02:51:13.461Z","comments":true,"path":"2019/11/10/汇编语言-入门学习/","link":"","permalink":"https://jeffup.github.io/2019/11/10/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80-%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0/","excerpt":"简介：本篇旨在对汇编的基础知识进行汇总，汇总的都是要点（简明扼要），目前还在更新中。","text":"简介：本篇旨在对汇编的基础知识进行汇总，汇总的都是要点（简明扼要），目前还在更新中。 第一章 基础知识1.1 存储单元一个存储单元存储的信息量以bit为单位（最小）。而转换关系中8 bit=1 bytes(B)。而一个字=两个字节在微型计算机存储器的存储单元中，一个单元可以存1 B（即8个进制位）。而一个存储器有128个单元，则可以存储128 B。 1.2 CPU对存储器的读写要读写，则应该与三类信息进行交互： 地址信息 控制信息 数据信息 而逻辑上又分为3类总线，分别传输信息： 地址总线（指出内存中的信息放在那里(自下而上读01)） 控制总线（若要传输的数据多于一次性传输的宽度，则分开来多传几次） 数据总线 1.2.1 影响性能的因素：宽度（线的条数）：它决定了部件的能力（速度，控制能力等）。8086为16条，8088为8条 若CPU的寻址能力为8KB，则总线宽度：8*1024/1 = 2**13 (注意单位是B,13则为总线宽度) 第二章 寄存器2.1 通用寄存器有AX BX CX DX四种，它们分为高位和低位以兼容以前的程序，如（AX = AH(高) + AL(低)）要注意的是：若只用AL进行运算，若超出其范围，超出的数据不会到AH当中！ 2.2 CPU给出物理地址的方法 段地址(SA)：只是为了内存的管理，并不是真分段。16位地址分段，一段64KB偏移地址(EA)：16位地址最多64KB公式：物理地址=段地址*16+偏移地址 2.3 段寄存器有CS DS SS ES四种。CS常存储段地址。它们提供了一下功能： CS：CPU要执行指令的地址。相当于命令指针 DS：读取内存的地址（返回数据）。相当于数据指针 SS：存储内存中的栈的顶。相当于栈顶指针 2.3.1 CS和IPIP是存储基于CS的偏移量。修改的流程： 一般流程：读取指令 -&gt; 修改 IP+=命令长度 -&gt; 执行指令(可能会涉及修改CS:IP) -&gt; 读取指令…8086PC启动时在FFFF0H单元中读取指令执行 2.4 疑问1. 为什么偏移地址只能在64Kb内？一个16位的CPU，只能有1111 1111 1111 1111，代表了4个16进制数，所以能表示2**16 bit的数据，恰好，就是64Kb。 2.暂留第三章 寄存器（内存访问）3.1 内存中字的存储 字单元的概念：即存放一个字型数据的内存单元，由两个地址连续的内存单元（一个8位）组成。高放高位，低放低位。 这里解释一下： 若有单元[0]-&gt;2e，[1]-&gt;33，那么我们读[0]的字型数据为：332eH（高放高位） 3.2 DS和[address] “[…]”表示一个内存单元，表示在段地址下的偏移量。如10000H = 1000:0 = [0] 在masm汇编编辑器中，如果单纯写mov ax,[0]，那么他会把[0]当做0来解释，即指令变成：mov ax,0而若用bx作为中转，那是可以的！如： 12mov bx,0mov ax,[bx] 这个是可以把[bx]当成段地址，返回ds:bx下的数据的！而如果偏要用[idata]的话，那么就必须加上ds:前缀，如： 1mov ax,ds:[0] 而对于Debug编译器的话，ds是自动加上的，用 1mov ax,[0] 即可，如果使用[]的话，而且他（段寄存器）是不能直接用mov命令改变的，必须通过其他的寄存器中转才能改变。 3.3 字的传送（mov指令）在传送字之后， DS和[address]也会跟着变，如1000:0，若传入一个fffeH，则address会从0-&gt;2，此时，[0]存有feH，[1]存有ffH,[2]为空。 3.4 mov、add、sub指令主要是说说置零问题，与机械码长度问题，稍微提一下，以后会细讲。举例子： 12sub bx, bxmov bx, 0 两个都是可以将bx寄存器置零的指令，但是sub的机械码长度为2，而mov为3，用sub更好。另外说说jmp指令，他是转移指令，具有一个操作对象的指令，而上面的具有两个。 3.5 栈他是一个FILO结构（先入后出），而且是从大变小（地址）。 3.5.1 push和pop 执行push ax命令，会把ax中的数据传入ss:sp指向的地址空间。此时sp-=2执行pop ax命令，会把ss:sp指向的地址空间中的数据传给ax。此时sp+=2 执行之后的指针变化： push先令sp-=2，然后将ax中的数据放进去。称为出栈。 pop是先取出数据放到ax中，再sp+=2。称为入栈。 3.5.2 数据传输如8086cpu的入栈和出栈都是以字为单位进行的。 3.5.3 栈指针上面已经用到了：段寄存器:寄存器存储(ss:sp)sp是指偏移地址，ss:sp始终指向栈顶。 3.6 栈顶越界问题栈溢出问题都是大问题，如果栈顶越界了，那么执行push和pop会受影响吗？当然不会！直接刚，写！写！写！出！出！出！管你呢。所以就会有可能读了其他程序的数据，或者修改了（覆盖）其他程序的数据（直接崩溃的说）执行情况（取自《汇编语言第二版》王爽著） 3.7 问题1.程序与数据有区别吗？可以说有，也可以说没有。由于指令都是0和1组成的，只是用不同功能的段地址读出来的不一样，如,CS和DS都指向10000H，那么，CS会将里头的数据转化为机械码，执行指令，而DS就直接读数据，作为单纯的数据使用。 2.空栈如（10000H~1000FH）此时ss=1000H，那么sp是多少？因为是自下而上（自大到小），所以sp=0010H。换一种方式看，若存储了一个数据，则一个存到000EH，一个存到000FH，此时的栈指针在栈顶，当然指向000EH了，此时是已经让sp-=2了，那么回溯一下，不就有sp=0010H了。 好了，问题来了，如果将（10000H~1FFFFH）作为空间呢？答案：sp=0000H，因为，不能变成10000H(笑) 3.栈会溢出，那么，为什么不设置栈大小emmm，可惜8086cpu就是没有，所以变成自己注意。 4.只有mov可以完成传输数据吗？push也可以哦，只要把sp定位为ds:[address]那就好了哦。直接写进去。 第四章 第一个程序4.1 一个源程序从写出到执行的过程如图：执行过程包括：写程序-&gt;编译连接成可执行文件-&gt;执行。 可执行文件文件中包括以下两部分： 程序和数据 相关的描述：程序多大，占用多少运行空间 4.2 源程序4.2.1 伪指令也就是只能被编译器识别的指令，如assume、segment、end等，这是没有机械码的。一般的伪指令使用如下： 12345assume cs:code #声明（假设）cs:段名（标号）code segment #段名 segment_指令_code ends #对应segment，表示一个段结束end #对应assume，表示程序结束 4.2.2 程序返回现在考虑，如何让上一个程序把CPU控制权交给写一个程序，这时候就要使用程序返回其代码如下： 12mov ax, 4c00Hint 21H 4.3 程序生成流程编程 -&gt; 1.asm -&gt; 编译 -&gt; 1.obj -&gt; 连接 -&gt; 1.exe -&gt; 加载 -&gt; 内存中的程序 -&gt; 运行注：加载就是将程序加载到内存，执行就是在内存中执行程序的指令 4.4 怎么装载程序？操作系统是一个模块组成庞大的系统。任何通用的系统都要提供一个称为shell的程序，用户使用这个程序来操作计算机系统进行工作。 如DOS中有一个程序command.com，这个程序称为：命令解释器，也就是DOS中的SHELL（其实跟我们的cmd.exe差不多） 先运行shell，然后在加载1.exe可执行程序的时候，cmd会自动把cpu的控制权交给1.exe，执行完成再返回cmd。 4.4 展示EXE的加载过程 第五章 [BX]和loop指令5.1 [BX]这个之前就讲过：其实就是把BX中的值作为ds的偏移地址EA，然后可以用这个来访问特定地址下的数据。如ds:1000H，bx=0001H，那么[BX]就是指ds*16+bx下的值。 5.2 loop直接上程序： 12345678assume cs:eloopeloop segment mov ax,128 mov cx,36 s:add ax,ax loop seloop endsend 解释： loop是按照cx当中的值进行对有标号的s下的命令进行循环的。当cx不等于0，则执行循环，这个程序实际上是实现128*36的程序。 s实际上是IP值，指向s标记的地址，所以loop s实际上是给IP赋值：IP=s，然后就可以通过cs:ip来执行指令了 注意：汇编程序中，数据不能以字母开头，所以要在前面加个0。比如：9138h可以写成9138h，而A000h就必须写成0A000h 5.3 loop和[bx]的联合运用例如来一个如同C++语言中的： 123456int dx = 0;int ds[12] = &#123;1, 2, ...&#125;;for(int i=0; i &lt; 12; i++)&#123; dx += ds[i];&#125; 那么汇编语言就有： 123456789101112131415161718192021assume cs:codecode segment: mov ax, 0ffffh ;因为ds寄存器不能直接赋值，所以用ax作为中间变量 mov ds,ax mov bx,0 ;初始化ds:bx指向ffff:0 mov dx,0 ;初始化**累加寄存器**dx，让值为0 mov cx,12 ;初始化循环计数寄存器cx，令值为12，指循环12次 s: mov al,[bx] ;以下两步执行ax的赋值操作 mov ah,0 ; add dx,ax ;执行加法 inc bx ;ds:bx指向下一个单元，因为bx的值增加了1，相当于C++代码中的*i++* loop s ;loop完成一次，则cx=cx-1，然后判断cx是否等于0，如果等于则退出循环 mov ax,4c00h int 21hcode endsend 好了，现在来说说这段代码里面有什么需要注意的点： cx寄存器一般用作loop循环的判断条件，即循环的粗次数。 ax寄存器的初始化有两步，是，因为一个字符型数据是8位这样的话转化为16位就得让高8位的值赋为0。 dx寄存器是常用的累加寄存器。 inc指令是让后面的值加一的指令，相当于C++语言中的‘++’自增。 int指令： 由int 指令引发的中断是一种重要的内中断。格式： int n //相当于引发一个n号中断的过程,最终功能和call指令相似，都是调用一段程序。 取中断类型码n 标志寄存器入栈，并IF=0,TF=0 //TF=0使得避免中断程序执行过程中引发单步中断 CS,IP寄存器入栈 IP=(n*4) , CS=(n*4 + 2)原文链接 5.4 段前缀与其使用 能够显示地指令内存单元的段地址的，如：”ds:”、”cs:”、”ss:”、”es:”。这就是段前缀。 默认的[x]是指：(dx*16)+x，而如果要用其他的段寄存器，则需要加上它的段前缀。 第六章 包含多个段的程序 由于软件是由数据和程序组成的，数据当然也是程序里面必不可少的部分，所以会将代码分为多段进行，如数据段、代码段等。 6.1 在代码段中使用数据 汇编程序若没有特殊的说明（或者注明在哪里开始），则默认从头开始！所以，一旦你的程序头部有数据，则将会把头部的数据翻译为机器码执行。(冤) 那么解决方式是：在开始执行代码的地方加上 start: 123456789101112131415assume cs:codecode segment dw 0123h,0456h,0789h ;这里是数据部分 dw意思是定义字符型数据 start: mov bx,0 ;注意，从这开始，标识为start! mov ax,0 mov cx,8 s: add ax,cs:[bx] ;用cs作为段地址，取数据！ add bx,2 loop s mov ax,4c00h int 2hcode endsend start ;注意end后面要加上end开始的名称！ 6.2 将数据、代码、栈放入不同的段上面说了，代码从哪里开始就在哪里加上start，结束就用end start（其他标识也行）好，记住，那是代码，别把接下来说的混淆了。 不同的段可以放不同的东西，例如数据，代码等等。只要记住将段名end了再定义其他段。也只有定义了，才能使用这个段 123456789101112131415161718192021222324252627282930313233assume cs:b,ds:a,ss:ca segment dw 0123h, 0456h, 0789h, 0abch, 0de fh, Ofedh, 0cbah, 0987ha endsc segment dw 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0c endsb segmentd: mov ax,c ;使用段c中的数据 mov ss,ax mov sp, 20h ;希望用c段当作栈空间，设置ss:sp指向c:20 mov ax,a ;使用段a mov ds,ax ;希望用ds:bx访问a段中的数据，ds指向a段 mov bx,0 ;ds:bx指向a段中的第一一个单元 mov Cx,8s: push [bx] add bx,2 1oop s ;以上将a段中的0~15单元中的8个字型数据依次入栈 mov bx,0 mov cx, Bs0: pop [bx] add bx,2 1oop s0 ;以上依次出栈8个字型数据到a段的0~15单元中 mov ax, 4c00hint 21hb endsend d ;d处是要执行的第一- 条指令，即程序的入口 第七章 更灵活的定位内存地址的方法之前的[0]和[bx]均可以起到定位的作用，现在有更灵活的定位方式： 7.1 and和or指令 and是有零变零，而or是有一变一也可以想象成and是乘法，or是加法 7.2 以字符型给出数据凡是以’…’形式给出数据的，都被译为是字符型数据，这样，编译器会将里面的数据变成ASCII码值。具体实例： 12db &apos;unIX&apos;mov al,&apos;a&apos; 这里被译为 12db 75H,6EH,49H,58Hmov al,61H 而大小写转换的方法有两种： 基于比较的，在ASCII码中，大写字母+20H=小写字母 基于二进制数的，在ASCII表达字符时，若第五位为0，则为大写字母；若第五位为1则为小写字母（这里可以用or或者and来进行转换） 7.3 以[bx+idata]的方式寻址现在以例题进行解析，将第一组字符串变成大写，第二组变成小写 123456789assume cs:codesg,ds:datasgdatasg segment db &apos;BaSiC&apos; db &apos;MinIX&apos;datasg endscodesg segmentstart: ;代码段codesg endsend start 原来的思想：取[bx]中的字符，再对其进行and 11011111b操作，再放回去，然后将bx自增，再重新···，而变成小写就or 00100000b。（这里要执行两次循环啊，一个变大写，一个变小写） 然而我们可以使用以下思想，更加便捷，就是[bx+idata]：思想和前面的一样，但是，不用执行两次循环，只要一次就够了：12345678910111213 mov ax,datasg mov ds, ax mov bx,0 mov cx,5s:mov al,[bx] ;定位第一个字符串的第bx个字符 and al,11011111b ;执行完变大工作 mov [bx],al ;放回去 mov al[5+bx] ;定位第二个字符串的第bx个字符（因为一个字符串只有5个字符） or al,00100000b ;执行变小工作 mov [5+bx],al ;放回去 inc bx ;自增 loop s 这个其实，学过高级语言都知道这方法，只不过，没想到汇编也能做吧，汇编语言也不是那么死板的。 7.4 si与di寄存器和多重循环这个只要知道是16位寄存器，功能和bx差不多，可以用作[bx+si+idata]和[bx+di+idata]就可以了。其中，idata是常量，其他的为变量。这个结构可以执行二重循环，相当于处理二维数组。需要注意的是二重循环的实现： 问题一：cx寄存器是用作循环的判定条件的，那么二重循环对于没有两个cx的我们来说，如何是好？将之前的cx用其他寄存器保存起来啊！ 问题二：二重循环可以那样做，那么多重循环呢！？你只有有限个寄存器。利用内存空间！开辟一段dw 0，让后指向它，放进去就完事了。 问题三：那这个方法的前提是我得知道有多少个循环，很麻烦啊，换个简单的。 在需要暂存数据的时候我们都应该使用栈* 在需要暂存数据的时候我们都应该使用栈* 在需要暂存数据的时候我们都应该使用栈*按顺序push，然后逆向按顺序pop 第八章 数据处理的两个基本问题这两个问题是： 处理的数据在什么地方 要处理的数据有多长 8.1 bx、si、di和bp这几个都用过，主要说说bp:这个只要在[…]里使用了它，没有段地址声明，那么默认是ss 8.2 机器指令处理的数据在什么地方在指令执行前，所要处理的数据可以在三个地方： CPU内部 内存 端口下面举例子：上图还表明了汇编语言中数据位置的表达 立即数（idata）：如上图的最后一个例子，是直接赋值的 寄存器：如上图的第二个例子，使用寄存器名。 段地址：如果是[bx]则默认段地址是ds，如果是[bp]则默认段地址为ss，当然可以显性给出。 8.3 指令处理的数据长度这个得看具体例子。 如果是ax,bx，那么这个就是字操作 如说是al,bl，那么就是字节操作 在没有寄存器名存在的情况下，用操作符X ptr指明内存单元的长度，X在汇编中可以为word或byte（且必须显式声明）。 12mov word ptr ds:[0],1 ;字mov byte ptr ds:[0],1 ;字节 有些指令默认了访问的是字还是字节，如push默认进行字操作，而用[…]的是字单元操作(一个8位)。 8.4 div指令div是除法指令，使用div做除法的时候应注意以下问题. 除数:有8位和16位两种，在一个reg或内存单元中。 被除数:默认放在AX或DX和AX中 如果除数为8位，被除数则为16位，默认在AX中存放； 如果除数为16位，被除数则为32位，在DX和AX中存放，DX存放高16位，AX存放低16位。 结果: 如果除数为8位，则AL存储除法操作的商，AH存储除法操作的余数: 如果除数为16位，则AX存储除法操作的商，DX存储除法操作的余数。 格式如下： 12345div regdiv 内存单元div byte ptr ds:[0]含义：(al)=(ax)/((ds)*16+0)的商 (ah)=(ax)/((ds)*16+0)的余数 8.5 实例利用除法指令计算100001/100分析： 由于100001大于整数最大值（16位）65535，不能用ax寄存器存放，所以只能用dx和ax两个寄存器联合存放，共32位 而出书100小于255（8位），但是因为被除数是32位，所以除数应该用16位的来存放除数100所以有程序： 1234mov dx,1mov ax,86A1H ;(dx)*10000H+(ax)=100001 100001=186A1Hmov bx,100div bx 执行后，(ax)=03E8H(即10000)，(dx)=1(余数为1)。 8.6 伪指令dd之前有学过用db和dw定义字节型数据和字型数据。dd是用来定义dword（double word，双字）型数据的。 db 占1个字节 dw 占1个字（即两个字节） db 占2个字（即四个字节） 8.7 dupdup是一个操作符，在汇编语言中与dw,db,dd一样，都是由编译器识别处理的符号，且与它们一同配合使用，用来进行数据重复。如： 123456789db 3 dup (0)定义了3个字节，它们的值都是0，相当于执行了 db 0,0,0。db 3 dup (1,2,3)定义了3\\*3=9个字节，它们是0、1、2、0、1、2、0、1、2，相当于db 0,1,2,0,1,2,0,1,2。字符型也适用。总结：d？ 重复的次数 dup (重复的(字节/字/双字型)数据） 第九章 转移指令的原理可以修改IP 或同事修改CS和IP的指令统称为转移指令统称为转移指令。如jmp、jno等，即可以控制CPU指令内存中某处代码的指令。具体分类有： 无条件转移指令（jmp） 条件转移指令（jno） 循环指令（loop） 过程 中断 还有其他的分类： 只修改IP：段内转移（jmp ax） 同时修改CS和IP：段间转移（jmp 1000:0） 短转移 近转移 9.1 操作符offsetoffset是编译器处理符号，功能：取得标号的额编译地址。如： 12start: mov ax, offset start ;相当于mov ax,0 s: mov ax, offset s ;相当于mov ax,3 解析：第一条指令mov … 是三个字节，所以s段的offset为3 9.2 jmp指令和依据译为进行转移的jmp指令9.2.1 jmp short 标号(转移到标号出执行指令)1. short标号下，它属于段内短转移，对IP的修改范围为-128~127。9.2.2 立即数在机器码中的表示在一般的汇编指令当中，汇编指令的idata（立即数），不论他是表示一个数据还是内存单元的偏移地址，都会在相应的机器指令中出现，因为CPU执行的是机器指令，他必须处理这些数据或地址。 123mov ax,0123h B8 23 01mov ax,ds:[0123h] A1 23 01push ds:[0123h] FF 36 23 01 9.2.3 jmp转移的机制（是怎么实现转移的）12345start: mov ax,0 mov bx,0 jmp short s add ax,1 s: inc ax 首先我们应该知道，jmp指令是2个字节，如代码中的jmp机械码是：EB 03 。这样的机械码，没有包含s段的地址！所以将jmp指令写入内存之后，IP=IP+2=0008h。 但是，执行完jmp后，IP=000Bh。因为执行JMP，就是执行IP=IP+(EB之后的偏移量)=IP+3=000Bh。 所以jmp执行的是给IP加偏移地址！。 所以 jmp short 标号 的功能为：(ip)=(ip)+8位位移 9.2.4 继续上面的，8位位移是怎么得出来的？ 8位位移=标号处的地址 - jmp指令后的第一个字节的地址. short指明此处的位移为8位位移; 8位位移的范围为-128-127，用补码表示 8位位移由编译程序在编译时算出。 还有一种和”jmp short标号”功能相近的指令格式:jmp near ptr标号它实现的是段内近转移。功能为:(IP)=(LP)+16位位移。(1) 16位位移=标号处的地址 - jmp指令后的第一个字节的地址:(2) near ptr指明此处的位移为16位位移，进行的是段内近转移:(3) 16位位移的范围为一32768~32767，用补码表示:(4) 16位位移由编译程序在编译时算出。 9.2.5 jmp far ptr 标号（段间转移/远转移）是不是所有的jmp机械码都没有段数据呢？当然不是！小标题就说到了：far ptr，这个指令用标号的段地址和偏移地址修改CS和IP如：解释：“OB 01 BD 0B”是目的地之在指令中的存储顺序：高地址：“BD 0B”是段地址 0BBDH ；低地址：“0B 01”是偏移地址 010BH ； 9.2.6 转移地址在寄存器的jmp指令(这就相当于总结了，上面废话有点多) 若只是一个字，则只是偏移地址（直接EB ??完事） 若是两个字，那么一个是段，一个是偏移地址。 9.3 jcxz指令该指令为有条件转移指令，所有的有条件转移指令都是短指令，即上面9.2.6说的1个字，只有位移（偏移地址），对ip的修改范围是：-128~127. 指令格式：jcxz 标号如果(cx)=0，则转移到标号这 9.4 loop指令也是短转移指令，pass 9.5 编译器对转移位移超界的检测编译的时候就会出错！因为，这超界，编译器可识别不了。这不存在的玩意儿。","categories":[{"name":"理论","slug":"理论","permalink":"https://jeffup.github.io/categories/%E7%90%86%E8%AE%BA/"},{"name":"代码编程","slug":"理论/代码编程","permalink":"https://jeffup.github.io/categories/%E7%90%86%E8%AE%BA/%E4%BB%A3%E7%A0%81%E7%BC%96%E7%A8%8B/"}],"tags":[{"name":"汇编","slug":"汇编","permalink":"https://jeffup.github.io/tags/%E6%B1%87%E7%BC%96/"},{"name":"二进制","slug":"二进制","permalink":"https://jeffup.github.io/tags/%E4%BA%8C%E8%BF%9B%E5%88%B6/"}]},{"title":"网络流量分析（nogotofail））","slug":"网络流量分析-nogotofail","date":"2019-11-10T06:50:53.000Z","updated":"2019-11-15T11:54:33.898Z","comments":true,"path":"2019/11/10/网络流量分析-nogotofail/","link":"","permalink":"https://jeffup.github.io/2019/11/10/%E7%BD%91%E7%BB%9C%E6%B5%81%E9%87%8F%E5%88%86%E6%9E%90-nogotofail/","excerpt":"应用范围它包括对常见的SSL证书验证问题(HTTPS和TLS/SSL)的测试库bug、SSL和STARTTLS剥离问题、明文问题等等。","text":"应用范围它包括对常见的SSL证书验证问题(HTTPS和TLS/SSL)的测试库bug、SSL和STARTTLS剥离问题、明文问题等等。 应用到的库：psutil模块psutil是一个跨平台库能够轻松实现获取系统运行的进程和系统利用率（包括CPU、内存、磁盘、网络等）信息。它主要用来做系统监控，性能分析，进程管理。它实现了同等命令行工具提供的功能，如ps、top、lsof、netstat、ifconfig、who、df、kill、free、nice、ionice、iostat、iotop、uptime、pidof、tty、taskset、pmap等。目前支持32位和64位的Linux、Windows、OS X、FreeBSD和Sun Solaris等操作系统. 安装install psutil```123### 基本使用#### 获取CPU时间 psutil.cpu_times()scputimes(user=650613.02, nice=22.14, system=154916.5, idle=16702285.26, iowait=68894.55, irq=3.38, softirq=7075.65, steal=0.0, guest=0.0) &gt; 1. psutil.process_iter() 遍历所有进程 2. psutil.version_info[] 3. psutil.net_connections 寻找连接(用户)的个数，在[OSX](https://baike.baidu.com/item/mavericks/4902413?fr=aladdin)中需要root权限 4. psutil.NoSuchProcess, psutil.AccessDenied [参考文章](https://www.cnblogs.com/saneri/p/7528283.html) https://www.cnblogs.com/lfs2640666960/p/9330735.html 介绍的不错 5. bash: 未预期的符号 `newline&apos; 附近有语法错误:将&lt;&gt;换成&apos;&apos; # 关于elk 1. 安装 yum install -y elasticsearch 安装在/usr/share/elasticsearch当中，启动在bin当中的elasticsearch。用./Bin...来启动 * 测试运行：curl &apos;http://localhost:9200/?pretty&apos; * 会得到![](elasticsuccess.jpg) * Elasticsearch 的实例。 而一个 集群 是一组拥有相同 cluster.name 的节点， 他们能一起工作并共享数据，还提供容错与可伸缩性。(当然，一个单独的节点也可以组成一个集群) 你可以在 elasticsearch.yml 配置文件中 修改 cluster.name ，该文件会在节点启动时加载 (译者注：这个重启服务后才会生效)。 * 而elasticsearch中的.yml在/etc/elasticsearch当中 * 设置：logstash，netflow，配置 * 可以用端口9200，web客户端，甚至curl进行交互 curl -X&lt;VERB&gt; &apos;&lt;PROTOCOL&gt;://&lt;HOST&gt;:&lt;PORT&gt;/&lt;PATH&gt;?&lt;QUERY_STRING&gt;&apos; -d &apos;&lt;BODY&gt;&apos; [使用参考](https://www.elastic.co/guide/cn/elasticsearch/guide/current/_talking_to_elasticsearch.html) * * 会遇到问题：Exception in thread &quot;main&quot; org.elasticsearch.bootstrap.BootstrapException: java.nio.file.NoSuchFileException: /usr/share/elasticsearch/config Likely root cause: java.nio.file.NoSuchFileException: /usr/share/elasticsearch/config ... [解决方法](https://www.cnblogs.com/yswenli/p/6397351.html) 其实就是： cp -r /etc/elasticsearch /usr/share/elasticsearch/config ➜ ~ groupadd elsearch ➜ ~ useradd elsearch -g elsearch -p elsearch ➜ ~ cd /usr/share ➜ chown -R elsearch:elsearch elasticsearch ➜ su elsearch 这是因为elasticsearch需要读写配置文件，我们需要给予config文件夹权限，上面新建了elsearch用户，elsearch用户不具备读写权限，因此还是会报错，解决方法是切换到管理员账户，赋予权限即可： sudo -i chmod -R 775 config [这篇讲的很全](https://www.linuxidc.com/Linux/2018-11/155518.htm) 安装sense 其实这个是Kibana的一个应用 安装：yum install -y kibana 测试运行也是一样的路径 http://localhost:5601/app/sense 这个是emmm，测试？ 关于javaAPI交互 节点客户端（Node client） 节点客户端作为一个非数据节点加入到本地集群中。换句话说，它本身不保存任何数据，但是它知道数据在集群中的哪个节点中，并且可以把请求转发到正确的节点。 传输客户端（Transport client） 轻量级的传输客户端可以将请求发送到远程集群。它本身不加入集群，但是它可以将请求转发到集群中的一个节点上。 两个 Java 客户端都是通过 9300 端口并使用 Elasticsearch 的原生 传输 协议和集群交互。集群中的节点通过端口 9300 彼此通信。如果这个端口没有打开，节点将无法形成一个集群。","categories":[{"name":"理论","slug":"理论","permalink":"https://jeffup.github.io/categories/%E7%90%86%E8%AE%BA/"}],"tags":[{"name":"网络流量","slug":"网络流量","permalink":"https://jeffup.github.io/tags/%E7%BD%91%E7%BB%9C%E6%B5%81%E9%87%8F/"},{"name":"python","slug":"python","permalink":"https://jeffup.github.io/tags/python/"}]},{"title":"算法实验","slug":"算法实验","date":"2019-11-10T03:05:40.000Z","updated":"2019-11-11T06:15:04.604Z","comments":true,"path":"2019/11/10/算法实验/","link":"","permalink":"https://jeffup.github.io/2019/11/10/%E7%AE%97%E6%B3%95%E5%AE%9E%E9%AA%8C/","excerpt":"简介：包括线性时间算法，最长递增子序列，以斐波那契堆实现迪杰斯特拉算法","text":"简介：包括线性时间算法，最长递增子序列，以斐波那契堆实现迪杰斯特拉算法 1. 线性时间选择（序数问题） 问题描述：已知n个数，找出排序后第k小的数。要求平均时间复杂度为O(n)。 解决思路：使用快速排序的思想解决查找问题，用随机数（舍伍德算法）解决基准问题，用分治策略搭建整体的算法结构。 步骤分析：(1) 使用舍伍德算法选择基准r（第r个数）(2) 用快速排序算法进行下面的操作：将大于基准的数值放于基准后，将小于基准的数值放于基准前，刷新数组的排序。(3) 若想要查找的第k个数值的k比基准r大，则取数组的右边再重复进行以上操作，若小于，则选择左边的，若等于，则输出。 示例： 示例分析：输入10个数，分别为5 2 7 8 9 0 1 3 4 6，第5小的元素为4，验证成功。 2. 最长递增子序列问题 问题描述：寻找最长递增的序列。 解决思路：利用矩阵记录之前的结果，用动态规划法完成寻找 算法步骤：(1) 设置变量有：存储当前最长序列的值的数组tempmax，存储最长序列长度maxlen存储最长序列的最大值下标maxindex(2) 从下标为1的值开始遍历(3) 若i下标下的值比前一个值大，则更新tempmax[i]=tempmax[i-1]+1，即增加长度1，若此时的tempmaxp[i]比maxlen大，则更新maxlen，且更新maxindex=1 示例：示例分析： 输入10个数分别为1 3 2 4 5 3 7 8 9 6，其最长递增子序列为3 7 8 9，长度为4，验证成功。 3. 斐波那契堆实现最短路径算法（迪杰斯特拉） 问题描述：用斐波那契堆取最小路径辅助迪杰斯特拉算法实现最小路径算法 解决思路：1. 使用贪心算法实现迪杰斯特拉最短路径算法，使用斐波那契堆建立最小堆，方便取最小‘结点’以完成接下来的操作 算法思想： 迪杰斯特拉伪代码： 123456789DIJKSTRA(G, w, s)INITIALIZE - SINGLE - SOURCE(G, s)S ← ØQ ← V[G] //第3行，INSERT操作，O（1）构造堆while Q ≠ Ø do u ← EXTRACT - MIN(Q) //第5行，从堆中取出最小点 S ← S ∪&#123; u &#125; for each vertex v ∈ Adj[u] do RELAX(u, v, w) //第8行，RELAX操作，对堆进行降级工作 其中在第5行的EXTRACT-MIN操作用斐波那契堆实现，斐波那契堆结构如下: 斐波那契堆是由一组最小堆有序树构成的。每个节点的度数为其子节点的数目。树的度数为其根节点的度数。 斐波那契堆中的树都是有根的但是无序。每个节点x包含指向父节点的指针p[x]和指向任意一个子结点的child[x]。x的所有子节点都用双向循环链表链接起来，叫做x的子链表。子链表中的每一个节点y都有指向它的左兄弟的left[y]和右兄弟的right[y]。如果节点y是x仅有的子节点，则left[y]=right[y]=y。 斐波那契堆中所有树的根节点也用一个双向循环链表链接起来。使用一个指针指向斐波那契堆中最小元素。 用稀疏矩阵表示图，定义为weight 具体实现示例分析： 其矩阵如： {0,4,NoEdge,2,NoEdge}, {4,0,4,1,NoEdge}, {NoEdge,4,0,1,3}, {2,1,1,0,7},{NoEdge,NoEdge,3,7,0}最终应该得到结果：a-&gt;a=0a-&gt;d-&gt;b=3a-&gt;d-&gt;c=3a-&gt;d=2a-&gt;d-&gt;c-&gt;e=6 测试成功！","categories":[{"name":"代码编程","slug":"代码编程","permalink":"https://jeffup.github.io/categories/%E4%BB%A3%E7%A0%81%E7%BC%96%E7%A8%8B/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://jeffup.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"C++","slug":"C","permalink":"https://jeffup.github.io/tags/C/"}]},{"title":"Hello World","slug":"hello-world","date":"2019-11-10T02:19:20.246Z","updated":"2019-11-11T06:13:02.844Z","comments":true,"path":"2019/11/10/hello-world/","link":"","permalink":"https://jeffup.github.io/2019/11/10/hello-world/","excerpt":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. HEXO常用：新建文章1$ hexo new \"My New Post\" More info: Writing 启动本地镜像服务1$ hexo server More info: Server 生成静态文件1$ hexo generate More info: Generating 上传文件（同步）12$ hexo deploy$ hexo d 也可 More info: Deployment 常要注意的玩意：hexo图片问题hexo阅读更多1npm install hexo-generator-index2 --save 12345678# index2 generator是否包含官方的hexo-generator-index，默认true（包含）index2_include_index: trueindex2_generator: per_page: 8 order_by: -date # 按发布时间排序 exclude: - tag hide # 不包含标签为hide的文章 - category hide # 不包含分类为hide的文章 然后 博客设置问题：头像&amp;图标：在主题目录下配置文件中.头像： 12345author: name: DuK work: Study,0-1 location: China avatar_url: /images/avatar.png 而其图标： 1favicon: /images/favicon.ico 网站：图标制作 侧边栏目（标签，归档）得先进行 1hexo new page tags 然后才会有，这里tags还要加上： 12345---title: tagsdate: 2019-11-10 11:36:27layout: tags---","categories":[],"tags":[{"name":"配置","slug":"配置","permalink":"https://jeffup.github.io/tags/%E9%85%8D%E7%BD%AE/"},{"name":"博客","slug":"博客","permalink":"https://jeffup.github.io/tags/%E5%8D%9A%E5%AE%A2/"},{"name":"指令","slug":"指令","permalink":"https://jeffup.github.io/tags/%E6%8C%87%E4%BB%A4/"}]}]}