{"meta":{"title":"DuK_Blogs","subtitle":"","description":"","author":"DuK","url":"https://jeffup.github.io","root":"/"},"pages":[{"title":"about","date":"2019-11-10T03:36:04.000Z","updated":"2019-11-10T03:36:04.773Z","comments":true,"path":"about/index.html","permalink":"https://jeffup.github.io/about/index.html","excerpt":"","text":""},{"title":"archives","date":"2019-11-10T03:36:47.000Z","updated":"2019-11-10T03:36:47.668Z","comments":true,"path":"archives/index.html","permalink":"https://jeffup.github.io/archives/index.html","excerpt":"","text":""},{"title":"search","date":"2019-11-10T04:00:01.000Z","updated":"2019-11-10T04:00:01.331Z","comments":true,"path":"search/index.html","permalink":"https://jeffup.github.io/search/index.html","excerpt":"","text":""},{"title":"tags","date":"2019-11-10T03:36:27.000Z","updated":"2019-11-10T05:41:08.515Z","comments":true,"path":"tags/index.html","permalink":"https://jeffup.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"工具OllyDbg的使用","slug":"工具OllyDbg的使用","date":"2019-11-10T08:08:12.000Z","updated":"2019-11-10T08:08:12.507Z","comments":true,"path":"2019/11/10/工具OllyDbg的使用/","link":"","permalink":"https://jeffup.github.io/2019/11/10/%E5%B7%A5%E5%85%B7OllyDbg%E7%9A%84%E4%BD%BF%E7%94%A8/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"汇编语言(入门学习)","slug":"汇编语言-入门学习","date":"2019-11-10T06:57:39.000Z","updated":"2019-11-11T06:16:56.496Z","comments":true,"path":"2019/11/10/汇编语言-入门学习/","link":"","permalink":"https://jeffup.github.io/2019/11/10/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80-%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0/","excerpt":"简介：本篇旨在对汇编的基础知识进行汇总，汇总的都是要点（简明扼要），目前还在更新中。","text":"简介：本篇旨在对汇编的基础知识进行汇总，汇总的都是要点（简明扼要），目前还在更新中。 第一章 基础知识1.1 存储单元一个存储单元存储的信息量以bit为单位（最小）。而转换关系中8 bit=1 bytes(B)。而一个字=两个字节在微型计算机存储器的存储单元中，一个单元可以存1 B（即8个进制位）。而一个存储器有128个单元，则可以存储128 B。 1.2 CPU对存储器的读写要读写，则应该与三类信息进行交互： 地址信息 控制信息 数据信息 而逻辑上又分为3类总线，分别传输信息： 地址总线（指出内存中的信息放在那里(自下而上读01)） 控制总线（若要传输的数据多于一次性传输的宽度，则分开来多传几次） 数据总线 影响性能的因素：宽度（线的条数）：它决定了部件的能力（速度，控制能力等）。8086为16条，8088为8条 若CPU的寻址能力为8KB，则总线宽度：8*1024/1 = 2**13 (注意单位是B,13则为总线宽度) 第二章 寄存器2.1 通用寄存器有AX BX CX DX四种，它们分为高位和低位以兼容以前的程序，如（AX = AH(高) + AL(低)）要注意的是：若只用AL进行运算，若超出其范围，超出的数据不会到AH当中！ 2.2 CPU给出物理地址的方法 段地址(SA)：只是为了内存的管理，并不是真分段。16位地址分段，一段64KB偏移地址(EA)：16位地址最多64KB公式：物理地址=段地址*16+偏移地址 2.2 段寄存器有CS DS SS ES四种。CS常存储段地址。它们提供了一下功能： CS：CPU要执行指令的地址。相当于命令指针 DS：读取内存的地址（返回数据）。相当于数据指针 SS：存储内存中的栈的顶。相当于栈顶指针CS和IPIP是存储基于CS的偏移量。修改的流程： 一般流程：读取指令 -&gt; 修改 IP+=命令长度 -&gt; 执行指令(可能会涉及修改CS:IP) -&gt; 读取指令…8086PC启动时在FFFF0H单元中读取指令执行 2.3 疑问1. 为什么偏移地址只能在64Kb内？一个16位的CPU，只能有1111 1111 1111 1111，代表了4个16进制数，所以能表示2**16 bit的数据，恰好，就是64Kb。 2.暂留第三章 寄存器（内存访问）3.1 内存中字的存储 字单元的概念：即存放一个字型数据的内存单元，由两个地址连续的内存单元（一个8位）组成。高放高位，低放低位。 这里解释一下： 若有单元[0]-&gt;2e [1]-&gt;33，那么我们读[0]的字型数据为：332eH（高放高位） 3.2 DS和[address] “[…]”表示一个内存单元，表示在段地址下的偏移量。如10000H = 1000:0 = [0] 注意，ds是自动加上的，如果使用[]的话，而且他（段寄存器）是不能直接用mov命令改变的，必须通过其他的寄存器中转才能改变。 3.3 字的传送（mov指令）在传送字之后， DS和[address]也会跟着变，如1000:0，若传入一个fffeH，则address会从0-&gt;2，此时，[0]存有feH，[1]存有ffH,[2]为空。 3.4 mov、add、sub指令主要是说说置零问题，与机械码长度问题，稍微提一下，以后会细讲。举例子： 12sub bx, bxmov bx, 0 两个都是可以将bx寄存器置零的指令，但是sub的机械码长度为2，而mov为3，用sub更好。另外说说jmp指令，他是转移指令，具有一个操作对象的指令，而上面的具有两个。 3.5 栈他是一个FILO结构（先入后出），而且是从大变小（地址）。 1.push和pop 执行push ax命令，会把ax中的数据传入ss:sp指向的地址空间。此时sp-=2执行pop ax命令，会把ss:sp指向的地址空间中的数据传给ax。此时sp+=2 执行之后的指针变化： push先令sp-=2，然后将ax中的数据放进去。称为出栈。 pop是先取出数据放到ax中，再sp+=2。称为入栈。 2.数据传输如8086cpu的入栈和出栈都是以字为单位进行的。 3.栈指针上面已经用到了：段寄存器:寄存器存储(ss:sp)sp是指偏移地址，ss:sp始终指向栈顶。 3.6 栈顶越界问题栈溢出问题都是大问题，如果栈顶越界了，那么执行push和pop会受影响吗？当然不会！直接刚，写！写！写！出！出！出！管你呢。所以就会有可能读了其他程序的数据，或者修改了（覆盖）其他程序的数据（直接崩溃的说）执行情况（取自《汇编语言第二版》王爽著） 问题1.程序与数据有区别吗？可以说有，也可以说没有。由于指令都是0和1组成的，只是用不同功能的段地址读出来的不一样，如,CS和DS都指向10000H，那么，CS会将里头的数据转化为机械码，执行指令，而DS就直接读数据，作为单纯的数据使用。 2.空栈如（10000H~1000FH）此时ss=1000H，那么sp是多少？因为是自下而上（自大到小），所以sp=0010H。换一种方式看，若存储了一个数据，则一个存到000EH，一个存到000FH，此时的栈指针在栈顶，当然指向000EH了，此时是已经让sp-=2了，那么回溯一下，不就有sp=0010H了。 好了，问题来了，如果将（10000H~1FFFFH）作为空间呢？答案：sp=0000H，因为，不能变成10000H(笑) 3.栈会溢出，那么，为什么不设置栈大小emmm，可惜8086cpu就是没有，所以变成自己注意。 4.只有mov可以完成传输数据吗？push也可以哦，只要把sp定位为ds:[address]那就好了哦。直接写进去。","categories":[{"name":"理论","slug":"理论","permalink":"https://jeffup.github.io/categories/%E7%90%86%E8%AE%BA/"},{"name":"代码编程","slug":"理论/代码编程","permalink":"https://jeffup.github.io/categories/%E7%90%86%E8%AE%BA/%E4%BB%A3%E7%A0%81%E7%BC%96%E7%A8%8B/"}],"tags":[{"name":"汇编","slug":"汇编","permalink":"https://jeffup.github.io/tags/%E6%B1%87%E7%BC%96/"},{"name":"二进制","slug":"二进制","permalink":"https://jeffup.github.io/tags/%E4%BA%8C%E8%BF%9B%E5%88%B6/"}]},{"title":"网络流量分析（nogotofail））","slug":"网络流量分析(nogotofail)","date":"2019-11-10T06:50:53.000Z","updated":"2019-11-11T05:49:07.237Z","comments":true,"path":"2019/11/10/网络流量分析(nogotofail)/","link":"","permalink":"https://jeffup.github.io/2019/11/10/%E7%BD%91%E7%BB%9C%E6%B5%81%E9%87%8F%E5%88%86%E6%9E%90(nogotofail)/","excerpt":"","text":"应用范围它包括对常见的SSL证书验证问题(HTTPS和TLS/SSL)的测试库bug、SSL和STARTTLS剥离问题、明文问题等等。","categories":[{"name":"理论","slug":"理论","permalink":"https://jeffup.github.io/categories/%E7%90%86%E8%AE%BA/"}],"tags":[{"name":"网络流量","slug":"网络流量","permalink":"https://jeffup.github.io/tags/%E7%BD%91%E7%BB%9C%E6%B5%81%E9%87%8F/"}]},{"title":"算法实验","slug":"算法实验","date":"2019-11-10T03:05:40.000Z","updated":"2019-11-11T06:15:04.604Z","comments":true,"path":"2019/11/10/算法实验/","link":"","permalink":"https://jeffup.github.io/2019/11/10/%E7%AE%97%E6%B3%95%E5%AE%9E%E9%AA%8C/","excerpt":"简介：包括线性时间算法，最长递增子序列，以斐波那契堆实现迪杰斯特拉算法","text":"简介：包括线性时间算法，最长递增子序列，以斐波那契堆实现迪杰斯特拉算法 1. 线性时间选择（序数问题） 问题描述：已知n个数，找出排序后第k小的数。要求平均时间复杂度为O(n)。 解决思路：使用快速排序的思想解决查找问题，用随机数（舍伍德算法）解决基准问题，用分治策略搭建整体的算法结构。 步骤分析：(1) 使用舍伍德算法选择基准r（第r个数）(2) 用快速排序算法进行下面的操作：将大于基准的数值放于基准后，将小于基准的数值放于基准前，刷新数组的排序。(3) 若想要查找的第k个数值的k比基准r大，则取数组的右边再重复进行以上操作，若小于，则选择左边的，若等于，则输出。 示例： 示例分析：输入10个数，分别为5 2 7 8 9 0 1 3 4 6，第5小的元素为4，验证成功。 2. 最长递增子序列问题 问题描述：寻找最长递增的序列。 解决思路：利用矩阵记录之前的结果，用动态规划法完成寻找 算法步骤：(1) 设置变量有：存储当前最长序列的值的数组tempmax，存储最长序列长度maxlen存储最长序列的最大值下标maxindex(2) 从下标为1的值开始遍历(3) 若i下标下的值比前一个值大，则更新tempmax[i]=tempmax[i-1]+1，即增加长度1，若此时的tempmaxp[i]比maxlen大，则更新maxlen，且更新maxindex=1 示例：示例分析： 输入10个数分别为1 3 2 4 5 3 7 8 9 6，其最长递增子序列为3 7 8 9，长度为4，验证成功。 3. 斐波那契堆实现最短路径算法（迪杰斯特拉） 问题描述：用斐波那契堆取最小路径辅助迪杰斯特拉算法实现最小路径算法 解决思路：1. 使用贪心算法实现迪杰斯特拉最短路径算法，使用斐波那契堆建立最小堆，方便取最小‘结点’以完成接下来的操作 算法思想： 迪杰斯特拉伪代码： 123456789DIJKSTRA(G, w, s)INITIALIZE - SINGLE - SOURCE(G, s)S ← ØQ ← V[G] //第3行，INSERT操作，O（1）构造堆while Q ≠ Ø do u ← EXTRACT - MIN(Q) //第5行，从堆中取出最小点 S ← S ∪&#123; u &#125; for each vertex v ∈ Adj[u] do RELAX(u, v, w) //第8行，RELAX操作，对堆进行降级工作 其中在第5行的EXTRACT-MIN操作用斐波那契堆实现，斐波那契堆结构如下: 斐波那契堆是由一组最小堆有序树构成的。每个节点的度数为其子节点的数目。树的度数为其根节点的度数。 斐波那契堆中的树都是有根的但是无序。每个节点x包含指向父节点的指针p[x]和指向任意一个子结点的child[x]。x的所有子节点都用双向循环链表链接起来，叫做x的子链表。子链表中的每一个节点y都有指向它的左兄弟的left[y]和右兄弟的right[y]。如果节点y是x仅有的子节点，则left[y]=right[y]=y。 斐波那契堆中所有树的根节点也用一个双向循环链表链接起来。使用一个指针指向斐波那契堆中最小元素。 用稀疏矩阵表示图，定义为weight 具体实现示例分析： 其矩阵如： {0,4,NoEdge,2,NoEdge}, {4,0,4,1,NoEdge}, {NoEdge,4,0,1,3}, {2,1,1,0,7},{NoEdge,NoEdge,3,7,0}最终应该得到结果：a-&gt;a=0a-&gt;d-&gt;b=3a-&gt;d-&gt;c=3a-&gt;d=2a-&gt;d-&gt;c-&gt;e=6 测试成功！","categories":[{"name":"代码编程","slug":"代码编程","permalink":"https://jeffup.github.io/categories/%E4%BB%A3%E7%A0%81%E7%BC%96%E7%A8%8B/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://jeffup.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"C++","slug":"C","permalink":"https://jeffup.github.io/tags/C/"}]},{"title":"Hello World","slug":"hello-world","date":"2019-11-10T02:19:20.246Z","updated":"2019-11-11T06:13:02.844Z","comments":true,"path":"2019/11/10/hello-world/","link":"","permalink":"https://jeffup.github.io/2019/11/10/hello-world/","excerpt":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. HEXO常用：新建文章1$ hexo new \"My New Post\" More info: Writing 启动本地镜像服务1$ hexo server More info: Server 生成静态文件1$ hexo generate More info: Generating 上传文件（同步）12$ hexo deploy$ hexo d 也可 More info: Deployment 常要注意的玩意：hexo图片问题hexo阅读更多1npm install hexo-generator-index2 --save 12345678# index2 generator是否包含官方的hexo-generator-index，默认true（包含）index2_include_index: trueindex2_generator: per_page: 8 order_by: -date # 按发布时间排序 exclude: - tag hide # 不包含标签为hide的文章 - category hide # 不包含分类为hide的文章 然后 博客设置问题：头像&amp;图标：在主题目录下配置文件中.头像： 12345author: name: DuK work: Study,0-1 location: China avatar_url: /images/avatar.png 而其图标： 1favicon: /images/favicon.ico 网站：图标制作 侧边栏目（标签，归档）得先进行 1hexo new page tags 然后才会有，这里tags还要加上： 12345---title: tagsdate: 2019-11-10 11:36:27layout: tags---","categories":[],"tags":[{"name":"配置","slug":"配置","permalink":"https://jeffup.github.io/tags/%E9%85%8D%E7%BD%AE/"},{"name":"博客","slug":"博客","permalink":"https://jeffup.github.io/tags/%E5%8D%9A%E5%AE%A2/"},{"name":"指令","slug":"指令","permalink":"https://jeffup.github.io/tags/%E6%8C%87%E4%BB%A4/"}]}]}