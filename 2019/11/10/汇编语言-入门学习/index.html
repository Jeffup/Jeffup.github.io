<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8" />

    

    

    <title>汇编语言(入门学习) | DuK_Blogs</title>
    <meta name="author" content="DuK" />
    <meta name="keywords" content="" />
    <meta name="description" content="简介：本篇旨在对汇编的基础知识进行汇总，汇总的都是要点（简明扼要），目前还在更新中。第一章 基础知识1.1 存储单元一个存储单元存储的信息量以bit为单位（最小）。而转换关系中8 bit=1 bytes(B)。而一个字=两个字节在微型计算机存储器的存储单元中，一个单元可以存1 B（即8个进制位）。而一个存储器有128个单元，则可以存储128 B。1.2 CPU对存储器的读写要读写，则应该与三类信息进行交互：地址信息控制信息数据信息而逻辑上又分为3类总线，分别传输信息：..." />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width,initial-scale=1,user-scalable=no" />

    
    
    <link rel="icon" href="/images/favicon.ico">
    

    <style type="text/css">
    @font-face {
        font-family: 'icomoon';
        src: url("/fonts/icomoon.eot?q628ml");
        src: url("/fonts/icomoon.eot?q628ml#iefix") format('embedded-opentype'),
             url("/fonts/icomoon.ttf?q628ml") format('truetype'),
             url("/fonts/icomoon.woff?q628ml") format('woff'),
             url("/fonts/icomoon.svg?q628ml#icomoon") format('svg');
        font-weight: normal;
        font-style: normal;
    }
    </style>
    <link rel="stylesheet" href="/css/style.css">

    <!--[if lt IE 9]>
    <style type="text/css">
    .nav-inner {top:0;}
    .author-meta {position:static;top:0;}
    .search-form {height:36px;}
    </style>
    <script type="text/javascript" src="https://unpkg.com/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
    <![endif]-->
</head>
<body>

    <main class="app">
        <header id="header" class="header clearfix">
    <div id="nav" class="nav">
    <div class="nav-mobile">
        <button id="open-panel" class="open-panel nav-mobile-item"><i class="icon-documents"></i></button>
        <h1 class="nav-mobile-title nav-mobile-item">DuK_Blogs</h1>
        <button id="open-menus" class="open-panel nav-mobile-item"><i class="icon-library"></i></button>
    </div>

    <nav id="nav-inner" class="nav-inner">
        
            <a class="nav-item" href="/">
                <span class="nav-text">首页</span>
            </a>
        
            <a class="nav-item" href="/tags">
                <span class="nav-text">标签</span>
            </a>
        
            <a class="nav-item" href="/archives">
                <span class="nav-text">归档</span>
            </a>
        
            <a class="nav-item" href="/about">
                <span class="nav-text">关于</span>
            </a>
        
    </nav>
</div>

    <aside id="aside" class="aside">
    <div id="aside-mask" class="aside-mask"></div>
    <div id="aside-inner" class="aside-inner">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit"><i class="icon-search-stroke"></i></button><input type="hidden" name="sitesearch" value="https://jeffup.github.io"></form>

        
        
        
        

        
        <ol class="toc"><li class="toc-item toc-level-4"><a class="toc-link" href="#简介：本篇旨在对汇编的基础知识进行汇总，汇总的都是要点（简明扼要），目前还在更新中。"><span class="toc-number">1.</span> <span class="toc-text">简介：本篇旨在对汇编的基础知识进行汇总，汇总的都是要点（简明扼要），目前还在更新中。</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#第一章-基础知识"><span class="toc-number"></span> <span class="toc-text">第一章 基础知识</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-1-存储单元"><span class="toc-number"></span> <span class="toc-text">1.1 存储单元</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-2-CPU对存储器的读写"><span class="toc-number"></span> <span class="toc-text">1.2 CPU对存储器的读写</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-1-影响性能的因素："><span class="toc-number"></span> <span class="toc-text">1.2.1 影响性能的因素：</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#宽度（线的条数）：它决定了部件的能力（速度，控制能力等）。8086为16条，8088为8条"><span class="toc-number">1.</span> <span class="toc-text">宽度（线的条数）：它决定了部件的能力（速度，控制能力等）。8086为16条，8088为8条</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#第二章-寄存器"><span class="toc-number"></span> <span class="toc-text">第二章 寄存器</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#2-1-通用寄存器"><span class="toc-number"></span> <span class="toc-text">2.1 通用寄存器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-2-CPU给出物理地址的方法"><span class="toc-number"></span> <span class="toc-text">2.2 CPU给出物理地址的方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-2-段寄存器"><span class="toc-number"></span> <span class="toc-text">2.2 段寄存器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-1-CS和IP"><span class="toc-number"></span> <span class="toc-text">2.2.1 CS和IP</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-3-疑问"><span class="toc-number"></span> <span class="toc-text">2.3 疑问</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-为什么偏移地址只能在64Kb内？"><span class="toc-number"></span> <span class="toc-text">1. 为什么偏移地址只能在64Kb内？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-暂留"><span class="toc-number"></span> <span class="toc-text">2.暂留</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#第三章-寄存器（内存访问）"><span class="toc-number"></span> <span class="toc-text">第三章 寄存器（内存访问）</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#3-1-内存中字的存储"><span class="toc-number"></span> <span class="toc-text">3.1 内存中字的存储</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-2-DS和-address"><span class="toc-number"></span> <span class="toc-text">3.2 DS和[address]</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-3-字的传送（mov指令）"><span class="toc-number"></span> <span class="toc-text">3.3 字的传送（mov指令）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-4-mov、add、sub指令"><span class="toc-number"></span> <span class="toc-text">3.4 mov、add、sub指令</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-5-栈"><span class="toc-number"></span> <span class="toc-text">3.5 栈</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-5-1-push和pop"><span class="toc-number"></span> <span class="toc-text">3.5.1 push和pop</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-5-2-数据传输"><span class="toc-number"></span> <span class="toc-text">3.5.2 数据传输</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-5-3-栈指针"><span class="toc-number"></span> <span class="toc-text">3.5.3 栈指针</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-6-栈顶越界问题"><span class="toc-number"></span> <span class="toc-text">3.6 栈顶越界问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-7-问题"><span class="toc-number"></span> <span class="toc-text">3.7 问题</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-程序与数据有区别吗？"><span class="toc-number"></span> <span class="toc-text">1.程序与数据有区别吗？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-空栈如（10000H-1000FH）此时ss-1000H，那么sp是多少？"><span class="toc-number"></span> <span class="toc-text">2.空栈如（10000H~1000FH）此时ss=1000H，那么sp是多少？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-栈会溢出，那么，为什么不设置栈大小"><span class="toc-number"></span> <span class="toc-text">3.栈会溢出，那么，为什么不设置栈大小</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-只有mov可以完成传输数据吗？"><span class="toc-number"></span> <span class="toc-text">4.只有mov可以完成传输数据吗？</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#第四章-第一个程序"><span class="toc-number"></span> <span class="toc-text">第四章 第一个程序</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#4-1-一个源程序从写出到执行的过程"><span class="toc-number"></span> <span class="toc-text">4.1 一个源程序从写出到执行的过程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-2-源程序"><span class="toc-number"></span> <span class="toc-text">4.2 源程序</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-1-伪指令"><span class="toc-number"></span> <span class="toc-text">4.2.1 伪指令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-2-程序返回"><span class="toc-number"></span> <span class="toc-text">4.2.2 程序返回</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-3-程序生成流程"><span class="toc-number"></span> <span class="toc-text">4.3 程序生成流程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-4-怎么装载程序？"><span class="toc-number"></span> <span class="toc-text">4.4 怎么装载程序？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-4-展示EXE的加载过程"><span class="toc-number"></span> <span class="toc-text">4.4 展示EXE的加载过程</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#第五章-BX-和loop指令"><span class="toc-number"></span> <span class="toc-text">第五章 [BX]和loop指令</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#5-1-BX"><span class="toc-number"></span> <span class="toc-text">5.1 [BX]</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-2-loop"><span class="toc-number"></span> <span class="toc-text">5.2 loop</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-3-loop和-bx-的联合运用"><span class="toc-number"></span> <span class="toc-text">5.3 loop和[bx]的联合运用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-4-段前缀与其使用"><span class="toc-number"></span> <span class="toc-text">5.4 段前缀与其使用</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#第六章-包含多个段的程序"><span class="toc-number"></span> <span class="toc-text">第六章 包含多个段的程序</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#6-1-在代码段中使用数据"><span class="toc-number"></span> <span class="toc-text">6.1 在代码段中使用数据</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#第七章-更灵活的定位内存地址的方法"><span class="toc-number"></span> <span class="toc-text">第七章 更灵活的定位内存地址的方法</span></a>
        
    </div>
</aside>

</header>

        <div id="content" class="content">
            <div id="wrapper" class="wrapper" style="max-width: 800px">
                <article class="article" itemscope itemprop="blogPost">
    
    <header class="article-header">
        
        <h1 itemprop="name">
            汇编语言(入门学习)
        </h1>
        
        <div class="article-meta clearfix">
            <a class="article-date" href="https://jeffup.github.io/2019/11/10/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80-%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0/index.html">
    
    <i class="icon-calendar"></i>
    
    <time datetime="2019-11-10T06:57:39.000Z" itemprop="datePublished">2019-11-10</time>
</a>

            
<div class="article-tag-list">
    <i class="icon-tag"></i>
    <a class="article-tag-link" href="/tags/%E4%BA%8C%E8%BF%9B%E5%88%B6/" rel="tag">二进制</a>, <a class="article-tag-link" href="/tags/%E6%B1%87%E7%BC%96/" rel="tag">汇编</a>
</div>


        </div>
    </header>
    
    <section class="article-body markdown-body">
        
        <h4 id="简介：本篇旨在对汇编的基础知识进行汇总，汇总的都是要点（简明扼要），目前还在更新中。"><a href="#简介：本篇旨在对汇编的基础知识进行汇总，汇总的都是要点（简明扼要），目前还在更新中。" class="headerlink" title="简介：本篇旨在对汇编的基础知识进行汇总，汇总的都是要点（简明扼要），目前还在更新中。"></a>简介：本篇旨在对汇编的基础知识进行汇总，汇总的都是要点（简明扼要），目前还在更新中。</h4><a id="more"></a>
<h1 id="第一章-基础知识"><a href="#第一章-基础知识" class="headerlink" title="第一章 基础知识"></a>第一章 基础知识</h1><h2 id="1-1-存储单元"><a href="#1-1-存储单元" class="headerlink" title="1.1 存储单元"></a>1.1 存储单元</h2><p>一个存储单元存储的信息量以<strong>bit</strong>为单位（最小）。而转换关系中8 bit=1 bytes(B)。而一个字=两个字节<br>在微型计算机存储器的存储单元中，一个单元可以存<strong>1 B</strong>（即8个进制位）。而一个存储器有128个单元，则可以存储128 B。</p>
<h2 id="1-2-CPU对存储器的读写"><a href="#1-2-CPU对存储器的读写" class="headerlink" title="1.2 CPU对存储器的读写"></a>1.2 CPU对存储器的读写</h2><p>要读写，则应该与三类信息进行交互：</p>
<blockquote>
<ol>
<li>地址信息</li>
<li>控制信息</li>
<li>数据信息</li>
</ol>
</blockquote>
<p>而逻辑上又分为3类总线，分别传输信息：</p>
<blockquote>
<ol>
<li>地址总线（指出内存中的信息放在那里(自下而上读01)）</li>
<li>控制总线（若要传输的数据多于一次性传输的宽度，则分开来多传几次）</li>
<li>数据总线</li>
</ol>
</blockquote>
<h3 id="1-2-1-影响性能的因素："><a href="#1-2-1-影响性能的因素：" class="headerlink" title="1.2.1 影响性能的因素："></a>1.2.1 影响性能的因素：</h3><h4 id="宽度（线的条数）：它决定了部件的能力（速度，控制能力等）。8086为16条，8088为8条"><a href="#宽度（线的条数）：它决定了部件的能力（速度，控制能力等）。8086为16条，8088为8条" class="headerlink" title="宽度（线的条数）：它决定了部件的能力（速度，控制能力等）。8086为16条，8088为8条"></a>宽度（线的条数）：它决定了部件的能力（速度，控制能力等）。8086为16条，8088为8条</h4><blockquote>
<p>若CPU的寻址能力为8KB，则总线宽度：8*1024/1 = 2**13 (注意单位是B,13则为总线宽度)</p>
</blockquote>
<h1 id="第二章-寄存器"><a href="#第二章-寄存器" class="headerlink" title="第二章 寄存器"></a>第二章 寄存器</h1><h2 id="2-1-通用寄存器"><a href="#2-1-通用寄存器" class="headerlink" title="2.1 通用寄存器"></a>2.1 通用寄存器</h2><p>有<strong>AX BX CX DX</strong>四种，它们分为高位和低位以兼容以前的程序，如（AX = AH(高) + AL(低)）<br><em>要注意的是：若只用AL进行运算，若超出其范围，超出的数据不会到AH当中！</em></p>
<h2 id="2-2-CPU给出物理地址的方法"><a href="#2-2-CPU给出物理地址的方法" class="headerlink" title="2.2 CPU给出物理地址的方法"></a>2.2 CPU给出物理地址的方法</h2><blockquote>
<p>段地址(<strong>SA</strong>)：只是为了内存的管理，并不是真分段。16位地址分段，一段64KB<br>偏移地址(<strong>EA</strong>)：16位地址最多64KB<br>公式：物理地址=段地址*16+偏移地址</p>
</blockquote>
<h2 id="2-2-段寄存器"><a href="#2-2-段寄存器" class="headerlink" title="2.2 段寄存器"></a>2.2 段寄存器</h2><p>有<strong>CS DS SS ES</strong>四种。CS常存储段地址。它们提供了一下功能：</p>
<ol>
<li>CS：CPU要<strong>执行指令</strong>的地址。相当于命令指针</li>
<li>DS：读取内存的地址（返回数据）。相当于数据指针</li>
<li>SS：存储内存中的栈的顶。相当于栈顶指针</li>
</ol>
<h3 id="2-2-1-CS和IP"><a href="#2-2-1-CS和IP" class="headerlink" title="2.2.1 CS和IP"></a>2.2.1 CS和IP</h3><p>IP是存储基于CS的偏移量。修改的流程：</p>
<blockquote>
<p>一般流程：读取指令 -&gt; 修改 IP+=<em>命令长度</em> -&gt; 执行指令(可能会涉及修改CS:IP) -&gt; 读取指令…<br><em>8086PC启动时在FFFF0H单元中读取指令执行</em></p>
</blockquote>
<h2 id="2-3-疑问"><a href="#2-3-疑问" class="headerlink" title="2.3 疑问"></a>2.3 疑问</h2><h3 id="1-为什么偏移地址只能在64Kb内？"><a href="#1-为什么偏移地址只能在64Kb内？" class="headerlink" title="1. 为什么偏移地址只能在64Kb内？"></a>1. 为什么偏移地址只能在64Kb内？</h3><p>一个16位的CPU，只能有1111 1111 1111 1111，代表了4个16进制数，所以能表示2**16 bit的数据，恰好，就是64Kb。</p>
<h3 id="2-暂留"><a href="#2-暂留" class="headerlink" title="2.暂留"></a>2.暂留</h3><h1 id="第三章-寄存器（内存访问）"><a href="#第三章-寄存器（内存访问）" class="headerlink" title="第三章 寄存器（内存访问）"></a>第三章 寄存器（内存访问）</h1><h2 id="3-1-内存中字的存储"><a href="#3-1-内存中字的存储" class="headerlink" title="3.1 内存中字的存储"></a>3.1 内存中字的存储</h2><blockquote>
<p>字单元的概念：即存放一个字型数据的内存单元，由<strong>两个地址连续</strong>的内存单元（一个8位）组成。高放高位，低放低位。</p>
</blockquote>
<p>这里解释一下： 若有单元[0]-&gt;2e，[1]-&gt;33，那么我们读[0]的字型数据为：332eH（高放高位）</p>
<h2 id="3-2-DS和-address"><a href="#3-2-DS和-address" class="headerlink" title="3.2 DS和[address]"></a>3.2 DS和[address]</h2><blockquote>
<p>“[…]”表示一个内存单元，表示在段地址下的偏移量。如10000H = 1000:0 = [0]</p>
</blockquote>
<ul>
<li><p>在masm汇编编辑器中，如果单纯写mov ax,[0]，那么他会把[0]当做0来解释，即指令变成：mov ax,0<br>而若用bx作为中转，那是可以的！如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mov bx,0</span><br><span class="line">mov ax,[bx]</span><br></pre></td></tr></table></figure>
<p>这个是可以把[bx]当成段地址，返回ds:bx下的数据的！<br>而如果偏要用[idata]的话，那么就必须加上<strong>ds:</strong>前缀，如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mov ax,ds:[0]</span><br></pre></td></tr></table></figure>
</li>
<li><p>而对于Debug编译器的话，ds是自动加上的，用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mov ax,[0]</span><br></pre></td></tr></table></figure>
<p>即可，如果使用[]的话，而且他（段寄存器）是不能直接用mov命令改变的，必须通过其他的寄存器中转才能改变。</p>
</li>
</ul>
<h2 id="3-3-字的传送（mov指令）"><a href="#3-3-字的传送（mov指令）" class="headerlink" title="3.3 字的传送（mov指令）"></a>3.3 字的传送（mov指令）</h2><p>在传送字之后， DS和[address]也会跟着变，如1000:0，若传入一个fffeH，则address会从0-&gt;2，此时，[0]存有feH，[1]存有ffH,[2]为空。</p>
<h2 id="3-4-mov、add、sub指令"><a href="#3-4-mov、add、sub指令" class="headerlink" title="3.4 mov、add、sub指令"></a>3.4 mov、add、sub指令</h2><p>主要是说说置零问题，与机械码长度问题，稍微提一下，以后会细讲。<br>举例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sub bx, bx</span><br><span class="line">mov bx, 0</span><br></pre></td></tr></table></figure>
<p>两个都是可以将bx寄存器置零的指令，但是sub的机械码长度为2，而mov为3，用sub更好。<br>另外说说jmp指令，他是转移指令，具有一个操作对象的指令，而上面的具有两个。</p>
<h2 id="3-5-栈"><a href="#3-5-栈" class="headerlink" title="3.5 栈"></a>3.5 栈</h2><p>他是一个FILO结构（先入后出），而且是从大变小（地址）。</p>
<h3 id="3-5-1-push和pop"><a href="#3-5-1-push和pop" class="headerlink" title="3.5.1 push和pop"></a>3.5.1 push和pop</h3><blockquote>
<p>执行push ax命令，会把ax中的数据传入ss:sp指向的地址空间。此时<strong>sp-=2</strong><br>执行pop ax命令，会把ss:sp指向的地址空间中的数据传给ax。此时<strong>sp+=2</strong></p>
</blockquote>
<p>执行之后的指针变化：</p>
<ul>
<li>push先令sp-=2，然后将ax中的数据放进去。称为出栈。</li>
<li>pop是先取出数据放到ax中，再sp+=2。称为入栈。</li>
</ul>
<p><img src="/2019/11/10/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80-%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0/3.5.png" alt></p>
<h3 id="3-5-2-数据传输"><a href="#3-5-2-数据传输" class="headerlink" title="3.5.2 数据传输"></a>3.5.2 数据传输</h3><p>如8086cpu的入栈和出栈都是以<strong>字</strong>为单位进行的。</p>
<h3 id="3-5-3-栈指针"><a href="#3-5-3-栈指针" class="headerlink" title="3.5.3 栈指针"></a>3.5.3 栈指针</h3><p>上面已经用到了：段寄存器:寄存器存储(ss:sp)<br>sp是指偏移地址，ss:sp始终指向栈顶。</p>
<h2 id="3-6-栈顶越界问题"><a href="#3-6-栈顶越界问题" class="headerlink" title="3.6 栈顶越界问题"></a>3.6 栈顶越界问题</h2><p>栈溢出问题都是大问题，如果栈顶越界了，那么执行push和pop会受影响吗？当然不会！直接刚，写！写！写！出！出！出！管你呢。<br>所以就会有可能读了其他程序的数据，或者<strong>修改了（覆盖）</strong>其他程序的数据（直接崩溃的说）<br>执行情况（取自《汇编语言第二版》王爽著）<br><img src="/2019/11/10/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80-%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0/3.6.jpg" alt></p>
<h2 id="3-7-问题"><a href="#3-7-问题" class="headerlink" title="3.7 问题"></a>3.7 问题</h2><h3 id="1-程序与数据有区别吗？"><a href="#1-程序与数据有区别吗？" class="headerlink" title="1.程序与数据有区别吗？"></a>1.程序与数据有区别吗？</h3><p>可以说有，也可以说没有。由于指令都是0和1组成的，只是用不同功能的段地址读出来的不一样，如,CS和DS都指向10000H，那么，CS会将里头的数据转化为机械码，执行指令，而DS就直接读数据，作为单纯的数据使用。</p>
<h3 id="2-空栈如（10000H-1000FH）此时ss-1000H，那么sp是多少？"><a href="#2-空栈如（10000H-1000FH）此时ss-1000H，那么sp是多少？" class="headerlink" title="2.空栈如（10000H~1000FH）此时ss=1000H，那么sp是多少？"></a>2.空栈如（10000H~1000FH）此时ss=1000H，那么sp是多少？</h3><p>因为是自下而上（自大到小），所以sp=0010H。<br>换一种方式看，若存储了一个数据，则一个存到000EH，一个存到000FH，此时的栈指针在栈顶，当然指向000EH了，此时是已经让sp-=2了，那么回溯一下，不就有sp=0010H了。</p>
<ul>
<li>好了，问题来了，如果将（10000H~1FFFFH）作为空间呢？<br>答案：sp=0000H，因为，不能变成10000H(笑)</li>
</ul>
<h3 id="3-栈会溢出，那么，为什么不设置栈大小"><a href="#3-栈会溢出，那么，为什么不设置栈大小" class="headerlink" title="3.栈会溢出，那么，为什么不设置栈大小"></a>3.栈会溢出，那么，为什么不设置栈大小</h3><p>emmm，可惜8086cpu就是没有，所以变成自己注意。</p>
<h3 id="4-只有mov可以完成传输数据吗？"><a href="#4-只有mov可以完成传输数据吗？" class="headerlink" title="4.只有mov可以完成传输数据吗？"></a>4.只有mov可以完成传输数据吗？</h3><p>push也可以哦，只要把sp定位为ds:[address]那就好了哦。直接写进去。</p>
<h1 id="第四章-第一个程序"><a href="#第四章-第一个程序" class="headerlink" title="第四章 第一个程序"></a>第四章 第一个程序</h1><h2 id="4-1-一个源程序从写出到执行的过程"><a href="#4-1-一个源程序从写出到执行的过程" class="headerlink" title="4.1 一个源程序从写出到执行的过程"></a>4.1 一个源程序从写出到执行的过程</h2><p>如图：<br><img src="/2019/11/10/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80-%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0/4.1.png" alt><br>执行过程包括：写程序-&gt;编译连接成可执行文件-&gt;执行。</p>
<blockquote>
<p>可执行文件文件中包括以下两部分：</p>
</blockquote>
<ol>
<li>程序和数据</li>
<li>相关的描述：程序多大，占用多少运行空间</li>
</ol>
<h2 id="4-2-源程序"><a href="#4-2-源程序" class="headerlink" title="4.2 源程序"></a>4.2 源程序</h2><h3 id="4-2-1-伪指令"><a href="#4-2-1-伪指令" class="headerlink" title="4.2.1 伪指令"></a>4.2.1 伪指令</h3><p>也就是只能被编译器识别的指令，如<strong>assume</strong>、<strong>segment</strong>、<strong>end</strong>等，<strong><em>这是没有机械码的</em></strong>。<br>一般的伪指令使用如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code  #声明（假设）cs:段名（标号）</span><br><span class="line">code segment	#段名 segment</span><br><span class="line">_指令_</span><br><span class="line">code ends		#对应segment，表示一个段结束</span><br><span class="line">end				#对应assume，表示程序结束</span><br></pre></td></tr></table></figure>

<h3 id="4-2-2-程序返回"><a href="#4-2-2-程序返回" class="headerlink" title="4.2.2 程序返回"></a>4.2.2 程序返回</h3><p>现在考虑，如何让上一个程序把CPU控制权交给写一个程序，这时候就要使用<strong>程序返回</strong><br>其代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mov ax, 4c00H</span><br><span class="line">int 21H</span><br></pre></td></tr></table></figure>
<h2 id="4-3-程序生成流程"><a href="#4-3-程序生成流程" class="headerlink" title="4.3 程序生成流程"></a>4.3 程序生成流程</h2><p><strong>编程 -&gt; <em>1.asm</em> -&gt; 编译 -&gt; <em>1.obj</em> -&gt; 连接 -&gt; <em>1.exe</em> -&gt; 加载 -&gt; <em>内存中的程序</em> -&gt; 运行</strong><br>注：加载就是将程序加载到内存，执行就是在内存中执行程序的指令</p>
<h2 id="4-4-怎么装载程序？"><a href="#4-4-怎么装载程序？" class="headerlink" title="4.4 怎么装载程序？"></a>4.4 怎么装载程序？</h2><p>操作系统是一个模块组成庞大的系统。任何通用的系统都要提供一个称为shell的程序，用户使用这个程序来操作计算机系统进行工作。</p>
<p>如DOS中有一个程序command.com，这个程序称为：命令解释器，也就是DOS中的SHELL<br>（其实跟我们的cmd.exe差不多）</p>
<p>先运行shell，然后在加载1.exe可执行程序的时候，cmd会自动把cpu的控制权交给1.exe，执行完成再返回cmd。</p>
<h2 id="4-4-展示EXE的加载过程"><a href="#4-4-展示EXE的加载过程" class="headerlink" title="4.4 展示EXE的加载过程"></a>4.4 展示EXE的加载过程</h2><p><img src="/2019/11/10/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80-%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0/4.4.png" alt></p>
<h1 id="第五章-BX-和loop指令"><a href="#第五章-BX-和loop指令" class="headerlink" title="第五章 [BX]和loop指令"></a>第五章 [BX]和loop指令</h1><h2 id="5-1-BX"><a href="#5-1-BX" class="headerlink" title="5.1 [BX]"></a>5.1 [BX]</h2><p>这个之前就讲过：其实就是把BX中的值作为ds的偏移地址EA，然后可以用这个来访问特定地址下的数据。<br>如ds:1000H，bx=0001H，那么[BX]就是指ds*16+bx下的值。</p>
<h2 id="5-2-loop"><a href="#5-2-loop" class="headerlink" title="5.2 loop"></a>5.2 loop</h2><p>直接上程序：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">assume cs:eloop</span><br><span class="line">eloop segment</span><br><span class="line">	mov ax,128</span><br><span class="line">	mov cx,36</span><br><span class="line">  s:add ax,ax</span><br><span class="line">	loop s</span><br><span class="line">eloop ends</span><br><span class="line">end</span><br></pre></td></tr></table></figure>
<p>解释：</p>
<ol>
<li>loop是按照cx当中的值进行对有标号的s下的命令进行循环的。当cx不等于0，则执行循环，这个程序实际上是实现128*36的程序。</li>
<li>s实际上是IP值，指向s标记的地址，所以loop s实际上是给IP赋值：IP=s，然后就可以通过cs:ip来执行指令了</li>
</ol>
<blockquote>
<p>注意：汇编程序中，数据不能以字母开头，所以要在前面加个0。比如：9138h可以写成9138h，而A000h就必须写成0A000h</p>
</blockquote>
<h2 id="5-3-loop和-bx-的联合运用"><a href="#5-3-loop和-bx-的联合运用" class="headerlink" title="5.3 loop和[bx]的联合运用"></a>5.3 loop和[bx]的联合运用</h2><p>例如来一个如同C++语言中的：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> dx = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> ds[<span class="number">12</span>] = &#123;<span class="number">1</span>, <span class="number">2</span>, ...&#125;;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i &lt; <span class="number">12</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">	dx += ds[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>那么汇编语言就有：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code</span><br><span class="line">code segment:</span><br><span class="line">	mov ax, 0ffffh	;因为ds寄存器不能直接赋值，所以用ax作为中间变量</span><br><span class="line">	mov ds,ax		</span><br><span class="line">	mov bx,0		;初始化ds:bx指向ffff:0</span><br><span class="line"></span><br><span class="line">	mov dx,0		;初始化**累加寄存器**dx，让值为0</span><br><span class="line"></span><br><span class="line">	mov cx,12		;初始化循环计数寄存器cx，令值为12，指循环12次</span><br><span class="line"></span><br><span class="line"> s: mov al,[bx]		;以下两步执行ax的赋值操作</span><br><span class="line">	mov ah,0		;</span><br><span class="line">	add dx,ax		;执行加法</span><br><span class="line">	inc bx			;ds:bx指向下一个单元，因为bx的值增加了1，相当于C++代码中的*i++*</span><br><span class="line">	loop s			;loop完成一次，则cx=cx-1，然后判断cx是否等于0，如果等于则退出循环</span><br><span class="line"></span><br><span class="line">	mov ax,4c00h</span><br><span class="line">	int 21h</span><br><span class="line"></span><br><span class="line">code ends</span><br><span class="line">end</span><br></pre></td></tr></table></figure>
<p>好了，现在来说说这段代码里面有什么需要注意的点：</p>
<ol>
<li>cx寄存器一般用作loop循环的判断条件，即<strong>循环的粗次数</strong>。</li>
<li>ax寄存器的初始化有两步，是，因为一个字符型数据是8位这样的话转化为16位就得让高8位的值赋为0。</li>
<li>dx寄存器是常用的累加寄存器。</li>
<li>inc指令是让后面的值加一的指令，相当于C++语言中的‘++’自增。</li>
<li>int指令：<blockquote>
<p>由int 指令引发的中断是一种重要的内中断。<br>格式： int n   //相当于引发一个n号中断的过程,最终功能和call指令相似，都是调用一段程序。</p>
<ul>
<li>取中断类型码n</li>
<li>标志寄存器入栈，并IF=0,TF=0      //TF=0使得避免中断程序执行过程中引发单步中断</li>
<li>CS,IP寄存器入栈</li>
<li>IP=(n<em>4) , CS=(n</em>4 + 2)<br><a href="https://blog.csdn.net/u010034085/article/details/97819727" target="_blank" rel="noopener">原文链接</a></li>
</ul>
</blockquote>
</li>
</ol>
<h2 id="5-4-段前缀与其使用"><a href="#5-4-段前缀与其使用" class="headerlink" title="5.4 段前缀与其使用"></a>5.4 段前缀与其使用</h2><blockquote>
<ul>
<li>能够显示地指令内存单元的段地址的，如：”ds:”、”cs:”、”ss:”、”es:”。这就是段前缀。</li>
<li>默认的[x]是指：(dx*16)+x，而如果要用其他的段寄存器，则需要加上它的段前缀。 </li>
</ul>
</blockquote>
<h1 id="第六章-包含多个段的程序"><a href="#第六章-包含多个段的程序" class="headerlink" title="第六章 包含多个段的程序"></a>第六章 包含多个段的程序</h1><blockquote>
<p>由于软件是由数据和程序组成的，数据当然也是程序里面必不可少的部分，所以会将代码分为多段进行，如数据段、代码段等。</p>
</blockquote>
<h2 id="6-1-在代码段中使用数据"><a href="#6-1-在代码段中使用数据" class="headerlink" title="6.1 在代码段中使用数据"></a>6.1 在代码段中使用数据</h2><blockquote>
<p><strong>汇编程序若没有特殊的说明（或者注明在哪里开始），则默认从头开始！</strong><br>所以，一旦你的程序头部有数据，则将会把头部的数据翻译为<strong>机器码</strong>执行。(冤)</p>
</blockquote>
<p>那么解决方式是：在开始执行代码的地方加上 <strong>start:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code</span><br><span class="line">code segment</span><br><span class="line">  dw 0123h,0456h,0789h		;这里是数据部分 dw意思是定义字符型数据</span><br><span class="line">  start: mov bx,0		;注意，从这开始，标识为start!</span><br><span class="line">         mov ax,0</span><br><span class="line"></span><br><span class="line">         mov cx,8</span><br><span class="line">	  s: add ax,cs:[bx]	;用cs作为段地址，取数据！</span><br><span class="line">         add bx,2</span><br><span class="line">         loop s</span><br><span class="line">         </span><br><span class="line">         mov ax,4c00h</span><br><span class="line">         int 2h</span><br><span class="line">code ends</span><br><span class="line">end start					;注意end后面要加上end开始的名称！</span><br><span class="line">```	</span><br><span class="line"></span><br><span class="line">## 6.2 将数据、代码、栈放入不同的段</span><br><span class="line">上面说了，代码从哪里开始就在哪里加上**start**，结束就用**end start**（其他标识也行）</span><br><span class="line">好，记住，那是代码，别把接下来说的混淆了。</span><br><span class="line"></span><br><span class="line">不同的段可以放不同的东西，例如数据，代码等等。</span><br><span class="line">只要记住将段名end了再定义其他段。也只有定义了，才能使用这个段</span><br></pre></td></tr></table></figure>
<pre><code>assume cs:b,ds:a,ss:c
a  segment
    dw 0123h, 0456h, 0789h, 0abch, 0de fh, Ofedh, 0cbah, 0987h
a ends

c segment
    dw 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
c ends

b segment

d:  mov ax,c    ;使用段c中的数据
    mov ss,ax
    mov sp, 20h  ;希望用c段当作栈空间，设置ss:sp指向c:20

    mov ax,a    ;使用段a
    mov ds,ax  ;希望用ds:bx访问a段中的数据，ds指向a段
    mov bx,0  ;ds:bx指向a段中的第一一个单元
    mov Cx,8

s:  push [bx]
    add bx,2
    1oop s   ;以上将a段中的0~15单元中的8个字型数据依次入栈

    mov bx,0
    mov cx, B
s0:    pop [bx]    
    add bx,2    
    1oop s0  ;以上依次出栈8个字型数据到a段的0~15单元中

    mov ax, 4c00hint 21h

b ends

end d  ;d处是要执行的第一- 条指令，即程序的入口</code></pre><p>```</p>
<h1 id="第七章-更灵活的定位内存地址的方法"><a href="#第七章-更灵活的定位内存地址的方法" class="headerlink" title="第七章 更灵活的定位内存地址的方法"></a>第七章 更灵活的定位内存地址的方法</h1>
        
    </section>
</article>



<a id="pagenext" href="/2019/11/10/%E7%BD%91%E7%BB%9C%E6%B5%81%E9%87%8F%E5%88%86%E6%9E%90-nogotofail/" class="article-next" title="网络流量分析（nogotofail））"><i class="icon-arrow-right"></i></a>


<a id="pageprev" href="/2019/11/10/%E5%B7%A5%E5%85%B7OllyDbg%E7%9A%84%E4%BD%BF%E7%94%A8/" class="article-prev" title="工具OllyDbg的使用"><i class="icon-arrow-left"></i></a>




            </div>
        </div>
        <footer class="footer">
    Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>, Theme by <a href="https://github.com/sanonz/hexo-theme-concise" target="_blank">Concise</a>

    
    <script>
        var _hmt = _hmt || [];
        (function () {
            var hm = document.createElement("script");
            hm.src = "https://hm.baidu.com/hm.js?e4027971a230b210f4671f485b33846a";
            var s = document.getElementsByTagName("script")[0];
            s.parentNode.insertBefore(hm, s);
        })();
    </script>
    
</footer>

    </main>

    <script type="text/javascript" src="https://cdn.bootcss.com/jquery/1.9.0/jquery.min.js"></script>
    <script type="text/javascript">
    $(function() {
        var nodes = {
            nav: $('#nav'),
            aside: $('#aside'),
            asideInner: $('#aside-inner'),
            navInner: $('#nav-inner')
        };

        var doing = false;
        nodes.asideInner.on('webkitAnimationEnd mozAnimationEnd oAnimationEnd oanimationend animationend', function() {
            if (nodes.aside.hasClass('mobile-open')) {
                nodes.aside.removeClass('mobile-open');
            } else {
                nodes.aside.removeClass('mobile-close panel-show');
            }
            doing = false;
        });
        $('#open-panel, #aside-mask').on('click', function() {
            if (doing) {
                return;
            }

            if (nodes.aside.hasClass('panel-show')) {
                nodes.aside.addClass('mobile-close');
            } else {
                nodes.aside.addClass('mobile-open panel-show');
            }
        });
        $('#open-menus').on('click', function() {
            nodes.navInner.slideToggle();
        });

        if (window.innerWidth <= 960) {
            setTimeout(function() {
                nodes.navInner.slideUp();
            }, 3000);
        }
    });
    </script>
    
        <script src="/js/scrollspy.min.js"></script>
        <script type="text/javascript">
        $(document.body).scrollspy({target: '#aside-inner'});

        $(window).on('resize', function() {
            var hw = $('#header').width();
            var ww = $('#wrapper').width();
            var space = ($(this).width() - hw - ww) / 2 / 2;

            var pageprev = $('#pageprev');
            var pagenext = $('#pagenext');
            var avg = (pageprev.width() + pagenext.width()) / 2

            if(space > avg) {
                var len = space - avg / 2;
                var styles = {position: 'fixed', top: '50%', marginTop: - (pageprev.width() + pagenext.width()) / 4}
                pageprev.css($.extend({left: hw + len}, styles));
                pagenext.css($.extend({right: len}, styles));
            } else {
                pageprev.removeAttr('style');
                pagenext.removeAttr('style');
            }
        }).trigger('resize');
        </script>
    

</body>
</html>
