<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8" />

    

    

    <title>汇编语言(入门学习) | DuK_Blogs</title>
    <meta name="author" content="DuK" />
    <meta name="keywords" content="" />
    <meta name="description" content="简介：本篇旨在对汇编的基础知识进行汇总，汇总的都是要点（简明扼要），目前还在更新中。第一章 基础知识1.1 存储单元一个存储单元存储的信息量以bit为单位（最小）。而转换关系中8 bit=1 bytes(B)。而一个字=两个字节在微型计算机存储器的存储单元中，一个单元可以存1 B（即8个进制位）。而一个存储器有128个单元，则可以存储128 B。1.2 CPU对存储器的读写要读写，则应该与三类信息进行交互：地址信息控制信息数据信息而逻辑上又分为3类总线，分别传输信息：..." />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width,initial-scale=1,user-scalable=no" />

    
    
    <link rel="icon" href="/images/favicon.ico">
    

    <style type="text/css">
    @font-face {
        font-family: 'icomoon';
        src: url("/fonts/icomoon.eot?q628ml");
        src: url("/fonts/icomoon.eot?q628ml#iefix") format('embedded-opentype'),
             url("/fonts/icomoon.ttf?q628ml") format('truetype'),
             url("/fonts/icomoon.woff?q628ml") format('woff'),
             url("/fonts/icomoon.svg?q628ml#icomoon") format('svg');
        font-weight: normal;
        font-style: normal;
    }
    </style>
    <link rel="stylesheet" href="/css/style.css">

    <!--[if lt IE 9]>
    <style type="text/css">
    .nav-inner {top:0;}
    .author-meta {position:static;top:0;}
    .search-form {height:36px;}
    </style>
    <script type="text/javascript" src="https://unpkg.com/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
    <![endif]-->
</head>
<body>

    <main class="app">
        <header id="header" class="header clearfix">
    <div id="nav" class="nav">
    <div class="nav-mobile">
        <button id="open-panel" class="open-panel nav-mobile-item"><i class="icon-documents"></i></button>
        <h1 class="nav-mobile-title nav-mobile-item">DuK_Blogs</h1>
        <button id="open-menus" class="open-panel nav-mobile-item"><i class="icon-library"></i></button>
    </div>

    <nav id="nav-inner" class="nav-inner">
        
            <a class="nav-item" href="/">
                <span class="nav-text">首页</span>
            </a>
        
            <a class="nav-item" href="/tags">
                <span class="nav-text">标签</span>
            </a>
        
            <a class="nav-item" href="/archives">
                <span class="nav-text">归档</span>
            </a>
        
            <a class="nav-item" href="/about">
                <span class="nav-text">关于</span>
            </a>
        
    </nav>
</div>

    <aside id="aside" class="aside">
    <div id="aside-mask" class="aside-mask"></div>
    <div id="aside-inner" class="aside-inner">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit"><i class="icon-search-stroke"></i></button><input type="hidden" name="sitesearch" value="https://jeffup.github.io"></form>

        
        
        
        

        
        <ol class="toc"><li class="toc-item toc-level-4"><a class="toc-link" href="#简介：本篇旨在对汇编的基础知识进行汇总，汇总的都是要点（简明扼要），目前还在更新中。"><span class="toc-number">1.</span> <span class="toc-text">简介：本篇旨在对汇编的基础知识进行汇总，汇总的都是要点（简明扼要），目前还在更新中。</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#第一章-基础知识"><span class="toc-number"></span> <span class="toc-text">第一章 基础知识</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-1-存储单元"><span class="toc-number"></span> <span class="toc-text">1.1 存储单元</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-2-CPU对存储器的读写"><span class="toc-number"></span> <span class="toc-text">1.2 CPU对存储器的读写</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-1-影响性能的因素："><span class="toc-number"></span> <span class="toc-text">1.2.1 影响性能的因素：</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#宽度（线的条数）：它决定了部件的能力（速度，控制能力等）。8086为16条，8088为8条"><span class="toc-number">1.</span> <span class="toc-text">宽度（线的条数）：它决定了部件的能力（速度，控制能力等）。8086为16条，8088为8条</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#第二章-寄存器"><span class="toc-number"></span> <span class="toc-text">第二章 寄存器</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#2-1-通用寄存器"><span class="toc-number"></span> <span class="toc-text">2.1 通用寄存器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-2-CPU给出物理地址的方法"><span class="toc-number"></span> <span class="toc-text">2.2 CPU给出物理地址的方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-3-段寄存器"><span class="toc-number"></span> <span class="toc-text">2.3 段寄存器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-1-CS和IP"><span class="toc-number"></span> <span class="toc-text">2.3.1 CS和IP</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-4-疑问"><span class="toc-number"></span> <span class="toc-text">2.4 疑问</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-为什么偏移地址只能在64Kb内？"><span class="toc-number"></span> <span class="toc-text">1. 为什么偏移地址只能在64Kb内？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-暂留"><span class="toc-number"></span> <span class="toc-text">2.暂留</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#第三章-寄存器（内存访问）"><span class="toc-number"></span> <span class="toc-text">第三章 寄存器（内存访问）</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#3-1-内存中字的存储"><span class="toc-number"></span> <span class="toc-text">3.1 内存中字的存储</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-2-DS和-address"><span class="toc-number"></span> <span class="toc-text">3.2 DS和[address]</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-3-字的传送（mov指令）"><span class="toc-number"></span> <span class="toc-text">3.3 字的传送（mov指令）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-4-mov、add、sub指令"><span class="toc-number"></span> <span class="toc-text">3.4 mov、add、sub指令</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-5-栈"><span class="toc-number"></span> <span class="toc-text">3.5 栈</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-5-1-push和pop"><span class="toc-number"></span> <span class="toc-text">3.5.1 push和pop</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-5-2-数据传输"><span class="toc-number"></span> <span class="toc-text">3.5.2 数据传输</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-5-3-栈指针"><span class="toc-number"></span> <span class="toc-text">3.5.3 栈指针</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-6-栈顶越界问题"><span class="toc-number"></span> <span class="toc-text">3.6 栈顶越界问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-7-问题"><span class="toc-number"></span> <span class="toc-text">3.7 问题</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-程序与数据有区别吗？"><span class="toc-number"></span> <span class="toc-text">1.程序与数据有区别吗？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-空栈如（10000H-1000FH）此时ss-1000H，那么sp是多少？"><span class="toc-number"></span> <span class="toc-text">2.空栈如（10000H~1000FH）此时ss=1000H，那么sp是多少？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-栈会溢出，那么，为什么不设置栈大小"><span class="toc-number"></span> <span class="toc-text">3.栈会溢出，那么，为什么不设置栈大小</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-只有mov可以完成传输数据吗？"><span class="toc-number"></span> <span class="toc-text">4.只有mov可以完成传输数据吗？</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#第四章-第一个程序"><span class="toc-number"></span> <span class="toc-text">第四章 第一个程序</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#4-1-一个源程序从写出到执行的过程"><span class="toc-number"></span> <span class="toc-text">4.1 一个源程序从写出到执行的过程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-2-源程序"><span class="toc-number"></span> <span class="toc-text">4.2 源程序</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-1-伪指令"><span class="toc-number"></span> <span class="toc-text">4.2.1 伪指令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-2-程序返回"><span class="toc-number"></span> <span class="toc-text">4.2.2 程序返回</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-3-程序生成流程"><span class="toc-number"></span> <span class="toc-text">4.3 程序生成流程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-4-怎么装载程序？"><span class="toc-number"></span> <span class="toc-text">4.4 怎么装载程序？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-4-展示EXE的加载过程"><span class="toc-number"></span> <span class="toc-text">4.4 展示EXE的加载过程</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#第五章-BX-和loop指令"><span class="toc-number"></span> <span class="toc-text">第五章 [BX]和loop指令</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#5-1-BX"><span class="toc-number"></span> <span class="toc-text">5.1 [BX]</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-2-loop"><span class="toc-number"></span> <span class="toc-text">5.2 loop</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-3-loop和-bx-的联合运用"><span class="toc-number"></span> <span class="toc-text">5.3 loop和[bx]的联合运用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-4-段前缀与其使用"><span class="toc-number"></span> <span class="toc-text">5.4 段前缀与其使用</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#第六章-包含多个段的程序"><span class="toc-number"></span> <span class="toc-text">第六章 包含多个段的程序</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#6-1-在代码段中使用数据"><span class="toc-number"></span> <span class="toc-text">6.1 在代码段中使用数据</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-2-将数据、代码、栈放入不同的段"><span class="toc-number"></span> <span class="toc-text">6.2 将数据、代码、栈放入不同的段</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#第七章-更灵活的定位内存地址的方法"><span class="toc-number"></span> <span class="toc-text">第七章 更灵活的定位内存地址的方法</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#7-1-and和or指令"><span class="toc-number"></span> <span class="toc-text">7.1 and和or指令</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-2-以字符型给出数据"><span class="toc-number"></span> <span class="toc-text">7.2 以字符型给出数据</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-3-以-bx-idata-的方式寻址"><span class="toc-number"></span> <span class="toc-text">7.3 以[bx+idata]的方式寻址</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-4-si与di寄存器和多重循环"><span class="toc-number"></span> <span class="toc-text">7.4 si与di寄存器和多重循环</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#第八章-数据处理的两个基本问题"><span class="toc-number"></span> <span class="toc-text">第八章 数据处理的两个基本问题</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#8-1-bx、si、di和bp"><span class="toc-number"></span> <span class="toc-text">8.1 bx、si、di和bp</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-2-机器指令处理的数据在什么地方"><span class="toc-number"></span> <span class="toc-text">8.2 机器指令处理的数据在什么地方</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-3-指令处理的数据长度"><span class="toc-number"></span> <span class="toc-text">8.3 指令处理的数据长度</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-4-div指令"><span class="toc-number"></span> <span class="toc-text">8.4 div指令</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-5-实例"><span class="toc-number"></span> <span class="toc-text">8.5 实例</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-6-伪指令dd"><span class="toc-number"></span> <span class="toc-text">8.6 伪指令dd</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-7-dup"><span class="toc-number"></span> <span class="toc-text">8.7 dup</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#第九章-转移指令的原理"><span class="toc-number"></span> <span class="toc-text">第九章 转移指令的原理</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#9-1-操作符offset"><span class="toc-number"></span> <span class="toc-text">9.1 操作符offset</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-2-jmp指令和依据译为进行转移的jmp指令"><span class="toc-number"></span> <span class="toc-text">9.2 jmp指令和依据译为进行转移的jmp指令</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#9-2-1-jmp-short-标号-转移到标号出执行指令"><span class="toc-number"></span> <span class="toc-text">9.2.1 jmp short 标号(转移到标号出执行指令)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-2-2-立即数在机器码中的表示"><span class="toc-number"></span> <span class="toc-text">9.2.2 立即数在机器码中的表示</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-2-3-jmp转移的机制（是怎么实现转移的）"><span class="toc-number"></span> <span class="toc-text">9.2.3 jmp转移的机制（是怎么实现转移的）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-2-4-继续上面的，8位位移是怎么得出来的？"><span class="toc-number"></span> <span class="toc-text">9.2.4 继续上面的，8位位移是怎么得出来的？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-2-5-jmp-far-ptr-标号（段间转移-远转移）"><span class="toc-number"></span> <span class="toc-text">9.2.5 jmp far ptr 标号（段间转移/远转移）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-2-6-转移地址在寄存器的jmp指令-这就相当于总结了，上面废话有点多"><span class="toc-number"></span> <span class="toc-text">9.2.6 转移地址在寄存器的jmp指令(这就相当于总结了，上面废话有点多)</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-3-jcxz指令"><span class="toc-number"></span> <span class="toc-text">9.3 jcxz指令</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-4-loop指令"><span class="toc-number"></span> <span class="toc-text">9.4 loop指令</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-5-编译器对转移位移超界的检测"><span class="toc-number"></span> <span class="toc-text">9.5 编译器对转移位移超界的检测</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#第十章-CALL和RET指令"><span class="toc-number"></span> <span class="toc-text">第十章 CALL和RET指令</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#10-1-ret和retf"><span class="toc-number"></span> <span class="toc-text">10.1 ret和retf</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#10-2-call指令"><span class="toc-number"></span> <span class="toc-text">10.2 call指令</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#10-2-1-依据位移进行转移的call指令"><span class="toc-number"></span> <span class="toc-text">10.2.1 依据位移进行转移的call指令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-2-2-转移地址在指令中的call指令"><span class="toc-number"></span> <span class="toc-text">10.2.2 转移地址在指令中的call指令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-2-3-转移指令在寄存器中的call指令"><span class="toc-number"></span> <span class="toc-text">10.2.3 转移指令在寄存器中的call指令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-2-4-转移指令在内存中的call指令"><span class="toc-number"></span> <span class="toc-text">10.2.4 转移指令在内存中的call指令</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#10-3-call与ret的配合使用（敲黑板！）"><span class="toc-number"></span> <span class="toc-text">10.3 call与ret的配合使用（敲黑板！）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#10-4-mul乘法指令"><span class="toc-number"></span> <span class="toc-text">10.4 mul乘法指令</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#10-4-1-乘法规则"><span class="toc-number"></span> <span class="toc-text">10.4.1 乘法规则</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-4-2-指令格式："><span class="toc-number"></span> <span class="toc-text">10.4.2 指令格式：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-4-3-用mul寻址"><span class="toc-number"></span> <span class="toc-text">10.4.3 用mul寻址</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#10-5-模块化程序设计"><span class="toc-number"></span> <span class="toc-text">10.5  模块化程序设计</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#10-5-1-参数和结果的传递问题"><span class="toc-number"></span> <span class="toc-text">10.5.1 参数和结果的传递问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-5-2-寄存器冲突问题"><span class="toc-number"></span> <span class="toc-text">10.5.2 寄存器冲突问题</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#10-6-课后"><span class="toc-number"></span> <span class="toc-text">10.6 课后</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#下面的程序执行后，ax和bx中的数值为多少？"><span class="toc-number"></span> <span class="toc-text">下面的程序执行后，ax和bx中的数值为多少？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#实验10-1-编写子程序-之-显示字符串"><span class="toc-number"></span> <span class="toc-text">实验10-1 编写子程序 之 显示字符串</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#显示字符串"><span class="toc-number">1.</span> <span class="toc-text">显示字符串</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#问题"><span class="toc-number">1.1.</span> <span class="toc-text">问题</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#子程序描述"><span class="toc-number">1.2.</span> <span class="toc-text">子程序描述</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#提示"><span class="toc-number">2.</span> <span class="toc-text">提示</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#解决除法溢出问题"><span class="toc-number"></span> <span class="toc-text">解决除法溢出问题</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#问题："><span class="toc-number">1.</span> <span class="toc-text">问题：</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#第十一章-标志寄存器"><span class="toc-number"></span> <span class="toc-text">第十一章 标志寄存器</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#11-1-标志表"><span class="toc-number"></span> <span class="toc-text">11.1 标志表</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#11-2-与标志有关的指令"><span class="toc-number"></span> <span class="toc-text">11.2 与标志有关的指令</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#11-2-1-与CF相关的：adc-sdd指令"><span class="toc-number"></span> <span class="toc-text">11.2.1 与CF相关的：adc,sdd指令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11-2-2-与CF和ZF有关的：cmp指令（比较指令）"><span class="toc-number"></span> <span class="toc-text">11.2.2 与CF和ZF有关的：cmp指令（比较指令）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11-2-3-与CMP有关的比较结果条件转移指令"><span class="toc-number"></span> <span class="toc-text">11.2.3 与CMP有关的比较结果条件转移指令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11-2-4-与DF有关指令"><span class="toc-number"></span> <span class="toc-text">11.2.4 与DF有关指令</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#11-3-标志位有关的问题"><span class="toc-number"></span> <span class="toc-text">11.3 标志位有关的问题</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#11-3-1-单纯就符号标志位就可以判断结果的正负吗？（即判断相减的两个数的大小）"><span class="toc-number"></span> <span class="toc-text">11.3.1 单纯就符号标志位就可以判断结果的正负吗？（即判断相减的两个数的大小）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#11-4-pushf和popf"><span class="toc-number"></span> <span class="toc-text">11.4 pushf和popf</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#第十二章-内中断"><span class="toc-number"></span> <span class="toc-text">第十二章 内中断</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#12-1-中断一条龙（中断程序，中断向量表，中断过程）"><span class="toc-number"></span> <span class="toc-text">12.1 中断一条龙（中断程序，中断向量表，中断过程）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#12-2-中断处理程序，安装，中断向量等"><span class="toc-number"></span> <span class="toc-text">12.2 中断处理程序，安装，中断向量等</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#12-3-单步中断和TF-DF标志"><span class="toc-number"></span> <span class="toc-text">12.3 单步中断和TF,DF标志</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#12-4-int指令"><span class="toc-number"></span> <span class="toc-text">12.4 int指令</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#12-4-1-int、iret和栈"><span class="toc-number"></span> <span class="toc-text">12.4.1 int、iret和栈</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#第十三章-汇编语言重点知识总结"><span class="toc-number"></span> <span class="toc-text">第十三章 汇编语言重点知识总结</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#13-1寄存器与存储器"><span class="toc-number"></span> <span class="toc-text">13.1寄存器与存储器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#13-2-指令系统与寻址方式"><span class="toc-number"></span> <span class="toc-text">13.2 指令系统与寻址方式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#13-3-汇编程序和汇编语言"><span class="toc-number"></span> <span class="toc-text">13.3 汇编程序和汇编语言</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#13-4-程序设计基础"><span class="toc-number"></span> <span class="toc-text">13.4 程序设计基础</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#13-5-输入-输出与中断系统"><span class="toc-number"></span> <span class="toc-text">13.5 输入/输出与中断系统</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#13-6-8088-汇编速查手册"><span class="toc-number"></span> <span class="toc-text">13.6 8088 汇编速查手册</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#13-6-1-数据传输指令"><span class="toc-number"></span> <span class="toc-text">13.6.1 数据传输指令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#13-6-2-算术运算指令"><span class="toc-number"></span> <span class="toc-text">13.6.2 算术运算指令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#13-6-3-逻辑运算指令"><span class="toc-number"></span> <span class="toc-text">13.6.3 逻辑运算指令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#13-6-4-串指令"><span class="toc-number"></span> <span class="toc-text">13.6.4 串指令</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#13-6-5-程序转移指令"><span class="toc-number"></span> <span class="toc-text">13.6.5 程序转移指令</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#13-6-6-伪指令"><span class="toc-number"></span> <span class="toc-text">13.6.6 伪指令</span></a>
        
    </div>
</aside>

</header>

        <div id="content" class="content">
            <div id="wrapper" class="wrapper" style="max-width: 800px">
                <article class="article" itemscope itemprop="blogPost">
    
    <header class="article-header">
        
        <h1 itemprop="name">
            汇编语言(入门学习)
        </h1>
        
        <div class="article-meta clearfix">
            <a class="article-date" href="https://jeffup.github.io/2019/11/10/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80-%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0/index.html">
    
    <i class="icon-calendar"></i>
    
    <time datetime="2019-11-10T06:57:39.000Z" itemprop="datePublished">2019-11-10</time>
</a>

            
<div class="article-tag-list">
    <i class="icon-tag"></i>
    <a class="article-tag-link" href="/tags/%E4%BA%8C%E8%BF%9B%E5%88%B6/" rel="tag">二进制</a>, <a class="article-tag-link" href="/tags/%E6%B1%87%E7%BC%96/" rel="tag">汇编</a>
</div>


        </div>
    </header>
    
    <section class="article-body markdown-body">
        
        <h4 id="简介：本篇旨在对汇编的基础知识进行汇总，汇总的都是要点（简明扼要），目前还在更新中。"><a href="#简介：本篇旨在对汇编的基础知识进行汇总，汇总的都是要点（简明扼要），目前还在更新中。" class="headerlink" title="简介：本篇旨在对汇编的基础知识进行汇总，汇总的都是要点（简明扼要），目前还在更新中。"></a>简介：本篇旨在对汇编的基础知识进行汇总，汇总的都是要点（简明扼要），目前还在更新中。</h4><a id="more"></a>
<h1 id="第一章-基础知识"><a href="#第一章-基础知识" class="headerlink" title="第一章 基础知识"></a>第一章 基础知识</h1><h2 id="1-1-存储单元"><a href="#1-1-存储单元" class="headerlink" title="1.1 存储单元"></a>1.1 存储单元</h2><p>一个存储单元存储的信息量以<strong>bit</strong>为单位（最小）。而转换关系中8 bit=1 bytes(B)。而一个字=两个字节<br>在微型计算机存储器的存储单元中，一个单元可以存<strong>1 B</strong>（即8个进制位）。而一个存储器有128个单元，则可以存储128 B。</p>
<h2 id="1-2-CPU对存储器的读写"><a href="#1-2-CPU对存储器的读写" class="headerlink" title="1.2 CPU对存储器的读写"></a>1.2 CPU对存储器的读写</h2><p>要读写，则应该与三类信息进行交互：</p>
<blockquote>
<ol>
<li>地址信息</li>
<li>控制信息</li>
<li>数据信息</li>
</ol>
</blockquote>
<p>而逻辑上又分为3类总线，分别传输信息：</p>
<blockquote>
<ol>
<li>地址总线（指出内存中的信息放在那里(自下而上读01)）</li>
<li>控制总线（若要传输的数据多于一次性传输的宽度，则分开来多传几次）</li>
<li>数据总线</li>
</ol>
</blockquote>
<h3 id="1-2-1-影响性能的因素："><a href="#1-2-1-影响性能的因素：" class="headerlink" title="1.2.1 影响性能的因素："></a>1.2.1 影响性能的因素：</h3><h4 id="宽度（线的条数）：它决定了部件的能力（速度，控制能力等）。8086为16条，8088为8条"><a href="#宽度（线的条数）：它决定了部件的能力（速度，控制能力等）。8086为16条，8088为8条" class="headerlink" title="宽度（线的条数）：它决定了部件的能力（速度，控制能力等）。8086为16条，8088为8条"></a>宽度（线的条数）：它决定了部件的能力（速度，控制能力等）。8086为16条，8088为8条</h4><blockquote>
<p>若CPU的寻址能力为8KB，则总线宽度：8*1024/1 = $2^13$ (注意单位是B,13则为总线宽度)</p>
</blockquote>
<h1 id="第二章-寄存器"><a href="#第二章-寄存器" class="headerlink" title="第二章 寄存器"></a>第二章 寄存器</h1><h2 id="2-1-通用寄存器"><a href="#2-1-通用寄存器" class="headerlink" title="2.1 通用寄存器"></a>2.1 通用寄存器</h2><p>有<strong>AX BX CX DX</strong>四种，它们分为高位和低位以兼容以前的程序，如（AX = AH(高) + AL(低)）<br><em>要注意的是：若只用AL进行运算，若超出其范围，超出的数据不会到AH当中！</em></p>
<h2 id="2-2-CPU给出物理地址的方法"><a href="#2-2-CPU给出物理地址的方法" class="headerlink" title="2.2 CPU给出物理地址的方法"></a>2.2 CPU给出物理地址的方法</h2><blockquote>
<p>段地址(<strong>SA</strong>)：只是为了内存的管理，并不是真分段。16位地址分段，一段64KB<br>偏移地址(<strong>EA</strong>)：16位地址最多64KB<br>公式：物理地址=段地址*16+偏移地址</p>
</blockquote>
<h2 id="2-3-段寄存器"><a href="#2-3-段寄存器" class="headerlink" title="2.3 段寄存器"></a>2.3 段寄存器</h2><p>有<strong>CS DS SS ES</strong>四种。CS常存储段地址。它们提供了一下功能：</p>
<ol>
<li>CS：CPU要<strong>执行指令</strong>的地址。相当于命令指针</li>
<li>DS：读取内存的地址（返回数据）。相当于数据指针</li>
<li>SS：存储内存中的栈的顶。相当于栈顶指针</li>
</ol>
<h3 id="2-3-1-CS和IP"><a href="#2-3-1-CS和IP" class="headerlink" title="2.3.1 CS和IP"></a>2.3.1 CS和IP</h3><p>IP是存储基于CS的偏移量。修改的流程：</p>
<blockquote>
<p>一般流程：读取指令 -&gt; 修改 IP+=<em>命令长度</em> -&gt; 执行指令(可能会涉及修改CS:IP) -&gt; 读取指令…<br><em>8086PC启动时在FFFF0H单元中读取指令执行</em></p>
</blockquote>
<h2 id="2-4-疑问"><a href="#2-4-疑问" class="headerlink" title="2.4 疑问"></a>2.4 疑问</h2><h3 id="1-为什么偏移地址只能在64Kb内？"><a href="#1-为什么偏移地址只能在64Kb内？" class="headerlink" title="1. 为什么偏移地址只能在64Kb内？"></a>1. 为什么偏移地址只能在64Kb内？</h3><p>一个16位的CPU，只能有1111 1111 1111 1111，代表了4个16进制数，所以能表示2**16 bit的数据，恰好，就是64Kb。</p>
<h3 id="2-暂留"><a href="#2-暂留" class="headerlink" title="2.暂留"></a>2.暂留</h3><h1 id="第三章-寄存器（内存访问）"><a href="#第三章-寄存器（内存访问）" class="headerlink" title="第三章 寄存器（内存访问）"></a>第三章 寄存器（内存访问）</h1><h2 id="3-1-内存中字的存储"><a href="#3-1-内存中字的存储" class="headerlink" title="3.1 内存中字的存储"></a>3.1 内存中字的存储</h2><blockquote>
<p>字单元的概念：即存放一个字型数据的内存单元，由<strong>两个地址连续</strong>的内存单元（一个8位）组成。高放高位，低放低位。</p>
</blockquote>
<p>这里解释一下： 若有单元[0]-&gt;2e，[1]-&gt;33，那么我们读[0]的字型数据为：332eH（高放高位）</p>
<h2 id="3-2-DS和-address"><a href="#3-2-DS和-address" class="headerlink" title="3.2 DS和[address]"></a>3.2 DS和[address]</h2><blockquote>
<p>“[…]”表示一个内存单元，表示在段地址下的偏移量。如10000H = 1000:0 = [0]</p>
</blockquote>
<ul>
<li><p>在masm汇编编辑器中，如果单纯写mov ax,[0]，那么他会把[0]当做0来解释，即指令变成：mov ax,0<br>而若用bx作为中转，那是可以的！如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mov bx,0</span><br><span class="line">mov ax,[bx]</span><br></pre></td></tr></table></figure>
<p>这个是可以把[bx]当成段地址，返回ds:bx下的数据的！<br>而如果偏要用[idata]的话，那么就必须加上<strong>ds:</strong>前缀，如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mov ax,ds:[0]</span><br></pre></td></tr></table></figure>
</li>
<li><p>而对于Debug编译器的话，ds是自动加上的，用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mov ax,[0]</span><br></pre></td></tr></table></figure>
<p>即可，如果使用[]的话，而且他（段寄存器）是不能直接用mov命令改变的，必须通过其他的寄存器中转才能改变。</p>
</li>
</ul>
<h2 id="3-3-字的传送（mov指令）"><a href="#3-3-字的传送（mov指令）" class="headerlink" title="3.3 字的传送（mov指令）"></a>3.3 字的传送（mov指令）</h2><p>在传送字之后， DS和[address]也会跟着变，如1000:0，若传入一个fffeH，则address会从0-&gt;2，此时，[0]存有feH，[1]存有ffH,[2]为空。</p>
<h2 id="3-4-mov、add、sub指令"><a href="#3-4-mov、add、sub指令" class="headerlink" title="3.4 mov、add、sub指令"></a>3.4 mov、add、sub指令</h2><p>主要是说说置零问题，与机械码长度问题，稍微提一下，以后会细讲。<br>举例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sub bx, bx</span><br><span class="line">mov bx, 0</span><br></pre></td></tr></table></figure>
<p>两个都是可以将bx寄存器置零的指令，但是sub的机械码长度为2，而mov为3，用sub更好。<br>另外说说jmp指令，他是转移指令，具有一个操作对象的指令，而上面的具有两个。</p>
<h2 id="3-5-栈"><a href="#3-5-栈" class="headerlink" title="3.5 栈"></a>3.5 栈</h2><p>他是一个FILO结构（先入后出），而且是从大变小（地址）。</p>
<h3 id="3-5-1-push和pop"><a href="#3-5-1-push和pop" class="headerlink" title="3.5.1 push和pop"></a>3.5.1 push和pop</h3><blockquote>
<p>执行push ax命令，会把ax中的数据传入ss:sp指向的地址空间。此时<strong>sp-=2</strong><br>执行pop ax命令，会把ss:sp指向的地址空间中的数据传给ax。此时<strong>sp+=2</strong></p>
</blockquote>
<p>执行之后的指针变化：</p>
<ul>
<li>push先令sp-=2，然后将ax中的数据放进去。称为出栈。</li>
<li>pop是先取出数据放到ax中，再sp+=2。称为入栈。</li>
</ul>
<p><img src="/2019/11/10/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80-%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0/3.5.png" alt></p>
<h3 id="3-5-2-数据传输"><a href="#3-5-2-数据传输" class="headerlink" title="3.5.2 数据传输"></a>3.5.2 数据传输</h3><p>如8086cpu的入栈和出栈都是以<strong>字</strong>为单位进行的。</p>
<h3 id="3-5-3-栈指针"><a href="#3-5-3-栈指针" class="headerlink" title="3.5.3 栈指针"></a>3.5.3 栈指针</h3><p>上面已经用到了：段寄存器:寄存器存储(ss:sp)<br>sp是指偏移地址，ss:sp始终指向栈顶。</p>
<h2 id="3-6-栈顶越界问题"><a href="#3-6-栈顶越界问题" class="headerlink" title="3.6 栈顶越界问题"></a>3.6 栈顶越界问题</h2><p>栈溢出问题都是大问题，如果栈顶越界了，那么执行push和pop会受影响吗？当然不会！直接刚，写！写！写！出！出！出！管你呢。<br>所以就会有可能读了其他程序的数据，或者<strong>修改了（覆盖）</strong>其他程序的数据（直接崩溃的说）<br>执行情况（取自《汇编语言第二版》王爽著）<br><img src="/2019/11/10/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80-%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0/3.6.jpg" alt></p>
<h2 id="3-7-问题"><a href="#3-7-问题" class="headerlink" title="3.7 问题"></a>3.7 问题</h2><h3 id="1-程序与数据有区别吗？"><a href="#1-程序与数据有区别吗？" class="headerlink" title="1.程序与数据有区别吗？"></a>1.程序与数据有区别吗？</h3><p>可以说有，也可以说没有。由于指令都是0和1组成的，只是用不同功能的段地址读出来的不一样，如,CS和DS都指向10000H，那么，CS会将里头的数据转化为机械码，执行指令，而DS就直接读数据，作为单纯的数据使用。</p>
<h3 id="2-空栈如（10000H-1000FH）此时ss-1000H，那么sp是多少？"><a href="#2-空栈如（10000H-1000FH）此时ss-1000H，那么sp是多少？" class="headerlink" title="2.空栈如（10000H~1000FH）此时ss=1000H，那么sp是多少？"></a>2.空栈如（10000H~1000FH）此时ss=1000H，那么sp是多少？</h3><p>因为是自下而上（自大到小），所以sp=0010H。<br>换一种方式看，若存储了一个数据，则一个存到000EH，一个存到000FH，此时的栈指针在栈顶，当然指向000EH了，此时是已经让sp-=2了，那么回溯一下，不就有sp=0010H了。</p>
<ul>
<li>好了，问题来了，如果将（10000H~1FFFFH）作为空间呢？<br>答案：sp=0000H，因为，不能变成10000H(笑)</li>
</ul>
<h3 id="3-栈会溢出，那么，为什么不设置栈大小"><a href="#3-栈会溢出，那么，为什么不设置栈大小" class="headerlink" title="3.栈会溢出，那么，为什么不设置栈大小"></a>3.栈会溢出，那么，为什么不设置栈大小</h3><p>emmm，可惜8086cpu就是没有，所以变成自己注意。</p>
<h3 id="4-只有mov可以完成传输数据吗？"><a href="#4-只有mov可以完成传输数据吗？" class="headerlink" title="4.只有mov可以完成传输数据吗？"></a>4.只有mov可以完成传输数据吗？</h3><p>push也可以哦，只要把sp定位为ds:[address]那就好了哦。直接写进去。</p>
<h1 id="第四章-第一个程序"><a href="#第四章-第一个程序" class="headerlink" title="第四章 第一个程序"></a>第四章 第一个程序</h1><h2 id="4-1-一个源程序从写出到执行的过程"><a href="#4-1-一个源程序从写出到执行的过程" class="headerlink" title="4.1 一个源程序从写出到执行的过程"></a>4.1 一个源程序从写出到执行的过程</h2><p>执行过程包括：写程序-&gt;编译连接成可执行文件-&gt;执行。</p>
<blockquote>
<p>可执行文件文件中包括以下两部分：</p>
</blockquote>
<ol>
<li>程序和数据</li>
<li>相关的描述：程序多大，占用多少运行空间</li>
</ol>
<h2 id="4-2-源程序"><a href="#4-2-源程序" class="headerlink" title="4.2 源程序"></a>4.2 源程序</h2><h3 id="4-2-1-伪指令"><a href="#4-2-1-伪指令" class="headerlink" title="4.2.1 伪指令"></a>4.2.1 伪指令</h3><p>也就是只能被编译器识别的指令，如<strong>assume</strong>、<strong>segment</strong>、<strong>end</strong>等，<strong><em>这是没有机械码的</em></strong>。<br>一般的伪指令使用如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code  #声明（假设）cs:段名（标号）</span><br><span class="line">code segment	#段名 segment</span><br><span class="line">_指令_</span><br><span class="line">code ends		#对应segment，表示一个段结束</span><br><span class="line">end				#对应assume，表示程序结束</span><br></pre></td></tr></table></figure>

<h3 id="4-2-2-程序返回"><a href="#4-2-2-程序返回" class="headerlink" title="4.2.2 程序返回"></a>4.2.2 程序返回</h3><p>现在考虑，如何让上一个程序把CPU控制权交给写一个程序，这时候就要使用<strong>程序返回</strong><br>其代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mov ax, 4c00H</span><br><span class="line">int 21H</span><br></pre></td></tr></table></figure>
<h2 id="4-3-程序生成流程"><a href="#4-3-程序生成流程" class="headerlink" title="4.3 程序生成流程"></a>4.3 程序生成流程</h2><p><strong>编程 -&gt; <em>1.asm</em> -&gt; 编译 -&gt; <em>1.obj</em> -&gt; 连接 -&gt; <em>1.exe</em> -&gt; 加载 -&gt; <em>内存中的程序</em> -&gt; 运行</strong><br>注：加载就是将程序加载到内存，执行就是在内存中执行程序的指令</p>
<h2 id="4-4-怎么装载程序？"><a href="#4-4-怎么装载程序？" class="headerlink" title="4.4 怎么装载程序？"></a>4.4 怎么装载程序？</h2><p>操作系统是一个模块组成庞大的系统。任何通用的系统都要提供一个称为shell的程序，用户使用这个程序来操作计算机系统进行工作。</p>
<p>如DOS中有一个程序command.com，这个程序称为：命令解释器，也就是DOS中的SHELL<br>（其实跟我们的cmd.exe差不多）</p>
<p>先运行shell，然后在加载1.exe可执行程序的时候，cmd会自动把cpu的控制权交给1.exe，执行完成再返回cmd。</p>
<h2 id="4-4-展示EXE的加载过程"><a href="#4-4-展示EXE的加载过程" class="headerlink" title="4.4 展示EXE的加载过程"></a>4.4 展示EXE的加载过程</h2><p><img src="/2019/11/10/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80-%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0/4.4.png" alt></p>
<h1 id="第五章-BX-和loop指令"><a href="#第五章-BX-和loop指令" class="headerlink" title="第五章 [BX]和loop指令"></a>第五章 [BX]和loop指令</h1><h2 id="5-1-BX"><a href="#5-1-BX" class="headerlink" title="5.1 [BX]"></a>5.1 [BX]</h2><p>这个之前就讲过：其实就是把BX中的值作为ds的偏移地址EA，然后可以用这个来访问特定地址下的数据。<br>如ds:1000H，bx=0001H，那么[BX]就是指ds*16+bx下的值。</p>
<h2 id="5-2-loop"><a href="#5-2-loop" class="headerlink" title="5.2 loop"></a>5.2 loop</h2><p>直接上程序：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">assume cs:eloop</span><br><span class="line">eloop segment</span><br><span class="line">	mov ax,128</span><br><span class="line">	mov cx,36</span><br><span class="line">  s:add ax,ax</span><br><span class="line">	loop s</span><br><span class="line">eloop ends</span><br><span class="line">end</span><br></pre></td></tr></table></figure>
<p>解释：</p>
<ol>
<li>loop是按照cx当中的值进行对有标号的s下的命令进行循环的。当cx不等于0，则执行循环，这个程序实际上是实现128*36的程序。</li>
<li>s实际上是IP值，指向s标记的地址，所以loop s实际上是给IP赋值：IP=s，然后就可以通过cs:ip来执行指令了</li>
</ol>
<blockquote>
<p>注意：汇编程序中，数据不能以字母开头，所以要在前面加个0。比如：9138h可以写成9138h，而A000h就必须写成0A000h</p>
</blockquote>
<h2 id="5-3-loop和-bx-的联合运用"><a href="#5-3-loop和-bx-的联合运用" class="headerlink" title="5.3 loop和[bx]的联合运用"></a>5.3 loop和[bx]的联合运用</h2><p>例如来一个如同C++语言中的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">int dx = 0;</span><br><span class="line">int ds[12] = &#123;1, 2, ...&#125;;</span><br><span class="line">for(int i=0; i &lt; 12; i++)</span><br><span class="line">&#123;</span><br><span class="line">	dx += ds[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>那么汇编语言就有：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code</span><br><span class="line">code segment:</span><br><span class="line">	mov ax, 0ffffh	;因为ds寄存器不能直接赋值，所以用ax作为中间变量</span><br><span class="line">	mov ds,ax		</span><br><span class="line">	mov bx,0		;初始化ds:bx指向ffff:0</span><br><span class="line"></span><br><span class="line">	mov dx,0		;初始化**累加寄存器**dx，让值为0</span><br><span class="line"></span><br><span class="line">	mov cx,12		;初始化循环计数寄存器cx，令值为12，指循环12次</span><br><span class="line"></span><br><span class="line"> s: mov al,[bx]		;以下两步执行ax的赋值操作</span><br><span class="line">	mov ah,0		;</span><br><span class="line">	add dx,ax		;执行加法</span><br><span class="line">	inc bx			;ds:bx指向下一个单元，因为bx的值增加了1，相当于C++代码中的*i++*</span><br><span class="line">	loop s			;loop完成一次，则cx=cx-1，然后判断cx是否等于0，如果等于则退出循环</span><br><span class="line"></span><br><span class="line">	mov ax,4c00h</span><br><span class="line">	int 21h</span><br><span class="line"></span><br><span class="line">code ends</span><br><span class="line">end</span><br></pre></td></tr></table></figure>
<p>好了，现在来说说这段代码里面有什么需要注意的点：</p>
<ol>
<li>cx寄存器一般用作loop循环的判断条件，即<strong>循环的粗次数</strong>。</li>
<li>ax寄存器的初始化有两步，是，因为一个字符型数据是8位这样的话转化为16位就得让高8位的值赋为0。</li>
<li>dx寄存器是常用的累加寄存器。</li>
<li>inc指令是让后面的值加一的指令，相当于C++语言中的‘++’自增。</li>
<li>int指令：<blockquote>
<p>由int 指令引发的中断是一种重要的内中断。<br>格式： int n   //相当于引发一个n号中断的过程,最终功能和call指令相似，都是调用一段程序。</p>
<ul>
<li>取中断类型码n</li>
<li>标志寄存器入栈，并IF=0,TF=0      //TF=0使得避免中断程序执行过程中引发单步中断</li>
<li>CS,IP寄存器入栈</li>
<li>IP=(n*4) , CS=(n*4 + 2)<br><a href="https://blog.csdn.net/u010034085/article/details/97819727" target="_blank" rel="noopener">原文链接</a></li>
</ul>
</blockquote>
</li>
</ol>
<h2 id="5-4-段前缀与其使用"><a href="#5-4-段前缀与其使用" class="headerlink" title="5.4 段前缀与其使用"></a>5.4 段前缀与其使用</h2><blockquote>
<ul>
<li>能够显示地指令内存单元的段地址的，如：”ds:”、”cs:”、”ss:”、”es:”。这就是段前缀。</li>
<li>默认的[x]是指：(dx*16)+x，而如果要用其他的段寄存器，则需要加上它的段前缀。 </li>
</ul>
</blockquote>
<h1 id="第六章-包含多个段的程序"><a href="#第六章-包含多个段的程序" class="headerlink" title="第六章 包含多个段的程序"></a>第六章 包含多个段的程序</h1><blockquote>
<p>由于软件是由数据和程序组成的，数据当然也是程序里面必不可少的部分，所以会将代码分为多段进行，如数据段、代码段等。</p>
</blockquote>
<h2 id="6-1-在代码段中使用数据"><a href="#6-1-在代码段中使用数据" class="headerlink" title="6.1 在代码段中使用数据"></a>6.1 在代码段中使用数据</h2><blockquote>
<p><strong>汇编程序若没有特殊的说明（或者注明在哪里开始），则默认从头开始！</strong><br>所以，一旦你的程序头部有数据，则将会把头部的数据翻译为<strong>机器码</strong>执行。(冤)</p>
</blockquote>
<p>那么解决方式是：在开始执行代码的地方加上 <strong>start:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code</span><br><span class="line">code segment</span><br><span class="line">  dw 0123h,0456h,0789h ;这里是数据部分 dw意思是定义字符型数据</span><br><span class="line">  start: mov bx,0   ;注意，从这开始，标识为start!</span><br><span class="line">         mov ax,0</span><br><span class="line"></span><br><span class="line">         mov cx,8</span><br><span class="line">	  s: add ax,cs:[bx]	;用cs作为段地址，取数据！</span><br><span class="line">         add bx,2</span><br><span class="line">         loop s</span><br><span class="line">         </span><br><span class="line">         mov ax,4c00h</span><br><span class="line">         int 2h</span><br><span class="line">code ends</span><br><span class="line">end start   ;注意end后面要加上end开始的名称！</span><br></pre></td></tr></table></figure>

<h2 id="6-2-将数据、代码、栈放入不同的段"><a href="#6-2-将数据、代码、栈放入不同的段" class="headerlink" title="6.2 将数据、代码、栈放入不同的段"></a>6.2 将数据、代码、栈放入不同的段</h2><p>上面说了，代码从哪里开始就在哪里加上<strong>start</strong>，结束就用<strong>end start</strong>（其他标识也行）<br>好，记住，那是代码，别把接下来说的混淆了。</p>
<p>不同的段可以放不同的东西，例如数据，代码等等。<br>只要记住将段名end了再定义其他段。也只有定义了，才能使用这个段</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">assume cs:b,ds:a,ss:c</span><br><span class="line">a segment</span><br><span class="line">    dw 0123h, 0456h, 0789h, 0abch, 0de fh, Ofedh, 0cbah, 0987h</span><br><span class="line">a ends</span><br><span class="line"></span><br><span class="line">c segment</span><br><span class="line">    dw 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0</span><br><span class="line">c ends</span><br><span class="line"></span><br><span class="line">b segment</span><br><span class="line">d:  mov ax,c  ;使用段c中的数据</span><br><span class="line">    mov ss,ax</span><br><span class="line">    mov sp, 20h  ;希望用c段当作栈空间，设置ss:sp指向c:20</span><br><span class="line"></span><br><span class="line">    mov ax,a	;使用段a</span><br><span class="line">    mov ds,ax  ;希望用ds:bx访问a段中的数据，ds指向a段</span><br><span class="line">    mov bx,0  ;ds:bx指向a段中的第一一个单元</span><br><span class="line">    mov Cx,8</span><br><span class="line"></span><br><span class="line">s:  push [bx]</span><br><span class="line">    add bx,2</span><br><span class="line">    1oop s   ;以上将a段中的0~15单元中的8个字型数据依次入栈</span><br><span class="line"></span><br><span class="line">    mov bx,0</span><br><span class="line">    mov cx, B</span><br><span class="line">s0:	pop [bx]</span><br><span class="line">    add bx,2</span><br><span class="line">    1oop s0  ;以上依次出栈8个字型数据到a段的0~15单元中</span><br><span class="line"></span><br><span class="line">    mov ax, 4c00hint 21h</span><br><span class="line">b ends</span><br><span class="line"></span><br><span class="line">end d  ;d处是要执行的第一- 条指令，即程序的入口</span><br></pre></td></tr></table></figure>
<h1 id="第七章-更灵活的定位内存地址的方法"><a href="#第七章-更灵活的定位内存地址的方法" class="headerlink" title="第七章 更灵活的定位内存地址的方法"></a>第七章 更灵活的定位内存地址的方法</h1><p>之前的[0]和[bx]均可以起到定位的作用，现在有更灵活的定位方式：</p>
<h2 id="7-1-and和or指令"><a href="#7-1-and和or指令" class="headerlink" title="7.1 and和or指令"></a>7.1 and和or指令</h2><blockquote>
<p>and是有零变零，而or是有一变一<br>也可以想象成and是乘法，or是加法</p>
</blockquote>
<h2 id="7-2-以字符型给出数据"><a href="#7-2-以字符型给出数据" class="headerlink" title="7.2 以字符型给出数据"></a>7.2 以字符型给出数据</h2><p>凡是以’…’形式给出数据的，都被译为是字符型数据，这样，编译器会将里面的数据变成ASCII码值。具体实例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">db &apos;unIX&apos;</span><br><span class="line">mov al,&apos;a&apos;</span><br></pre></td></tr></table></figure>
<p>这里被译为</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">db 75H,6EH,49H,58H</span><br><span class="line">mov al,61H</span><br></pre></td></tr></table></figure>
<p>而大小写转换的方法有两种：</p>
<ol>
<li>基于比较的，在ASCII码中，大写字母+20H=小写字母</li>
<li>基于二进制数的，在ASCII表达字符时，若第五位为0，则为大写字母；若第五位为1则为小写字母（这里可以用or或者and来进行转换）</li>
</ol>
<h2 id="7-3-以-bx-idata-的方式寻址"><a href="#7-3-以-bx-idata-的方式寻址" class="headerlink" title="7.3 以[bx+idata]的方式寻址"></a>7.3 以[bx+idata]的方式寻址</h2><p>现在以例题进行解析，将第一组字符串变成大写，第二组变成小写</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">assume cs:codesg,ds:datasg</span><br><span class="line">datasg segment</span><br><span class="line">  db &apos;BaSiC&apos;</span><br><span class="line">  db &apos;MinIX&apos;</span><br><span class="line">datasg ends</span><br><span class="line">codesg segment</span><br><span class="line">start:			;代码段</span><br><span class="line">codesg ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure>
<ul>
<li>原来的思想：取[bx]中的字符，再对其进行and 11011111b操作，再放回去，然后将bx自增，再重新···，而变成小写就or 00100000b。（这里要执行两次循环啊，一个变大写，一个变小写）</li>
<li>然而我们可以使用以下思想，更加便捷，就是[bx+idata]：思想和前面的一样，但是，不用执行两次循环，只要一次就够了：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">  mov ax,datasg</span><br><span class="line">  mov ds, ax</span><br><span class="line">  mov bx,0</span><br><span class="line">  </span><br><span class="line">  mov cx,5</span><br><span class="line">s:mov al,[bx]      ;定位第一个字符串的第bx个字符</span><br><span class="line">  and al,11011111b ;执行完变大工作</span><br><span class="line">  mov [bx],al      ;放回去</span><br><span class="line">  mov al[5+bx]     ;定位第二个字符串的第bx个字符（因为一个字符串只有5个字符）</span><br><span class="line">  or al,00100000b  ;执行变小工作</span><br><span class="line">  mov [5+bx],al    ;放回去</span><br><span class="line">  inc bx           ;自增</span><br><span class="line">  loop s</span><br></pre></td></tr></table></figure>
这个其实，学过高级语言都知道这方法，只不过，没想到汇编也能做吧，汇编语言也不是那么死板的。</li>
</ul>
<h2 id="7-4-si与di寄存器和多重循环"><a href="#7-4-si与di寄存器和多重循环" class="headerlink" title="7.4 si与di寄存器和多重循环"></a>7.4 si与di寄存器和多重循环</h2><p>这个只要知道是16位寄存器，功能和bx差不多，可以用作[bx+si+idata]和[bx+di+idata]就可以了。其中，idata是常量，其他的为变量。这个结构可以执行二重循环，相当于处理二维数组。<br>需要注意的是二重循环的实现：</p>
<blockquote>
<ul>
<li>问题一：cx寄存器是用作循环的判定条件的，那么二重循环对于没有两个cx的我们来说，如何是好？<br>将之前的cx用其他寄存器保存起来啊！</li>
<li>问题二：二重循环可以那样做，那么多重循环呢！？你只有有限个寄存器。<br>利用内存空间！开辟一段dw 0，让后指向它，放进去就完事了。</li>
<li>问题三：那这个方法的前提是我得知道有多少个循环，很麻烦啊，换个简单的。</li>
<li><em>在需要暂存数据的时候我们都应该使用栈*</em></li>
<li><em>在需要暂存数据的时候我们都应该使用栈*</em></li>
<li><em>在需要暂存数据的时候我们都应该使用栈*</em><br>按顺序push，然后逆向按顺序pop</li>
</ul>
</blockquote>
<h1 id="第八章-数据处理的两个基本问题"><a href="#第八章-数据处理的两个基本问题" class="headerlink" title="第八章 数据处理的两个基本问题"></a>第八章 数据处理的两个基本问题</h1><p>这两个问题是：</p>
<ol>
<li><strong>处理的数据在什么地方</strong></li>
<li><strong>要处理的数据有多长</strong></li>
</ol>
<h2 id="8-1-bx、si、di和bp"><a href="#8-1-bx、si、di和bp" class="headerlink" title="8.1 bx、si、di和bp"></a>8.1 bx、si、di和bp</h2><p>这几个都用过，主要说说bp:这个只要在[…]里使用了它，没有段地址声明，那么默认是<strong>ss</strong></p>
<h2 id="8-2-机器指令处理的数据在什么地方"><a href="#8-2-机器指令处理的数据在什么地方" class="headerlink" title="8.2 机器指令处理的数据在什么地方"></a>8.2 机器指令处理的数据在什么地方</h2><p><strong>在指令执行前</strong>，所要处理的数据可以在三个地方：</p>
<ol>
<li>CPU内部</li>
<li>内存</li>
<li>端口<br>下面举例子：<br><img src="/2019/11/10/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80-%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0/8.1.png" alt><br>上图还表明了汇编语言中数据位置的表达</li>
<li>立即数（idata）：如上图的最后一个例子，是直接赋值的</li>
<li>寄存器：如上图的第二个例子，使用寄存器名。</li>
<li>段地址：如果是[bx]则默认段地址是ds，如果是[bp]则默认段地址为ss，当然可以显性给出。</li>
</ol>
<h2 id="8-3-指令处理的数据长度"><a href="#8-3-指令处理的数据长度" class="headerlink" title="8.3 指令处理的数据长度"></a>8.3 指令处理的数据长度</h2><p>这个得看具体例子。</p>
<ol>
<li>如果是ax,bx，那么这个就是字操作</li>
<li>如说是al,bl，那么就是字节操作</li>
<li>在没有寄存器名存在的情况下，用操作符X ptr指明内存单元的长度，X在汇编中可以为word或byte（且必须显式声明）。</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mov word ptr ds:[0],1	;字</span><br><span class="line">mov byte ptr ds:[0],1	;字节</span><br></pre></td></tr></table></figure>
<ol start="4">
<li>有些指令默认了访问的是字还是字节，如<strong>push</strong>默认进行<strong>字</strong>操作，而用[…]的是字单元操作(一个8位)。</li>
</ol>
<h2 id="8-4-div指令"><a href="#8-4-div指令" class="headerlink" title="8.4 div指令"></a>8.4 div指令</h2><p>div是除法指令，使用div做除法的时候应注意以下问题.</p>
<ol>
<li>除数:有8位和16位两种，在<strong>一个reg</strong>或<strong>内存单元</strong>中。</li>
<li>被除数:默认放在<strong>AX</strong>或<strong>DX和AX</strong>中<ol>
<li>如果除数为8位，<strong>被除数则为16位</strong>，<strong>默认在AX</strong>中存放；</li>
<li>如果除数为16位，<strong>被除数则为32位</strong>，在DX和AX中存放，<strong>DX存放高16位，AX存放低16位</strong>。</li>
</ol>
</li>
<li>结果:<ol>
<li>如果<strong>除数为8位</strong>，则AL存储除法操作的商，AH存储除法操作的余数:</li>
<li>如果<strong>除数为16位</strong>，则AX存储除法操作的商，DX存储除法操作的余数。</li>
</ol>
</li>
</ol>
<p>格式如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">div reg</span><br><span class="line">div 内存单元</span><br><span class="line">div byte ptr ds:[0]</span><br><span class="line">含义：(al)=(ax)/((ds)*16+0)的商</span><br><span class="line">	 (ah)=(ax)/((ds)*16+0)的余数</span><br></pre></td></tr></table></figure>
<h2 id="8-5-实例"><a href="#8-5-实例" class="headerlink" title="8.5 实例"></a>8.5 实例</h2><p>利用除法指令计算100001/100<br>分析：</p>
<ol>
<li>由于100001大于整数最大值（16位）65535，不能用ax寄存器存放，所以只能用dx和ax两个寄存器联合存放，共32位</li>
<li>而出书100小于255（8位），但是因为被除数是32位，所以除数应该用16位的来存放除数100<br>所以有程序：</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mov dx,1</span><br><span class="line">mov ax,86A1H	;(dx)*10000H+(ax)=100001   100001=186A1H</span><br><span class="line">mov bx,100</span><br><span class="line">div bx</span><br></pre></td></tr></table></figure>

<p>执行后，(ax)=03E8H(即10000)，(dx)=1(余数为1)。</p>
<h2 id="8-6-伪指令dd"><a href="#8-6-伪指令dd" class="headerlink" title="8.6 伪指令dd"></a>8.6 伪指令dd</h2><p>之前有学过用db和dw定义字节型数据和字型数据。dd是用来定义dword（double word，双字）型数据的。</p>
<ul>
<li>db 占1个字节</li>
<li>dw 占1个字（即两个字节）</li>
<li>db 占2个字（即四个字节）</li>
</ul>
<h2 id="8-7-dup"><a href="#8-7-dup" class="headerlink" title="8.7 dup"></a>8.7 dup</h2><p>dup是一个操作符，在汇编语言中与dw,db,dd一样，都是由编译器识别处理的符号，且与它们一同配合使用，用来进行数据重复。<br>如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">db 3 dup (0)</span><br><span class="line">定义了3个字节，它们的值都是0，相当于执行了 db 0,0,0。</span><br><span class="line"></span><br><span class="line">db 3 dup (1,2,3)</span><br><span class="line">定义了3\*3=9个字节，它们是0、1、2、0、1、2、0、1、2，相当于db 0,1,2,0,1,2,0,1,2。</span><br><span class="line">字符型也适用。</span><br><span class="line"></span><br><span class="line">总结：</span><br><span class="line">d？ 重复的次数 dup (重复的(字节/字/双字型)数据）</span><br></pre></td></tr></table></figure>

<h1 id="第九章-转移指令的原理"><a href="#第九章-转移指令的原理" class="headerlink" title="第九章 转移指令的原理"></a>第九章 转移指令的原理</h1><p><strong>可以修改IP 或同事修改CS和IP的指令统称为转移指令统称为转移指令</strong>。如jmp、jno等，即可以控制CPU指令内存中某处代码的指令。<br>具体分类有：</p>
<ol>
<li>无条件转移指令（jmp）</li>
<li>条件转移指令（jno）</li>
<li>循环指令（loop）</li>
<li>过程</li>
<li>中断</li>
</ol>
<p>还有其他的分类：</p>
<ol>
<li><p>只修改IP：段内转移（jmp ax）</p>
</li>
<li><p>同时修改CS和IP：段间转移（jmp 1000:0）</p>
</li>
<li><p>短转移</p>
</li>
<li><p>近转移</p>
</li>
</ol>
<h2 id="9-1-操作符offset"><a href="#9-1-操作符offset" class="headerlink" title="9.1 操作符offset"></a>9.1 操作符offset</h2><p>offset是编译器处理符号，功能：取得标号的额编译地址。<br>如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">start: mov ax, offset start	;相当于mov ax,0</span><br><span class="line">	s: mov ax, offset s		;相当于mov ax,3</span><br></pre></td></tr></table></figure>
<p>解析：第一条指令mov … 是三个字节，所以s段的offset为3</p>
<h2 id="9-2-jmp指令和依据译为进行转移的jmp指令"><a href="#9-2-jmp指令和依据译为进行转移的jmp指令" class="headerlink" title="9.2 jmp指令和依据译为进行转移的jmp指令"></a>9.2 jmp指令和依据译为进行转移的jmp指令</h2><h3 id="9-2-1-jmp-short-标号-转移到标号出执行指令"><a href="#9-2-1-jmp-short-标号-转移到标号出执行指令" class="headerlink" title="9.2.1 jmp short 标号(转移到标号出执行指令)"></a>9.2.1 jmp short 标号(转移到标号出执行指令)</h3><pre><code>1. short标号下，它属于段内短转移，对IP的修改范围为-128~127。</code></pre><h3 id="9-2-2-立即数在机器码中的表示"><a href="#9-2-2-立即数在机器码中的表示" class="headerlink" title="9.2.2 立即数在机器码中的表示"></a>9.2.2 立即数在机器码中的表示</h3><p>在一般的汇编指令当中，汇编指令的idata（立即数），不论他是表示一个数据还是内存单元的偏移地址，都会在相应的机器指令中出现，因为CPU执行的是机器指令，他必须处理这些数据或地址。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mov ax,0123h		B8 23 01</span><br><span class="line">mov ax,ds:[0123h]	A1 23 01</span><br><span class="line">push ds:[0123h]		FF 36 23 01</span><br></pre></td></tr></table></figure>
<h3 id="9-2-3-jmp转移的机制（是怎么实现转移的）"><a href="#9-2-3-jmp转移的机制（是怎么实现转移的）" class="headerlink" title="9.2.3 jmp转移的机制（是怎么实现转移的）"></a>9.2.3 jmp转移的机制（是怎么实现转移的）<span id="jmp"></span></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">start:	mov ax,0</span><br><span class="line">		mov bx,0</span><br><span class="line">		jmp short s</span><br><span class="line">		add ax,1</span><br><span class="line">	s:	inc ax</span><br></pre></td></tr></table></figure>

<ol>
<li>首先我们应该知道，jmp指令是2个字节，如代码中的jmp机械码是：<strong>EB 03</strong> 。这样的机械码，<strong>没有包含s段的地址</strong>！所以将jmp指令写入内存之后，IP=IP+2=0008h。</li>
<li>但是，执行完jmp后，IP=000Bh。因为执行JMP，就是执行IP=IP+(EB之后的偏移量)=IP+3=000Bh。</li>
<li>所以<strong>jmp执行的是给IP加偏移地址！</strong>。</li>
</ol>
<p>所以 jmp short 标号 的功能为：<strong>(ip)=(ip)+8位位移</strong></p>
<h3 id="9-2-4-继续上面的，8位位移是怎么得出来的？"><a href="#9-2-4-继续上面的，8位位移是怎么得出来的？" class="headerlink" title="9.2.4 继续上面的，8位位移是怎么得出来的？"></a>9.2.4 继续上面的，8位位移是怎么得出来的？</h3><p><img src="/2019/11/10/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80-%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0/9.2.4.png" alt></p>
<ol>
<li><strong>8位位移</strong>=<strong>标号处的地址</strong> - jmp指令<strong>后的第一个字节的地址</strong>.</li>
<li><strong>short</strong>指明此处的位移为<strong>8位位移</strong>;</li>
<li>8位位移的范围为-128-127，<strong>用补码表示</strong></li>
<li>8位位移由编译程序在编译时算出。</li>
</ol>
<blockquote>
<p>还有一种和”jmp short标号”功能相近的指令格式:<br><strong>jmp near ptr标号</strong><br>它实现的是段内近转移。功能为:<strong>(IP)=(LP)+16位位移</strong>。<br>(1) 16位位移=标号处的地址 - jmp指令后的第一个字节的地址:<br>(2) <strong>near ptr</strong>指明此处的位移为<strong>16位位移</strong>，进行的是<strong>段内近转移</strong>:<br>(3) 16位位移的范围为一32768~32767，用<strong>补码表示</strong>:<br>(4) 16位位移由编译程序在编译时算出。</p>
</blockquote>
<h3 id="9-2-5-jmp-far-ptr-标号（段间转移-远转移）"><a href="#9-2-5-jmp-far-ptr-标号（段间转移-远转移）" class="headerlink" title="9.2.5 jmp far ptr 标号（段间转移/远转移）"></a>9.2.5 jmp far ptr 标号（段间转移/远转移）</h3><p>是不是所有的jmp机械码都没有段数据呢？当然不是！小标题就说到了：far ptr，这个指令用标号的段地址和偏移地址修改CS和IP<br>如：<br><img src="/2019/11/10/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80-%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0/9.2.5.png" alt><br>解释：“OB 01 BD 0B”是目的地之在指令中的存储顺序：<br>高地址：“BD 0B”是段地址 0BBDH ；<br>低地址：“0B 01”是偏移地址 010BH ；</p>
<h3 id="9-2-6-转移地址在寄存器的jmp指令-这就相当于总结了，上面废话有点多"><a href="#9-2-6-转移地址在寄存器的jmp指令-这就相当于总结了，上面废话有点多" class="headerlink" title="9.2.6 转移地址在寄存器的jmp指令(这就相当于总结了，上面废话有点多)"></a>9.2.6 转移地址在寄存器的jmp指令(这就相当于总结了，上面废话有点多)</h3><ul>
<li>若只是一个字，则只是偏移地址（直接EB ??完事）</li>
<li>若是两个字，那么一个是段，一个是偏移地址。</li>
</ul>
<h2 id="9-3-jcxz指令"><a href="#9-3-jcxz指令" class="headerlink" title="9.3 jcxz指令"></a>9.3 jcxz指令</h2><p>该指令为有条件转移指令，所有的有条件转移指令都是<strong>短指令</strong>，即上面9.2.6说的1个字，只有位移（偏移地址），对ip的修改范围是：-128~127.</p>
<blockquote>
<p>指令格式：jcxz 标号<br>如果(cx)=0，则转移到标号这</p>
</blockquote>
<h2 id="9-4-loop指令"><a href="#9-4-loop指令" class="headerlink" title="9.4 loop指令"></a>9.4 loop指令</h2><p>也是短转移指令，pass</p>
<h2 id="9-5-编译器对转移位移超界的检测"><a href="#9-5-编译器对转移位移超界的检测" class="headerlink" title="9.5 编译器对转移位移超界的检测"></a>9.5 编译器对转移位移超界的检测</h2><p>编译的时候就会出错！因为，这超界，编译器可识别不了。这不存在的玩意儿。</p>
<h1 id="第十章-CALL和RET指令"><a href="#第十章-CALL和RET指令" class="headerlink" title="第十章 CALL和RET指令"></a>第十章 CALL和RET指令</h1><h2 id="10-1-ret和retf"><a href="#10-1-ret和retf" class="headerlink" title="10.1 ret和retf"></a>10.1 ret和retf</h2><p>它们都是用栈中的指令，而ret是改变ip，而retf是改变cs:ip，实现远转移。<br>而正是因为它们是取栈中的指令，所以要和push 和pop结合起来，而ret或者retf执行完后，相当于执行了指令pop<br>如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mov ax stack	;在前面声明的stack数据段，共16B</span><br><span class="line">mov ss ax		;栈段地址</span><br><span class="line">mov sp 16		;将值（Base）设置为16，往上加。（栈的特性）</span><br><span class="line">push cx</span><br><span class="line">push ip</span><br><span class="line">retf</span><br></pre></td></tr></table></figure>
<p>这里就相当于执行了刚放进去的机器码。</p>
<h2 id="10-2-call指令"><a href="#10-2-call指令" class="headerlink" title="10.2 call指令"></a>10.2 call指令</h2><ul>
<li>将打那个钱的IP或CS:IP压入栈中</li>
<li>转移</li>
</ul>
<p>注意：call指令不能执行短转移，其实现方法与<a href="#jmp">jmp指令</a>相同</p>
<h3 id="10-2-1-依据位移进行转移的call指令"><a href="#10-2-1-依据位移进行转移的call指令" class="headerlink" title="10.2.1 依据位移进行转移的call指令"></a>10.2.1 依据位移进行转移的call指令</h3><blockquote>
<p>call 标号(将当期那的ip压入栈后，转到标号处执行指令)</p>
</blockquote>
<p>指令执行时会带有以下操作：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1. (sp)=(sp)-2	;压栈</span><br><span class="line"> ((ss)*16+(sp))=(IP)</span><br><span class="line">2. (IP)=(IP)+16位位移</span><br></pre></td></tr></table></figure>
<p>这个位移之前也说过了，不多讲。<br>看到上面的代码我们也能联想到jmp的执行了，相当于：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">push IP</span><br><span class="line">jmp near ptr 标号</span><br></pre></td></tr></table></figure>
<p>举个例子！</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">内存地址 机器码 汇编指令 </span><br><span class="line">1000:0 b8 00 00 mov ax,0 </span><br><span class="line">1000:3 e8 01 00 call s </span><br><span class="line">1000:6 40 		inc ax </span><br><span class="line">1000:7 58 		s:pop ax</span><br></pre></td></tr></table></figure>
<p>也许你会想到：我没有push哪来的pop!?</p>
<ol>
<li>在call之时已经有了push ip，此时的ip=提取call s之后指向下一个执行机器码（inc ax）的ip指针，也就是ip=6。</li>
<li>而当call转移到s，ip就变为call之后的ip。</li>
<li>此时再pop ax，也就是ax=6。</li>
<li>因为执行完s，没有<span id="ret"></span>回调指令pop ip。。。所以不会执行inc ax</li>
</ol>
<h3 id="10-2-2-转移地址在指令中的call指令"><a href="#10-2-2-转移地址在指令中的call指令" class="headerlink" title="10.2.2 转移地址在指令中的call指令"></a>10.2.2 转移地址在指令中的call指令</h3><p>这个也就是段间转移了，是相对于上头说的段内转移</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">call far ptr 标号</span><br></pre></td></tr></table></figure>
<p>此时会执行cs和ip双压栈</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">1. (sp)=(sp)-2	;压栈</span><br><span class="line"> ((ss)*16+(sp))=(CS)</span><br><span class="line">(sp)=(sp)-2	;压栈</span><br><span class="line"> ((ss)*16+(sp))=(IP)</span><br><span class="line">2. (CS)=标号所在的段地址</span><br><span class="line">(IP)=标号在段中的偏移地址</span><br><span class="line"></span><br><span class="line">即：</span><br><span class="line">push CS</span><br><span class="line">push IP</span><br><span class="line">jmp far ptr 标号</span><br></pre></td></tr></table></figure>
<p>举个例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1000:0 b8 00 00 		mov ax,0</span><br><span class="line">1000:3 9a 09 00 00 10 	call far ptr s</span><br><span class="line">1000:8 40 				inc ax</span><br><span class="line">1000:9 58 			s:	pop ax</span><br><span class="line">						add ax,ax</span><br><span class="line">						pop bx</span><br><span class="line">						add ax,bx</span><br></pre></td></tr></table></figure>
<p>ax是多少呢？</p>
<ol>
<li>call指令执行之后，stack中有cs和ip两个数据，CS在底部,IP在顶部。所以第一次pop ax，ax=ip=8</li>
<li>执行add后ax=16即10H</li>
<li>再执行pop，bx=1000H</li>
<li>add指令执行后ax=ax+bx=1010H</li>
</ol>
<h3 id="10-2-3-转移指令在寄存器中的call指令"><a href="#10-2-3-转移指令在寄存器中的call指令" class="headerlink" title="10.2.3 转移指令在寄存器中的call指令"></a>10.2.3 转移指令在寄存器中的call指令</h3><pre><code>call 16位reg</code></pre><p>功能：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">push IP</span><br><span class="line">jmp 16位reg	;IP=(reg)</span><br></pre></td></tr></table></figure>
<p>这个跟10.2.1是不是很像？段内转移。例子：call ax（当ax=6,则转到cs:6处执行）</p>
<h3 id="10-2-4-转移指令在内存中的call指令"><a href="#10-2-4-转移指令在内存中的call指令" class="headerlink" title="10.2.4 转移指令在内存中的call指令"></a>10.2.4 转移指令在内存中的call指令</h3><pre><code>call word ptr 内存单元地址</code></pre><p>功能：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">push IP</span><br><span class="line">jmp word ptr 内存单元地址</span><br></pre></td></tr></table></figure>
<p>其实跟10.2.3没啥两样。</p>
<p>但是还有一种双字型：<br>    call dword ptr 内存单元地址<br>功能：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">push CS</span><br><span class="line">push IP</span><br><span class="line">jmp dword ptr 内存单元地址</span><br></pre></td></tr></table></figure>
<p>举个例子就明白了</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mov sp,10h</span><br><span class="line">mov ax,0123h</span><br><span class="line">mov ds:[0],ax</span><br><span class="line">mov word ptr ds:[2]，0</span><br><span class="line">call dword ptr ds:[0]</span><br></pre></td></tr></table></figure>
<p>执行后：(CS)=0, (IP)=0123H, (sp)=0CH.</p>
<h2 id="10-3-call与ret的配合使用（敲黑板！）"><a href="#10-3-call与ret的配合使用（敲黑板！）" class="headerlink" title="10.3 call与ret的配合使用（敲黑板！）"></a>10.3 call与ret的配合使用（敲黑板！）</h2><ul>
<li>call之时压ip到栈中!</li>
<li>call完之后，执行转移后的指令</li>
<li>通过ret取出栈中的地址，执行转移操作！即<strong><a href="#ret">回调</a></strong>作用！</li>
<li>回调完成就可以执行call之后的代码了！<br>分析例子：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code</span><br><span class="line">code segment</span><br><span class="line">  start: mov ax,1</span><br><span class="line">         mov cx,3</span><br><span class="line">         call s</span><br><span class="line">         mov bx,ax	;(b)=?</span><br><span class="line">         mov ax,4c00h</span><br><span class="line">         int 21h</span><br><span class="line">      s: add ax,ax</span><br><span class="line">         loop s</span><br><span class="line">         ret</span><br><span class="line">code ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure>
<blockquote>
<p> 我们来看一下CPU执行这个程序的主要过程。<br>  (1)CPU将call s指令的机器码读入，IP指向了call s后的指令mov bx,ax.然后CPU执行call s指令，将当前的IP值(指令mov bx,ax的偏移地址)压栈，并将IP的值改变为标号s处的偏移地址:<br>  (2) CPU从标号s处开始执行指令，loop循环完毕后，(ax)=8;<br>  (3) CPU将ret指令的机器码读入，IP指向了ret指令后的内存单元，然后CPU执行ret指令，从栈中弹出一个值(即call s先前压入的mov bx,ax指令的偏移地址)送入IP中。则CS:IP指向指令mov bx,ax;<br>  (4) CPU从mov bx,ax开始执行指令，直至完成。</p>
</blockquote>
</li>
</ul>
<h2 id="10-4-mul乘法指令"><a href="#10-4-mul乘法指令" class="headerlink" title="10.4 mul乘法指令"></a>10.4 mul乘法指令</h2><p>之前说了div除法指令，现在说乘法指令。</p>
<h3 id="10-4-1-乘法规则"><a href="#10-4-1-乘法规则" class="headerlink" title="10.4.1 乘法规则"></a>10.4.1 乘法规则</h3><p>这里跟div的除数和被除数不一样的是，乘法的两个数，要么都是8位要么都是16位！</p>
<ol>
<li>乘法的两个数</li>
</ol>
<ul>
<li>如果是8位，一个放在<strong>AL</strong>中，一个放在8位的reg或内存字节单元中。</li>
<li>如果是16位，一个放在<strong>AX</strong>中，一个放在16位的reg或内存字节单元中。</li>
</ul>
<ol start="2">
<li>乘法的结果</li>
</ol>
<ul>
<li>如果是8位乘法，结果放在<strong>AX</strong>中</li>
<li>如果是16位乘法，<strong>高位放DX</strong>，<strong>低位放AX</strong></li>
</ul>
<h3 id="10-4-2-指令格式："><a href="#10-4-2-指令格式：" class="headerlink" title="10.4.2 指令格式："></a>10.4.2 指令格式：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mul reg</span><br><span class="line">mul 内存单元</span><br></pre></td></tr></table></figure>
<p>格式说明：<br>因为有一个放在了al(以8位为例)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mov al 1</span><br><span class="line">mov byte ptr ds:[0] 2</span><br><span class="line">mul ds:[0]</span><br></pre></td></tr></table></figure>
<p>这个就是用2*1了~<br>结果是ax=2（当然，我赋值的是十进制嘛）</p>
<h3 id="10-4-3-用mul寻址"><a href="#10-4-3-用mul寻址" class="headerlink" title="10.4.3 用mul寻址"></a>10.4.3 用mul寻址</h3><ol>
<li>mul byte ptr ds:[0]<br>含义：ax=al<em>(ds</em>16+0)</li>
<li>mul word ptr [bx+si+8]<br>含义：dx=</li>
</ol>
<h2 id="10-5-模块化程序设计"><a href="#10-5-模块化程序设计" class="headerlink" title="10.5  模块化程序设计"></a>10.5  模块化程序设计</h2><h3 id="10-5-1-参数和结果的传递问题"><a href="#10-5-1-参数和结果的传递问题" class="headerlink" title="10.5.1 参数和结果的传递问题"></a>10.5.1 参数和结果的传递问题</h3><p>也就是说，传进来的参数是啥，返回值是个啥。</p>
<ol>
<li>传入的参数：<br>这个有很多，有用栈传递的，也有直接用内存单元或者寄存器。</li>
<li>返回值：<br>这个可以存在寄存器中返回跟传入参数的方法很像</li>
</ol>
<p>而模块化设计，其实就是相当于c语言中的函数，把一个段中的代码当做一个函数执行。</p>
<h3 id="10-5-2-寄存器冲突问题"><a href="#10-5-2-寄存器冲突问题" class="headerlink" title="10.5.2 寄存器冲突问题"></a>10.5.2 寄存器冲突问题</h3><p>冲突问题是什么呢？例如如果上面的模块使用的loop，即使用了寄存器cx，而call的模块也适用了loop，即也使用了cx，那么两者就将共用cx，肯定会出错！<br>解决办法有：</p>
<ol>
<li>让别的调用者调用其他寄存器（这个很难实现，你也不知道他会用到什么寄存器）</li>
<li>不要使用会冲突的寄存器（这个不可能实现，只是说说理想罢了）</li>
<li>用栈，压进去，保存，call完在出栈！（这个OK哦）</li>
</ol>
<h2 id="10-6-课后"><a href="#10-6-课后" class="headerlink" title="10.6 课后"></a>10.6 课后</h2><h3 id="下面的程序执行后，ax和bx中的数值为多少？"><a href="#下面的程序执行后，ax和bx中的数值为多少？" class="headerlink" title="下面的程序执行后，ax和bx中的数值为多少？"></a>下面的程序执行后，ax和bx中的数值为多少？</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">assume cs:codesg</span><br><span class="line">stack segment</span><br><span class="line">    dw 8 dup(0)</span><br><span class="line">stack ends</span><br><span class="line">codesg segment</span><br><span class="line">start:</span><br><span class="line">    mov ax,stack</span><br><span class="line">    mov ss,ax</span><br><span class="line">    mov sp,10h</span><br><span class="line">    mov word ptr ss:[0],offset s ;(ss:[0])=1ah</span><br><span class="line">    mov ss:[2],cs                ;(ss:[2])=cs</span><br><span class="line">    call dword ptr ss:[0]        ;cs入栈,ip=19h入栈,转到cs:1ah处执行指令</span><br><span class="line">                                 ;(ss:[4])=cs,(ss:[6])=ip</span><br><span class="line">    nop</span><br><span class="line">s:  mov ax,offset s              ;ax=1ah</span><br><span class="line">    sub ax,ss:[0ch]              ;ax=1ah-(ss:[0ch])=1ah-19h=1</span><br><span class="line">    mov bx,cs                    ;bx=cs＝0c5bh</span><br><span class="line">    sub bx,ss:[0eh]              ;bx=cs-cs=0</span><br><span class="line">    mov ax,4c00h</span><br><span class="line">    int 21h</span><br><span class="line">codesg ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure>
<h3 id="实验10-1-编写子程序-之-显示字符串"><a href="#实验10-1-编写子程序-之-显示字符串" class="headerlink" title="实验10-1 编写子程序 之 显示字符串"></a>实验10-1 编写子程序 之 显示字符串</h3><p>在这次实验中，我们将要编写3个子程序，通过它们来认识几个常见的问题和掌握解决这些问题的方法.同前面的所有实验一样，这个实验是必须独立完成的，在后面的课程中，将要用到这个实验中编写的3个子程序。</p>
<h4 id="显示字符串"><a href="#显示字符串" class="headerlink" title="显示字符串"></a>显示字符串</h4><h5 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h5><p>显示字符串是现实工作中经常要用到的功能，应该编写一个通用的子程序来实现这个功<br>能.我们应该提供灵活的调用接口，使调用者可以决定显示的位置(行、列)、内容和颜色。</p>
<h5 id="子程序描述"><a href="#子程序描述" class="headerlink" title="子程序描述"></a>子程序描述</h5><p>名称:show str<br>功能:在指定的位置，用指定的颜色，显示一个用0结束的字符串。<br>参数:(dh)=行号(取值范围。-24), (dl)=列号(取值范围0-79),<br>      (cl)=颜色，ds:si指向字符串的首地址<br>返回:无<br>应用举例:在屏幕的8行3列，用绿色显示data段中的字符串。</p>
<h4 id="提示"><a href="#提示" class="headerlink" title="提示"></a>提示</h4><ol>
<li>子程序的入口参数是屏幕上的行号和列号，注意在子程序内部要将它们转化为显存中的地址，首先要分析一下屏幕上的行列位置和显存地址的对应关系:</li>
<li>注意保存子程序中用到的相关寄存器:</li>
<li>这个子程序的内部处理和显存的结构密切相关.但是向外提供了与显存结构无关的接口。通过调用这个子程序，进行字符串的显示时可以不必了解显存的结构，为编程提供了方便。在实验中，注意体会这种设计思想。</li>
<li>其实这玩意，就是抢占了本来应该在屏幕中输出的系统信息。那么设置行列号的，就是占的信息的位置。<details>
<summary><mark><font color="darkred">点击查看参考代码</font></mark></summary>
<pre><code>  
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code,ds:data</span><br><span class="line"></span><br><span class="line">data segment</span><br><span class="line">	db &apos;Welcome to masm!&apos;,0</span><br><span class="line">data ends</span><br><span class="line"></span><br><span class="line">code segment</span><br><span class="line">start:	</span><br><span class="line">	mov dh,8	;行号</span><br><span class="line">	mov dl,3	;列号</span><br><span class="line">	mov cl,07h	;白色字	</span><br><span class="line">	mov ax,data</span><br><span class="line">	mov ds,ax</span><br><span class="line">	mov si,0	;循环加入字</span><br><span class="line">	call show_str</span><br><span class="line"></span><br><span class="line">	mov ax,4c00h</span><br><span class="line">	int 21h</span><br><span class="line">show_str:</span><br><span class="line">	push cx	;保存用到的寄存器</span><br><span class="line">	push si</span><br><span class="line">	push es</span><br><span class="line">	push di</span><br><span class="line">	push bx</span><br><span class="line"></span><br><span class="line">	mov ax,0b800h</span><br><span class="line">	mov es,ax</span><br><span class="line"></span><br><span class="line">	mov al,0a0h	;一行的总列数160字节</span><br><span class="line">	dec dh		;行号减1，因为是从0开始的</span><br><span class="line">	mul dh		;计算行开始偏移地址</span><br><span class="line">	mov bx,ax</span><br><span class="line"></span><br><span class="line">	mov al,2</span><br><span class="line">	mul dl		;计算列</span><br><span class="line">	sub ax,2	;列也是从0开始，而且一个字符占两个字节</span><br><span class="line">	add bx,ax	;求出开始位置	</span><br><span class="line">	</span><br><span class="line">	mov di,0</span><br><span class="line">	mov al,cl</span><br><span class="line">	mov ch,0	;高8位为0</span><br><span class="line">s:	</span><br><span class="line">	mov cl,ds:[si]	;判断是否到了字符结束</span><br><span class="line">	jcxz ok</span><br><span class="line">	mov es:[bx+di],cl</span><br><span class="line">	mov es:[bx+di+1],al</span><br><span class="line"></span><br><span class="line">	inc si</span><br><span class="line">	add di,2</span><br><span class="line">	jmp short s</span><br><span class="line">ok:</span><br><span class="line">	pop bx</span><br><span class="line">	pop di</span><br><span class="line">	pop es</span><br><span class="line">	pop si</span><br><span class="line">	pop cx</span><br><span class="line">	ret</span><br><span class="line"></span><br><span class="line">code ends</span><br><span class="line"></span><br><span class="line">end start</span><br></pre></td></tr></table></figure>
</code></pre>
</details>

</li>
</ol>
<h3 id="解决除法溢出问题"><a href="#解决除法溢出问题" class="headerlink" title="解决除法溢出问题"></a>解决除法溢出问题</h3><h4 id="问题："><a href="#问题：" class="headerlink" title="问题："></a>问题：</h4><p>其实就是如果商超过了应该存储商的寄存器的大小，应该怎么办。emmm可以用大一点的，用dword</p>
<h1 id="第十一章-标志寄存器"><a href="#第十一章-标志寄存器" class="headerlink" title="第十一章 标志寄存器"></a>第十一章 标志寄存器</h1><p>这是一种特殊的寄存器，一共16位：</p>
<ol>
<li>用来存储相关指令的执行结果</li>
<li>用来为CPU执行相关指令提供行为依据</li>
<li>用来控制CPU的相关工作方式<br>其分布如下：</li>
</ol>
<table>
<thead>
<tr>
<th>15</th>
<th>14</th>
<th>13</th>
<th>12</th>
<th>11</th>
<th>10</th>
<th>9</th>
<th>8</th>
<th>7</th>
<th>6</th>
<th>5</th>
<th>4</th>
<th>3</th>
<th>2</th>
<th>1</th>
<th>0</th>
</tr>
</thead>
<tbody><tr>
<td>*</td>
<td>*</td>
<td>*</td>
<td>*</td>
<td>OF</td>
<td>DF</td>
<td>IF</td>
<td>TF</td>
<td>SF</td>
<td>ZF</td>
<td>*</td>
<td>AF</td>
<td>*</td>
<td>PF</td>
<td>*</td>
<td>CF</td>
</tr>
</tbody></table>
<p>其中*表示都没用：1 3 5 12 13 14 15在8086CPU中都没有使用。<br>注意：对标志位有影响的指令有：add,sub,mul,div,inc,or,and等，而没有影响的有：mov,push,pop等，它们大多数为传送指令。</p>
<h2 id="11-1-标志表"><a href="#11-1-标志表" class="headerlink" title="11.1 标志表"></a>11.1 标志表</h2><table>
<thead>
<tr>
<th>名称</th>
<th>代号</th>
<th>作用</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>零标志</td>
<td>ZF</td>
<td>判断结果是否为零</td>
<td>若为0则ZF=1，否则ZF=0</td>
</tr>
<tr>
<td>奇偶标志</td>
<td>PF</td>
<td>判断结果中1的个数是奇是偶</td>
<td>若1的个数为奇数则PF=0，否则为1</td>
</tr>
<tr>
<td>符号标志</td>
<td>SF</td>
<td>判断结果是正是负</td>
<td>若为正数则SF=0，否则为1</td>
</tr>
<tr>
<td>进位标志位</td>
<td>CF</td>
<td>在进行<strong>无符号</strong>运算时记录是否有向最高位<strong>进位</strong>或者<strong>借位</strong></td>
<td>那是假想的最高位</td>
</tr>
<tr>
<td>溢出标志</td>
<td>OF</td>
<td>判断是否超过容器所能装的最大数</td>
<td>如al=98+99=197，197&gt;127溢出，实际结果：-59</td>
</tr>
<tr>
<td>方向标志</td>
<td>DF</td>
<td>控制每次操作后si、di的增减</td>
<td>df=0 每次si,di增加；df=1 每次si,di减少。经常用作字符串的传送</td>
</tr>
</tbody></table>
<h2 id="11-2-与标志有关的指令"><a href="#11-2-与标志有关的指令" class="headerlink" title="11.2 与标志有关的指令"></a>11.2 与标志有关的指令</h2><h3 id="11-2-1-与CF相关的：adc-sdd指令"><a href="#11-2-1-与CF相关的：adc-sdd指令" class="headerlink" title="11.2.1 与CF相关的：adc,sdd指令"></a>11.2.1 与CF相关的：adc,sdd指令</h3><ol>
<li>adc：带进位加法。如：adc al,8h == al+8h+CF </li>
<li>sdd：带借位减法。如：sdd al,8h == al-8h-CF</li>
</ol>
<h3 id="11-2-2-与CF和ZF有关的：cmp指令（比较指令）"><a href="#11-2-2-与CF和ZF有关的：cmp指令（比较指令）" class="headerlink" title="11.2.2 与CF和ZF有关的：cmp指令（比较指令）"></a>11.2.2 与CF和ZF有关的：cmp指令（比较指令）</h3><p>指令格式：cmp <em>s1</em>,<em>s2</em><br>举个例子：cmp ax,bx<br>比对结果如下：</p>
<table>
<thead>
<tr>
<th>情况</th>
<th>结果分析</th>
<th>结果</th>
</tr>
</thead>
<tbody><tr>
<td><strong>(ax)=(bx)</strong></td>
<td>则(ax)-(bx)=0</td>
<td><strong>zf=1</strong>;</td>
</tr>
<tr>
<td><strong>(ax)≠(bx)</strong></td>
<td>则(ax)-(bx)≠0</td>
<td><strong>zf=0</strong>;</td>
</tr>
<tr>
<td><strong>(ax)&lt;(bx)</strong></td>
<td>则(ax卜(bx)将产生借位</td>
<td><strong>cf=1</strong>;</td>
</tr>
<tr>
<td><strong>(ax)≥(bx)</strong></td>
<td>则(ax)-(bx)不必借位</td>
<td><strong>cf=0</strong>;</td>
</tr>
<tr>
<td><strong>(ax)&gt;(bx)</strong></td>
<td>则(ax)-(bx)既<em>不必借位<em>，</em>结果又不为0</em></td>
<td><strong>cf=0并且zf=0</strong>;</td>
</tr>
<tr>
<td><strong>(ax)≤(bx)</strong></td>
<td>则(ax)-(bx)既<em>可能借位<em>，</em>结果可能为0</em></td>
<td><strong>cf=1或zf=1</strong>.</td>
</tr>
</tbody></table>
<h3 id="11-2-3-与CMP有关的比较结果条件转移指令"><a href="#11-2-3-与CMP有关的比较结果条件转移指令" class="headerlink" title="11.2.3 与CMP有关的比较结果条件转移指令"></a>11.2.3 与CMP有关的比较结果条件转移指令</h3><table>
<thead>
<tr>
<th>指令</th>
<th>含义</th>
<th>简记</th>
<th>符号</th>
<th>监测的相关标志位</th>
</tr>
</thead>
<tbody><tr>
<td>je</td>
<td>等于则转移</td>
<td>equal</td>
<td>=</td>
<td>zf=1</td>
</tr>
<tr>
<td>jne</td>
<td>不等于则转移</td>
<td>not equal</td>
<td>≠</td>
<td>zf=0</td>
</tr>
<tr>
<td>jb</td>
<td>低于则转移</td>
<td>below</td>
<td>＜</td>
<td>cf=1</td>
</tr>
<tr>
<td>jnb</td>
<td>不低于则转移</td>
<td>not below</td>
<td>≥</td>
<td>cf=0</td>
</tr>
<tr>
<td>ja</td>
<td>高于则转移</td>
<td>above</td>
<td>＞</td>
<td>cf=0且zf=0</td>
</tr>
<tr>
<td>jna</td>
<td>不高于则转移</td>
<td>not above</td>
<td>≤</td>
<td>cf=1或zf=1</td>
</tr>
</tbody></table>
<p>注意，这个一般是与cmp配合使用，如同call和ret一样，但是没有说一定要配合使用。</p>
<h3 id="11-2-4-与DF有关指令"><a href="#11-2-4-与DF有关指令" class="headerlink" title="11.2.4 与DF有关指令"></a>11.2.4 与DF有关指令</h3><table>
<thead>
<tr>
<th>指令</th>
<th>功能</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td>movsb</td>
<td>mov es:[di],byte ptr ds:[si]</td>
<td>从ds中取字符放到es指定的位置中，单位为字节，会令<strong>di和si同时±1</strong></td>
</tr>
<tr>
<td>movsw</td>
<td>mov es:[di],word ptr ds:[si]</td>
<td>从ds中取字符放到es指定的位置中，单位为字，会令di<strong>和si同时±2</strong></td>
</tr>
<tr>
<td>cld</td>
<td>设置df=0，正向</td>
<td>令di，si向增方向</td>
</tr>
<tr>
<td>std</td>
<td>设置df=1，逆向</td>
<td>令di，si向减方向</td>
</tr>
<tr>
<td>rep</td>
<td>重复指令，根据CX当中的值，与LOOP相似</td>
<td>配合movsb使用</td>
</tr>
</tbody></table>
<p>例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">我们来看下面的两个程序。</span><br><span class="line">(1)编程，用串传送指令，将data段中的第一个字符串复制到它后面的空间中。</span><br><span class="line">data segment</span><br><span class="line">db &apos;Welcome to masm!.</span><br><span class="line">db 16 dup (0)</span><br><span class="line">data ends</span><br><span class="line">我们分析一下，使用串传送指令进行数据的传送，需要给它提供一些必要的信息</span><br><span class="line">它们是:</span><br><span class="line">1. 传送的原始位置:ds:si:</span><br><span class="line">2. 传送的目的位置:es:di;</span><br><span class="line">3. 传送的长度:CX;</span><br><span class="line">4. 传送的方向:df.</span><br><span class="line">在这个问题中，这些信息如下。</span><br><span class="line">1. 传送的原始位置:data:O;</span><br><span class="line">2. 传送的目的位置:data:0010;</span><br><span class="line">3. 传送的长度:16;</span><br><span class="line">4. 传送的方向:因为正向传送(每次串传送指令执行后，Si和di递增此较方便，所以设置df=o</span><br><span class="line">好了，明确了这些信息之后，我们来编写程序:</span><br><span class="line">mov ax,data</span><br><span class="line">mov ds,ax</span><br><span class="line">mov si,0	;ds:si指向data: 0</span><br><span class="line">mov es,ax</span><br><span class="line">mov di,16	;es.di于行向data:0010</span><br><span class="line">mov cx,16	;(cx)-16, rep循环1‘次</span><br><span class="line">cld			;设置df=0，正向传送</span><br><span class="line">rep movsb</span><br></pre></td></tr></table></figure>

<h2 id="11-3-标志位有关的问题"><a href="#11-3-标志位有关的问题" class="headerlink" title="11.3 标志位有关的问题"></a>11.3 标志位有关的问题</h2><h3 id="11-3-1-单纯就符号标志位就可以判断结果的正负吗？（即判断相减的两个数的大小）"><a href="#11-3-1-单纯就符号标志位就可以判断结果的正负吗？（即判断相减的两个数的大小）" class="headerlink" title="11.3.1 单纯就符号标志位就可以判断结果的正负吗？（即判断相减的两个数的大小）"></a>11.3.1 单纯就符号标志位就可以判断结果的正负吗？（即判断相减的两个数的大小）</h3><p>当然不是！</p>
<blockquote>
<p>当1-2=-1&lt;0，则SF为1，表示负数，则前一个数比后一个数大<br>当34-(-96)=82H时，82H是-126的补码，所以SF=1，但是前一个数比后一个数大？当然不。</p>
</blockquote>
<p>为什么呢？<strong>因为发生了溢出</strong>。</p>
<ul>
<li>也就是说，保存结果的寄存器不足以表示那么大的数。</li>
<li>而34-(-96)=130明显超过127（假设保存结果的是ah）。 </li>
<li>那么结果就会表示为-126<em>（130-127=3，-128+3-1=-126）</em></li>
<li>而此时，SF=1，同时，<strong>OF=1</strong>。</li>
<li>所以<strong>要看结果的正负，要结合SF和OF的值</strong>.</li>
</ul>
<p>总结：</p>
<table>
<thead>
<tr>
<th>标志</th>
<th>结果</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>SF=1,OF=0</td>
<td>负</td>
<td>略</td>
</tr>
<tr>
<td>SF=1,OF=1</td>
<td>正</td>
<td>因为溢出导致实际结果为负，那么逻辑上必定为正</td>
</tr>
<tr>
<td>SF=0,OF=1</td>
<td>负</td>
<td>因为溢出导致实际结果为正，那么逻辑上必定为负</td>
</tr>
<tr>
<td>SF=0,OF=0</td>
<td>正</td>
<td>略</td>
</tr>
</tbody></table>
<h2 id="11-4-pushf和popf"><a href="#11-4-pushf和popf" class="headerlink" title="11.4 pushf和popf"></a>11.4 pushf和popf</h2><p>因为标志寄存器共16位，所以pushf就直接将16位当做寄存器放入栈中，popf是出栈。<br>注意，它们不需要加对象参数，<strong>入栈和出栈的对象都是标志寄存器</strong>！</p>
<h1 id="第十二章-内中断"><a href="#第十二章-内中断" class="headerlink" title="第十二章 内中断"></a>第十二章 内中断</h1><p>也就是CPU不再往下执行下去。而CPU内部的四种中断信息是：</p>
<ol>
<li>除法错误，如div指令产生的除法溢出（中断类型码：0）</li>
<li>单步执行（中断类型码：1）</li>
<li>执行into指令（中断类型码：4）</li>
<li>执行int指令（指令格式：int n，其中n是中断类型码，是字节型立即数）</li>
</ol>
<h2 id="12-1-中断一条龙（中断程序，中断向量表，中断过程）"><a href="#12-1-中断一条龙（中断程序，中断向量表，中断过程）" class="headerlink" title="12.1 中断一条龙（中断程序，中断向量表，中断过程）"></a>12.1 中断一条龙（中断程序，中断向量表，中断过程）</h2><p>中断过程：</p>
<ol>
<li>取得中断类型码（即中断向量表中的中断程序位置）</li>
<li>标志位入栈（因为执行中断过程要改变标志寄存器的值）</li>
<li>设置寄存器的<strong>TF</strong>和<strong>IF</strong>的值为0</li>
<li>CS内容入栈</li>
<li>IP内容入栈（结束中断程序回调的时候用，和call差不多）</li>
<li>从内存地址为中断类型码*4和中断类型码*4+2的两个字单元中读取中断处理程序的入口地址设置IP和CS。（用来取得<strong>中断程序在内存中的位置</strong>）</li>
</ol>
<p>其实就是：</p>
<ol>
<li>get N</li>
<li>pushf</li>
<li>TF=0, IF=0</li>
<li>push CS</li>
<li>push IP</li>
<li>(IP)=(N*4), (CS)=(N/4+2)</li>
<li>执行程序！</li>
</ol>
<h2 id="12-2-中断处理程序，安装，中断向量等"><a href="#12-2-中断处理程序，安装，中断向量等" class="headerlink" title="12.2 中断处理程序，安装，中断向量等"></a>12.2 中断处理程序，安装，中断向量等</h2><p>这个只是稍微述说，额，因为我不太能用到这个，作为了解而已。<br>中断处理程序就如同除法溢出程序一样（输出‘…overflow’），如何处理后续的事物做中断处理，然后返回系统程序。<br>而如果想要自己编一个中断处理程序，首先</p>
<ol>
<li>把中断码想好，把程序要放的地方想好，<em>*放入中断向量表</em></li>
<li>编程序，安装（写到相应位置）</li>
<li>测试</li>
</ol>
<p>这里当然要用到之前学的几乎所有内容（包括ret,movsb等）</p>
<h2 id="12-3-单步中断和TF-DF标志"><a href="#12-3-单步中断和TF-DF标志" class="headerlink" title="12.3 单步中断和TF,DF标志"></a>12.3 单步中断和TF,DF标志</h2><p>说到这里，你看标题就知道，TF肯定与单步中断有关，具体有什么关系呢？<br>首先说说<strong>单步中断</strong>，也就是不停止（退出）运行的程序，却能返回其实时的寄存器信息（也就是还在运行，只不过暂时停止了）。<br>而TF就是实现单步中断的重要标志，当<strong>TF=1</strong>时将引发单步中断，所以要想中断就先置TF=1。<br>这就是为什么中断执行（刚开始）就要把<strong>TF置0，就是为了防止步步中断</strong>！</p>
<h2 id="12-4-int指令"><a href="#12-4-int指令" class="headerlink" title="12.4 int指令"></a>12.4 int指令</h2><p>int指令引发的内中断很重要。虽然其过程与12.1所说的别无二致。<br>接下来就深入理解理解int、iret和栈：</p>
<h3 id="12-4-1-int、iret和栈"><a href="#12-4-1-int、iret和栈" class="headerlink" title="12.4.1 int、iret和栈"></a>12.4.1 int、iret和栈</h3><h1 id="第十三章-汇编语言重点知识总结"><a href="#第十三章-汇编语言重点知识总结" class="headerlink" title="第十三章 汇编语言重点知识总结"></a>第十三章 汇编语言重点知识总结</h1><h2 id="13-1寄存器与存储器"><a href="#13-1寄存器与存储器" class="headerlink" title="13.1寄存器与存储器"></a>13.1寄存器与存储器</h2><ol>
<li>寄存器功能</li>
</ol>
<ul>
<li>寄存器的一般用途和专用用途</li>
<li>CS:IP 控制程序执行流程</li>
<li>SS:SP 提供堆栈栈顶单元地址</li>
<li>DS:BX(SI,DI) 提供数据段内单元地址</li>
<li>SS:BP 提供堆栈内单元地址</li>
<li>ES:BX(SI,DI) 提供附加段内单元地址</li>
<li>AX,CX,BX 和CX 寄存器多用于运算和暂存中间计算结果,但又专用于某些指令(查阅指令<br>表)。</li>
<li>PSW 程序状态字寄存器只能通过专用指令（LAHF, SAHF)和堆栈(PUSHF,POPF)进行存取。</li>
</ul>
<ol start="2">
<li>存储器分段管理</li>
</ol>
<ul>
<li>解决了16 位寄存器构成20 位地址的问题</li>
<li>便于程序重定位</li>
<li>20 位物理地址=段地址* 16 + 偏移地址</li>
<li>程序分段组织: 一般由代码段,堆栈段,数据段和附加段组成,不设置堆栈段时则使用系统<br>内部的堆栈。</li>
</ul>
<ol start="3">
<li>堆栈</li>
</ol>
<ul>
<li>堆栈是一种先进后出的数据结构, 数据的存取在栈顶进行, 数据入栈使堆栈向地址减小<br>的方向扩展。</li>
<li>堆栈常用于保存子程序调用和中断响应时的断点以及暂存数据或中间计算结果。</li>
<li>堆栈总是以字为单位存取</li>
</ul>
<h2 id="13-2-指令系统与寻址方式"><a href="#13-2-指令系统与寻址方式" class="headerlink" title="13.2 指令系统与寻址方式"></a>13.2 指令系统与寻址方式</h2><ol>
<li>指令系统</li>
</ol>
<ul>
<li>计算机提供给用户使用的机器指令集称为指令系统,大多数指令为双操作数指令。执行指令<br>后,一般源操作数不变,目的操作数被计算结果替代。</li>
<li>机器指令由CPU 执行,完成某种运算或操作,8086/8088 指令系统中的指令分为6 类: 数据传<br>送,算术运算,逻辑运算,串操作,控制转移和处理机控制。</li>
</ul>
<ol start="2">
<li>寻址方式</li>
</ol>
<ul>
<li>寻址方式确定执行指令时获得操作数地址的方法</li>
<li>分为与数据有关的寻址方式(7 种)和与转移地址有关的寻址方式(4)种。</li>
<li>与数据有关的寻址方式的一般用途:</li>
</ul>
<blockquote>
<p>(1) 立即数寻址方式–将常量赋给寄存器或存储单元<br>(2) 直接寻址方式–存取单个变量<br>(3) 寄存器寻址方式–访问寄存器的速度快于访问存储单元的速度<br>(4) 寄存器间接寻址方式–访问数组元素<br>(5) 变址寻址方式<br>(6) 基址变址寻址方式<br>(7) 相对基址变址寻址方式<br>(5),(6),(7)都便于处理数组元素</p>
</blockquote>
<p>. 与数据有关的寻址方式中,提供地址的寄存器只能是BX,SI,DI 或BP<br>. 与转移地址有关的寻址方式的一般用途:</p>
<blockquote>
<p>(1) 段内直接寻址–段内直接转移或子程序调用<br>(2) 段内间接寻址–段内间接转移或子程序调用<br>(3) 段间直接寻址–段间直接转移或子程序调用<br>(4) 段间间接寻址–段间间接转移或子程序调用</p>
</blockquote>
<h2 id="13-3-汇编程序和汇编语言"><a href="#13-3-汇编程序和汇编语言" class="headerlink" title="13.3 汇编程序和汇编语言"></a>13.3 汇编程序和汇编语言</h2><ol>
<li>汇编程序</li>
</ol>
<ul>
<li>汇编程序是将汇编语言源程序翻译成二进制代码程序的语言处理程序,翻译的过程称为汇<br>编。</li>
</ul>
<ol start="2">
<li>汇编语言</li>
</ol>
<ul>
<li>汇编语言是用指令助记符,各种标识变量,地址,过程等的标识符书写程序的语言, 汇编语言<br>指令与机器指令一一对应。</li>
<li>伪指令,宏指令不是由CPU 执行的指令,而是由汇编程序在汇编期间处理的指令。</li>
<li>伪指令指示汇编程序如何完成数据定义,存储空间分配,组织段等工作。</li>
<li>宏指令可简化程序并减少程序书写量。</li>
<li>条件汇编伪指令的功能是确定是否汇编某段源程序,而不是实现程序分支,对未汇编的程序<br>将不产生相应的目标代码。</li>
<li>结构作为一种数据结构可将一组类型不同但有逻辑关联的数据组织在一起,便于整体处理<br>数据。</li>
<li>记录可用于提高存储单元的利用率,将若干不足一个字节或字且有逻辑关联的信息压缩存<br>放在一个字节或字中。</li>
<li>指令中的表达式在汇编期间计算,并且只能对常量或地址进行计算。</li>
</ul>
<h2 id="13-4-程序设计基础"><a href="#13-4-程序设计基础" class="headerlink" title="13.4 程序设计基础"></a>13.4 程序设计基础</h2><ol>
<li>分支程序设计</li>
</ol>
<ul>
<li>程序分支由条件转移指令或无条件转移指令实现</li>
<li>存放若干目的转移地址或跳转指令的跳转表常用于实现多路分支</li>
<li>条件转移指令只能实现偏移量为-128 至+127 字节范围的转移</li>
<li>无条件转移指令根据寻址方式可实现短转移(偏移量为-128 至+127 字节),段内转移,段间<br>转移。</li>
</ul>
<ol start="2">
<li>循环程序设计</li>
</ol>
<ul>
<li>可由循环控制指令或条件转移指令组织循环结构</li>
<li>内层循环结构必须完全包含在外层循环结构内,并不能发生从循环结构外向循环结构内的<br>转移。</li>
</ul>
<ol start="3">
<li>子程序设计</li>
</ol>
<ul>
<li>子程序中应保护寄存器内容,并正确使用堆栈, 成对执行PUSH 和POP 指令，保证执行RET<br>指令时堆栈栈顶为返回地址。</li>
<li>主程序可通过寄存器,参数表,或堆栈传递参数给子程序</li>
</ul>
<ol start="4">
<li>EXE 文件和COM 文件</li>
</ol>
<ul>
<li>二者都是可执行文件</li>
<li>COM 文件源程序的特点是: 第一条可执行指令的起始存放地址必须是100H,不能分段,不用<br>定义堆栈,所有过程为NEAR 类型,直接用INT 20H 指令返回DOS。</li>
</ul>
<ol start="5">
<li>DOS 功能调用与BIOS 中断调用</li>
</ol>
<ul>
<li>二者都是完成DOS 系统提供给用户的输入/输出等常用功能,通过执行软中断指令完成一<br>次软中断服务。</li>
<li>DOS 功能调用的中断服务程序是操作系统的一部分,存于RAM 中; 而BIOS 中断调用的中<br>断服务程序存放在ROM 中。</li>
</ul>
<h2 id="13-5-输入-输出与中断系统"><a href="#13-5-输入-输出与中断系统" class="headerlink" title="13.5 输入/输出与中断系统"></a>13.5 输入/输出与中断系统</h2><ol>
<li>输入/输出的方式</li>
</ol>
<ul>
<li>程序直接I/O 方式: 用IN 和OUT 指令直接在端口级上进行I/O 操作,数据传送方式分为无<br>条件传送方式和查询传送方式。</li>
<li>中断传送方式: 由CPU 响应中断请求完成中断服务。</li>
<li>DMA 传送方式: 直接在存储器与外设之间传送数据。</li>
</ul>
<ol start="2">
<li>有关中断的概念</li>
</ol>
<ul>
<li>中断、中断源、中断请求、中断服务、中断向量、中断向量表、中断响应过程、中断指令、<br>开中断、关中断、内部中断、外部中断、可屏蔽中断、非屏蔽中断。</li>
</ul>
<ol start="3">
<li>键盘I/O、显示器I/O 操作</li>
</ol>
<ul>
<li>键盘的输入操作用BIOS 的16H 中断调用控制,也可直接访问60H 端口(数据端口), 61H 端<br>口(状态端口)检测键盘的按键操作。</li>
<li>对于特殊键（如Shift , Ctrl , Alt , NumLock , ScrollLock 等键）的按动情况，可以直接从来<br>40:17H 单元取得有关信息。</li>
<li>显示器的图形显示可以用BIOS 的10H 中断调用实现,另一种速度更快的方法是直接读写<br>视频缓冲区。</li>
</ul>
<ol start="4">
<li>打印机I/O 操作由INT 17H 中断调用实现， 串行通讯口操作由INT 14H 中断调用实现。<br>CLD Clear the direction flag (set to forward direction)<br>将方向标志置0，使si 和di 增量，串处理从低地址向高地址处理</li>
</ol>
<h2 id="13-6-8088-汇编速查手册"><a href="#13-6-8088-汇编速查手册" class="headerlink" title="13.6 8088 汇编速查手册"></a>13.6 8088 汇编速查手册</h2><h3 id="13-6-1-数据传输指令"><a href="#13-6-1-数据传输指令" class="headerlink" title="13.6.1 数据传输指令"></a>13.6.1 数据传输指令</h3><p>它们在存贮器和寄存器、寄存器和输入输出端口之间传送数据.</p>
<ol>
<li>通用数据传送指令.</li>
</ol>
<table>
<thead>
<tr>
<th>指令</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>MOV</td>
<td>传送字或字节.</td>
</tr>
<tr>
<td>MOVSX</td>
<td>先符号扩展,再传送.</td>
</tr>
<tr>
<td>MOVZX</td>
<td>先零扩展,再传送.</td>
</tr>
<tr>
<td>PUSH</td>
<td>把字压入堆栈.</td>
</tr>
<tr>
<td>POP</td>
<td>把字弹出堆栈.</td>
</tr>
<tr>
<td>PUSHA</td>
<td>把AX,CX,DX,BX,SP,BP,SI,DI 依次压入堆栈.</td>
</tr>
<tr>
<td>POPA</td>
<td>把DI,SI,BP,SP,BX,DX,CX,AX 依次弹出堆栈.</td>
</tr>
<tr>
<td>PUSHAD</td>
<td>把EAX,ECX,EDX, EBX,ESP,EBP,ESI,EDI 依次压入堆栈.</td>
</tr>
<tr>
<td>POPAD</td>
<td>把EDI,ESI,EBP,ESP,EBX,EDX, ECX,EAX 依次弹出堆栈.</td>
</tr>
<tr>
<td>BSWAP</td>
<td>交换32 位寄存器里字节的顺序</td>
</tr>
<tr>
<td>XCHG</td>
<td>交换字或字节.( 至少有一个操作数为寄存器,段寄存器不可作为操作数)</td>
</tr>
<tr>
<td>CMPXCHG</td>
<td>比较并交换操作数.( 第二个操作数必须为累加器AL/AX/EAX )</td>
</tr>
<tr>
<td>XADD</td>
<td>先交换再累加.( 结果在第一个操作数里)</td>
</tr>
<tr>
<td>XLAT</td>
<td>字节查表转换.── BX 指向一张256 字节的表的起点, AL 为表的索引值(0-255,即0-FFH); 返回AL 为查表结果. ( [BX+AL]-&gt;AL )</td>
</tr>
</tbody></table>
<ol start="2">
<li>输入输出端口传送指令.</li>
</ol>
<table>
<thead>
<tr>
<th>指令</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>IN</td>
<td>I/O 端口输入. ( 语法: IN 累加器, {端口号│DX} )</td>
</tr>
<tr>
<td>OUT</td>
<td>I/O 端口输出. ( 语法: OUT {端口号│DX},累加器)</td>
</tr>
<tr>
<td>输入输出端口由立即方式指定时, 其范围是0-255; 由寄存器DX 指定时,其范</td>
<td></td>
</tr>
<tr>
<td>围是0-65535.</td>
<td></td>
</tr>
</tbody></table>
<ol start="3">
<li>目的地址传送指令.</li>
</ol>
<table>
<thead>
<tr>
<th>指令</th>
<th>描述</th>
<th>例子</th>
</tr>
</thead>
<tbody><tr>
<td>LEA</td>
<td>装入有效地址.</td>
<td>例: LEA DX,string ;把偏移地址存到DX.</td>
</tr>
<tr>
<td>LDS</td>
<td>传送目标指针,把指针内容装入DS.</td>
<td>例: LDS SI,string ;把段地址:偏移地址存到DS:SI.</td>
</tr>
<tr>
<td>LES</td>
<td>传送目标指针,把指针内容装入ES.</td>
<td>例: LES DI,string ;把段地址:偏移地址存到ES:DI.</td>
</tr>
<tr>
<td>LFS</td>
<td>传送目标指针,把指针内容装入FS.</td>
<td>例: LFS DI,string ;把段地址:偏移地址存到FS:DI.</td>
</tr>
<tr>
<td>LGS</td>
<td>传送目标指针,把指针内容装入GS.</td>
<td>例: LGS DI,string ;把段地址:偏移地址存到GS:DI.</td>
</tr>
<tr>
<td>LSS</td>
<td>传送目标指针,把指针内容装入SS.</td>
<td>例: LSS DI,string ;把段地址:偏移地址存到SS:DI.</td>
</tr>
</tbody></table>
<ol start="4">
<li>标志传送指令. </li>
</ol>
<table>
<thead>
<tr>
<th>指令</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>LAHF</td>
<td>标志寄存器传送,把标志装入AH.</td>
</tr>
<tr>
<td>SAHF</td>
<td>标志寄存器传送,把AH 内容装入标志寄存器.</td>
</tr>
<tr>
<td>PUSHF</td>
<td>标志入栈.</td>
</tr>
<tr>
<td>POPF</td>
<td>标志出栈.</td>
</tr>
<tr>
<td>PUSHD</td>
<td>32 位标志入栈.</td>
</tr>
<tr>
<td>POPD</td>
<td>32 位标志出栈.</td>
</tr>
</tbody></table>
<h3 id="13-6-2-算术运算指令"><a href="#13-6-2-算术运算指令" class="headerlink" title="13.6.2 算术运算指令"></a>13.6.2 算术运算指令</h3><table>
<thead>
<tr>
<th>指令</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>ADD</td>
<td>加法.</td>
</tr>
<tr>
<td>ADC</td>
<td>带进位加法.</td>
</tr>
<tr>
<td>INC</td>
<td>加1.</td>
</tr>
<tr>
<td>AAA</td>
<td>加法的ASCII 码调整.</td>
</tr>
<tr>
<td>DAA</td>
<td>加法的十进制调整.</td>
</tr>
<tr>
<td>SUB</td>
<td>减法.</td>
</tr>
<tr>
<td>SBB</td>
<td>带借位减法.</td>
</tr>
<tr>
<td>DEC</td>
<td>减1.</td>
</tr>
<tr>
<td>NEC</td>
<td>求反(以0 减之).</td>
</tr>
<tr>
<td>CMP</td>
<td>比较.(两操作数作减法,仅修改标志位,不回送结果).</td>
</tr>
<tr>
<td>AAS</td>
<td>减法的ASCII 码调整.</td>
</tr>
<tr>
<td>DAS</td>
<td>减法的十进制调整.</td>
</tr>
<tr>
<td>MUL</td>
<td>无符号乘法.</td>
</tr>
<tr>
<td>IMUL</td>
<td>整数乘法.以上两条,结果回送AH 和AL(字节运算),或DX 和AX(字运算),</td>
</tr>
<tr>
<td>AAM</td>
<td>乘法的ASCII 码调整.</td>
</tr>
<tr>
<td>DIV</td>
<td>无符号除法.</td>
</tr>
<tr>
<td>IDIV</td>
<td>整数除法.以上两条,结果回送:商回送AL,余数回送AH, (字节运算);或商回送AX,余数回送DX, (字运算).</td>
</tr>
<tr>
<td>AAD</td>
<td>除法的ASCII 码调整.</td>
</tr>
<tr>
<td>CBW</td>
<td>字节转换为字. (把AL 中字节的符号扩展到AH 中去)</td>
</tr>
<tr>
<td>CWD</td>
<td>字转换为双字. (把AX 中的字的符号扩展到DX 中去)</td>
</tr>
<tr>
<td>CWDE</td>
<td>字转换为双字. (把AX 中的字符号扩展到EAX 中去)</td>
</tr>
<tr>
<td>CDQ</td>
<td>双字扩展. (把EAX 中的字的符号扩展到EDX 中去)</td>
</tr>
</tbody></table>
<h3 id="13-6-3-逻辑运算指令"><a href="#13-6-3-逻辑运算指令" class="headerlink" title="13.6.3 逻辑运算指令"></a>13.6.3 逻辑运算指令</h3><table>
<thead>
<tr>
<th>指令</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>AND</td>
<td>与运算.</td>
</tr>
<tr>
<td>OR</td>
<td>或运算.</td>
</tr>
<tr>
<td>XOR</td>
<td>异或运算.</td>
</tr>
<tr>
<td>NOT</td>
<td>取反.</td>
</tr>
<tr>
<td>TEST</td>
<td>测试.(两操作数作与运算,仅修改标志位,不回送结果).</td>
</tr>
<tr>
<td>SHL</td>
<td>逻辑左移.</td>
</tr>
<tr>
<td>SAL</td>
<td>算术左移.(=SHL)</td>
</tr>
<tr>
<td>SHR</td>
<td>逻辑右移.</td>
</tr>
<tr>
<td>SAR</td>
<td>算术右移.(=SHR)</td>
</tr>
<tr>
<td>ROL</td>
<td>循环左移.</td>
</tr>
<tr>
<td>ROR</td>
<td>循环右移.</td>
</tr>
<tr>
<td>RCL</td>
<td>通过进位的循环左移.</td>
</tr>
<tr>
<td>RCR</td>
<td>通过进位的循环右移.</td>
</tr>
</tbody></table>
<p>以上八种移位指令,其移位次数可达255 次.<br>移位一次时, 可直接用操作码. 如SHL AX,1.<br>移位&gt;1 次时, 则由寄存器CL 给出移位次数.<br>如MOV CL,04<br>SHL AX,CL</p>
<h3 id="13-6-4-串指令"><a href="#13-6-4-串指令" class="headerlink" title="13.6.4 串指令"></a>13.6.4 串指令</h3><table>
<thead>
<tr>
<th>指令</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>DS:SI</td>
<td>源串段寄存器:源串变址.</td>
</tr>
<tr>
<td>ES:DI</td>
<td>目标串段寄存器:目标串变址.</td>
</tr>
<tr>
<td>CX</td>
<td>重复次数计数器.</td>
</tr>
<tr>
<td>AL/AX 扫描值.</td>
<td></td>
</tr>
<tr>
<td>D</td>
<td>标志0 表示重复操作中SI 和DI 应自动增量; 1 表示应自动减量.</td>
</tr>
<tr>
<td>Z</td>
<td>标志用来控制扫描或比较操作的结束.</td>
</tr>
<tr>
<td>MOVS</td>
<td>串传送.( MOVSB 传送字符. MOVSW 传送字. MOVSD 传送双字. )</td>
</tr>
<tr>
<td>CMPS</td>
<td>串比较.( CMPSB 比较字符. CMPSW 比较字. )</td>
</tr>
<tr>
<td>SCAS</td>
<td>串扫描.把AL 或AX 的内容与目标串作比较,比较结果反映在标志位.</td>
</tr>
<tr>
<td>LODS</td>
<td>装入串.把源串中的元素(字或字节)逐一装入AL 或AX 中.( LODSB 传送字符. LODSW 传送字. LODSD 传送双字. )</td>
</tr>
<tr>
<td>STOS</td>
<td>保存串. 是LODS 的逆过程.</td>
</tr>
<tr>
<td>REP</td>
<td>当CX/ECX&lt;&gt;0 时重复.</td>
</tr>
<tr>
<td>REPE/REPZ</td>
<td>当ZF=1 或比较结果相等,且CX/ECX&lt;&gt;0 时重复.</td>
</tr>
<tr>
<td>REPNE/REPNZ</td>
<td>当ZF=0 或比较结果不相等,且CX/ECX&lt;&gt;0 时重复.</td>
</tr>
<tr>
<td>REPC</td>
<td>当CF=1 且CX/ECX&lt; &gt;0 时重复.</td>
</tr>
<tr>
<td>REPNC</td>
<td>当CF=0 且CX/ECX&lt;&gt;0 时重复.</td>
</tr>
</tbody></table>
<h2 id="13-6-5-程序转移指令"><a href="#13-6-5-程序转移指令" class="headerlink" title="13.6.5 程序转移指令"></a>13.6.5 程序转移指令</h2><ol>
<li><p>无条件转移指令(长转移)</p>
</li>
<li><table>
<thead>
<tr>
<th>指令</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>JMP</td>
<td>无条件转移指令</td>
</tr>
<tr>
<td>CALL</td>
<td>过程调用</td>
</tr>
<tr>
<td>RET/RETF</td>
<td>过程返回.</td>
</tr>
</tbody></table>
</li>
<li><p>条件转移指令(短转移,-128 到+127 的距离内)<br>( 当且仅当(SF XOR OF)=1 时,OP1&lt;OP2 )</p>
</li>
</ol>
<table>
<thead>
<tr>
<th>指令</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>JA/JNBE</td>
<td>不小于或不等于时转移.</td>
</tr>
<tr>
<td>JAE/JNB</td>
<td>大于或等于转移.</td>
</tr>
<tr>
<td>JB/JNAE</td>
<td>小于转移.</td>
</tr>
<tr>
<td>JBE/JNA</td>
<td>小于或等于转移.<br>以上四条,测试无符号整数运算的结果(标志C 和Z).</td>
</tr>
<tr>
<td>JG/JNLE</td>
<td>大于转移.</td>
</tr>
<tr>
<td>JGE/JNL</td>
<td>大于或等于转移.</td>
</tr>
<tr>
<td>JL/JNGE</td>
<td>小于转移.</td>
</tr>
<tr>
<td>JLE/JNG</td>
<td>小于或等于转移.<br>以上四条,测试带符号整数运算的结果(标志S,O 和Z).</td>
</tr>
<tr>
<td>JE/JZ</td>
<td>等于转移.</td>
</tr>
<tr>
<td>JNE/JNZ</td>
<td>不等于时转移.</td>
</tr>
<tr>
<td>JC</td>
<td>有进位时转移.</td>
</tr>
<tr>
<td>JNC</td>
<td>无进位时转移.</td>
</tr>
<tr>
<td>JNO</td>
<td>不溢出时转移.</td>
</tr>
<tr>
<td>JNP/JPO</td>
<td>奇偶性为奇数时转移.</td>
</tr>
<tr>
<td>JNS</td>
<td>符号位为”0” 时转移.</td>
</tr>
<tr>
<td>JO</td>
<td>溢出转移.</td>
</tr>
<tr>
<td>JP/JPE</td>
<td>奇偶性为偶数时转移.</td>
</tr>
<tr>
<td>JS</td>
<td>符号位为”1” 时转移.</td>
</tr>
</tbody></table>
<ol start="3">
<li>循环控制指令(短转移)</li>
</ol>
<table>
<thead>
<tr>
<th>指令</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>LOOP</td>
<td>CX 不为零时循环.</td>
</tr>
<tr>
<td>LOOPE/LOOPZ</td>
<td>CX 不为零且标志Z=1 时循环.</td>
</tr>
<tr>
<td>LOOPNE/LOOPNZ</td>
<td>CX 不为零且标志Z=0 时循环.</td>
</tr>
<tr>
<td>JCXZ</td>
<td>CX 为零时转移.</td>
</tr>
<tr>
<td>JECXZ</td>
<td>ECX 为零时转移.</td>
</tr>
</tbody></table>
<ol start="4">
<li>中断指令</li>
</ol>
<table>
<thead>
<tr>
<th>指令</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>INT</td>
<td>中断指令</td>
</tr>
<tr>
<td>INTO</td>
<td>溢出中断</td>
</tr>
<tr>
<td>IRET</td>
<td>中断返回</td>
</tr>
</tbody></table>
<ol start="5">
<li>处理器控制指令</li>
</ol>
<table>
<thead>
<tr>
<th>指令</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>HLT</td>
<td>处理器暂停, 直到出现中断或复位信号才继续.</td>
</tr>
<tr>
<td>WAIT</td>
<td>当芯片引线TEST 为高电平时使CPU 进入等待状态.</td>
</tr>
<tr>
<td>ESC</td>
<td>转换到外处理器.</td>
</tr>
<tr>
<td>LOCK</td>
<td>封锁总线.</td>
</tr>
<tr>
<td>NOP</td>
<td>空操作.</td>
</tr>
<tr>
<td>STC</td>
<td>置进位标志位.</td>
</tr>
<tr>
<td>CLC</td>
<td>清进位标志位.</td>
</tr>
<tr>
<td>CMC</td>
<td>进位标志取反.</td>
</tr>
<tr>
<td>STD</td>
<td>置方向标志位.</td>
</tr>
<tr>
<td>CLD</td>
<td>清方向标志位.</td>
</tr>
<tr>
<td>STI</td>
<td>置中断允许位.</td>
</tr>
<tr>
<td>CLI</td>
<td>清中断允许位.</td>
</tr>
</tbody></table>
<h3 id="13-6-6-伪指令"><a href="#13-6-6-伪指令" class="headerlink" title="13.6.6 伪指令"></a>13.6.6 伪指令</h3><table>
<thead>
<tr>
<th>指令</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>DW</td>
<td>定义字(2 字节).</td>
</tr>
<tr>
<td>PROC</td>
<td>定义过程.</td>
</tr>
<tr>
<td>ENDP</td>
<td>过程结束.</td>
</tr>
<tr>
<td>SEGMENT</td>
<td>定义段.</td>
</tr>
<tr>
<td>ASSUME</td>
<td>建立段寄存器寻址.</td>
</tr>
<tr>
<td>ENDS</td>
<td>段结束.</td>
</tr>
<tr>
<td>END</td>
<td>程序结束.</td>
</tr>
</tbody></table>

        
    </section>
</article>



<a id="pagenext" href="/2019/11/10/%E7%BD%91%E7%BB%9C%E6%B5%81%E9%87%8F%E5%88%86%E6%9E%90-nogotofail/" class="article-next" title="网络流量分析（nogotofail））"><i class="icon-arrow-right"></i></a>


<a id="pageprev" href="/2019/11/10/%E5%B7%A5%E5%85%B7OllyDbg%E7%9A%84%E4%BD%BF%E7%94%A8/" class="article-prev" title="工具OllyDbg的使用"><i class="icon-arrow-left"></i></a>




            </div>
        </div>
        <footer class="footer">
    Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>, Theme by <a href="https://github.com/sanonz/hexo-theme-concise" target="_blank">Concise</a>

    
    <script>
        var _hmt = _hmt || [];
        (function () {
            var hm = document.createElement("script");
            hm.src = "https://hm.baidu.com/hm.js?e4027971a230b210f4671f485b33846a";
            var s = document.getElementsByTagName("script")[0];
            s.parentNode.insertBefore(hm, s);
        })();
    </script>
    
</footer>

    </main>

    <script type="text/javascript" src="https://cdn.bootcss.com/jquery/1.9.0/jquery.min.js"></script>
    <script type="text/javascript">
    $(function() {
        var nodes = {
            nav: $('#nav'),
            aside: $('#aside'),
            asideInner: $('#aside-inner'),
            navInner: $('#nav-inner')
        };

        var doing = false;
        nodes.asideInner.on('webkitAnimationEnd mozAnimationEnd oAnimationEnd oanimationend animationend', function() {
            if (nodes.aside.hasClass('mobile-open')) {
                nodes.aside.removeClass('mobile-open');
            } else {
                nodes.aside.removeClass('mobile-close panel-show');
            }
            doing = false;
        });
        $('#open-panel, #aside-mask').on('click', function() {
            if (doing) {
                return;
            }

            if (nodes.aside.hasClass('panel-show')) {
                nodes.aside.addClass('mobile-close');
            } else {
                nodes.aside.addClass('mobile-open panel-show');
            }
        });
        $('#open-menus').on('click', function() {
            nodes.navInner.slideToggle();
        });

        if (window.innerWidth <= 960) {
            setTimeout(function() {
                nodes.navInner.slideUp();
            }, 3000);
        }
    });
    </script>
    
        <script src="/js/scrollspy.min.js"></script>
        <script type="text/javascript">
        $(document.body).scrollspy({target: '#aside-inner'});

        $(window).on('resize', function() {
            var hw = $('#header').width();
            var ww = $('#wrapper').width();
            var space = ($(this).width() - hw - ww) / 2 / 2;

            var pageprev = $('#pageprev');
            var pagenext = $('#pagenext');
            var avg = (pageprev.width() + pagenext.width()) / 2

            if(space > avg) {
                var len = space - avg / 2;
                var styles = {position: 'fixed', top: '50%', marginTop: - (pageprev.width() + pagenext.width()) / 4}
                pageprev.css($.extend({left: hw + len}, styles));
                pagenext.css($.extend({right: len}, styles));
            } else {
                pageprev.removeAttr('style');
                pagenext.removeAttr('style');
            }
        }).trigger('resize');
        </script>
    

</body>
</html>
